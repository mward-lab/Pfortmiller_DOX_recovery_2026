---
title: "DXR DE Analysis"
author: "Emma M Pfortmiller"
date: "2025-05-14"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: journal
    highlight: textmate
---

editor_options: 
  chunk_output_type: inline

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
pre {
  max-height: 400px;
  overflow-y: auto;
}

pre[class] {
  max-height: 200px;
  
}
```

I did this part with Sayan according to his analysis to ensure that my matrix was consistent with his - allowing me to work on downstream analysis
0#Read in Libraries
```{r Necessary Libraries, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(Biobase)
library(limma)
library(edgeR)
library(edgebundleR)
library(scales)
library(biomaRt)
library(ggrepel)
library(ggfortify)
library(corrplot)
library(readr)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(reshape2)
library(ggVennDiagram)
library(UpSetR)
library(ggpubr)
library(VennDiagram)
library(VennDetail)
library(BiocParallel)
library(RUVSeq)
library(SummarizedExperiment)
library(ggsignif)
library(purrr)
library(rstatix)
library(ggrastr)
library(tibble)
library(grid)
library(eulerr)
library(patchwork)
library(car)
library(gprofiler2)
library(forcats)
library(broom)

```

#Define custom plot theme
```{r Custom plot theme}

# # Define the custom theme
# plot_theme_custom <- function() {
#   theme_minimal() +
#     theme(
#       #line for x and y axis
#       axis.line = element_line(linewidth = 1,
#                                color = "black"),
# 
#       #axis ticks only on x and y, length standard
#       axis.ticks.x = element_line(color = "black",
#                                 linewidth = 1),
#       axis.ticks.y = element_line(color = "black",
#                                 linewidth = 1),
#       axis.ticks.length = unit(0.05, "in"),
# 
#       #text and font
#       axis.text = element_text(color = "black",
#                                family = "Arial",
#                                size = 7),
#       axis.title = element_text(color = "black",
#                                 family = "Arial",
#                                 size = 9),
#       legend.text = element_text(color = "black",
#                                  family = "Arial",
#                                  size = 7),
#       legend.title = element_text(color = "black",
#                                   family = "Arial",
#                                   size = 9),
#       plot.title = element_text(color = "black",
#                                 family = "Arial",
#                                 size = 10),
# 
#       #blank background and border
#       panel.background = element_blank(),
#       panel.border = element_blank(),
# 
#       #gridlines for alignment
#       panel.grid.major = element_line(color = "grey80", linewidth = 0.5),  #grey major grid for align in illus
#       panel.grid.minor = element_line(color = "grey90", linewidth = 0.5) #grey minor grid for align in illus
#     )
# }

# saveRDS(plot_theme_custom, "data/plot_theme_custom.RDS")

theme_custom <- readRDS("data/plot_theme_custom.RDS")

```

#Define saving plots as pdfs
```{r pdf saving function}

save_plot <- function(plot, filename, 
                      folder = ".", 
                      width = 8, 
                      height = 6, 
                      units = "in", 
                      dpi = 300, 
                      add_date = TRUE) {
  if (missing(filename)) stop("Please provide a filename (without extension) for the plot.")

  date_str <- if (add_date) paste0("_", format(Sys.Date(), "%y%m%d")) else ""
  pdf_file <- file.path(folder, paste0(filename, date_str, ".pdf"))
  png_file <- file.path(folder, paste0(filename, date_str, ".png"))
  ggsave(filename = pdf_file, plot = plot, device = cairo_pdf, width = width, height = height, units = units, bg = "transparent")
  ggsave(filename = png_file, plot = plot, device = "png", width = width, height = height, units = units, dpi = dpi, bg = "transparent")
  message("Saved plot as Cairo PDF: ", pdf_file)
  message("Saved plot as PNG: ", png_file)
}

output_folder <- "C:/Users/emmap/OneDrive/Desktop/DXR Manuscript Materials/Fig pdfs"


#save plot function created
#to use: just define the plot name, filename_base, width, height
```


#Read in Counts Files from FeatureCounts
```{r Create My Dataframe With All Counts Files}
#load in libraries needed
#these counts files are from featureCounts, all saved as RDS objects

#prev Ind1 84-1 is now Ind4

# ####Individual 1 - 87-1####
# Counts_87_DOX_24 <- readRDS("data/counts/Counts_87_DOX_24.RDS")
# Counts_87_DMSO_24 <- readRDS("data/counts/Counts_87_DMSO_24.RDS")
# Counts_87_DOX_24rec <- readRDS("data/counts/Counts_87_DOX_24rec.RDS")
# Counts_87_DMSO_24rec <- readRDS("data/counts/Counts_87_DMSO_24rec.RDS")
# Counts_87_DOX_144rec <- readRDS("data/counts/Counts_87_DOX_144rec.RDS")
# Counts_87_DMSO_144rec <- readRDS("data/counts/Counts_87_DMSO_144rec.RDS")
# 
# ####Individual 2 - 78-1####
# Counts_78_DOX_24 <- readRDS("data/counts/Counts_78_DOX_24.RDS")
# Counts_78_DMSO_24 <- readRDS("data/counts/Counts_78_DMSO_24.RDS")
# Counts_78_DOX_24rec <- readRDS("data/counts/Counts_78_DOX_24rec.RDS")
# Counts_78_DMSO_24rec <- readRDS("data/counts/Counts_78_DMSO_24rec.RDS")
# Counts_78_DOX_144rec <- readRDS("data/counts/Counts_78_DOX_144rec.RDS")
# Counts_78_DMSO_144rec <- readRDS("data/counts/Counts_78_DMSO_144rec.RDS")
# 
# ####Individual 3 - 75-1####
# Counts_75_DOX_24 <- readRDS("data/counts/Counts_75_DOX_24.RDS")
# Counts_75_DMSO_24 <- readRDS("data/counts/Counts_75_DMSO_24.RDS")
# Counts_75_DOX_24rec <- readRDS("data/counts/Counts_75_DOX_24rec.RDS")
# Counts_75_DMSO_24rec <- readRDS("data/counts/Counts_75_DMSO_24rec.RDS")
# Counts_75_DOX_144rec <- readRDS("data/counts/Counts_75_DOX_144rec.RDS")
# Counts_75_DMSO_144rec <- readRDS("data/counts/Counts_75_DMSO_144rec.RDS")
# 
# ####Individual 4 - 84-1####
# Counts_84_DOX_24 <- readRDS("data/counts/Counts_84_DOX_24.RDS")
# Counts_84_DMSO_24 <- readRDS("data/counts/Counts_84_DMSO_24.RDS")
# Counts_84_DOX_24rec <- readRDS("data/counts/Counts_84_DOX_24rec.RDS")
# Counts_84_DMSO_24rec <- readRDS("data/counts/Counts_84_DMSO_24rec.RDS")
# Counts_84_DOX_144rec <- readRDS("data/counts/Counts_84_DOX_144rec.RDS")
# Counts_84_DMSO_144rec <- readRDS("data/counts/Counts_84_DMSO_144rec.RDS")
# 
# ####Individual 5 - 17-3####
# Counts_17_DOX_24 <- readRDS("data/counts/Counts_17_DOX_24.RDS")
# Counts_17_DMSO_24 <- readRDS("data/counts/Counts_17_DMSO_24.RDS")
# Counts_17_DOX_24rec <- readRDS("data/counts/Counts_17_DOX_24rec.RDS")
# Counts_17_DMSO_24rec <- readRDS("data/counts/Counts_17_DMSO_24rec.RDS")
# Counts_17_DOX_144rec <- readRDS("data/counts/Counts_17_DOX_144rec.RDS")
# Counts_17_DMSO_144rec <- readRDS("data/counts/Counts_17_DMSO_144rec.RDS")
# 
# ####Individual 6 - 90-1####
# Counts_90_DOX_24 <- readRDS("data/counts/Counts_90_DOX_24.RDS")
# Counts_90_DMSO_24 <- readRDS("data/counts/Counts_90_DMSO_24.RDS")
# Counts_90_DOX_24rec <- readRDS("data/counts/Counts_90_DOX_24rec.RDS")
# Counts_90_DMSO_24rec <- readRDS("data/counts/Counts_90_DMSO_24rec.RDS")
# Counts_90_DOX_144rec <- readRDS("data/counts/Counts_90_DOX_144rec.RDS")
# Counts_90_DMSO_144rec <- readRDS("data/counts/Counts_90_DMSO_144rec.RDS")
# 
# ####Individual 7 - 90-1REP####
# Counts_90REP_DOX_24 <- readRDS("data/counts/Counts_90REP_DOX_24.RDS")
# Counts_90REP_DMSO_24 <- readRDS("data/counts/Counts_90REP_DMSO_24.RDS")
# Counts_90REP_DOX_24rec <- readRDS("data/counts/Counts_90REP_DOX_24rec.RDS")
# Counts_90REP_DMSO_24rec <- readRDS("data/counts/Counts_90REP_DMSO_24rec.RDS")
# Counts_90REP_DOX_144rec <- readRDS("data/counts/Counts_90REP_DOX_144rec.RDS")
# Counts_90REP_DMSO_144rec <- readRDS("data/counts/Counts_90REP_DMSO_144rec.RDS")

```

##Create my Dataframe from Counts Files
```{r Put Counts Together Into Dataframe}
#change 84-1 to Ind4 now
# counts_raw_df <-
#    data.frame(
#      Counts_87_DOX_24,
#      Counts_87_DMSO_24$MCW_EMP_JT_R38_R1.bam,
#      Counts_87_DOX_24rec$MCW_EMP_JT_R39_R1.bam,
#      Counts_87_DMSO_24rec$MCW_EMP_JT_R41_R1.bam,
#      Counts_87_DOX_144rec$MCW_EMP_JT_R42_R1.bam,
#      Counts_87_DMSO_144rec$MCW_EMP_JT_R44_R1.bam,
#      Counts_78_DOX_24$MCW_EMP_JT_R45_R1.bam,
#      Counts_78_DMSO_24$MCW_EMP_JT_R47_R1.bam,
#      Counts_78_DOX_24rec$MCW_EMP_JT_R48_R1.bam,
#      Counts_78_DMSO_24rec$MCW_EMP_JT_R50_R1.bam,
#      Counts_78_DOX_144rec$MCW_EMP_JT_R51_R1.bam,
#      Counts_78_DMSO_144rec$MCW_EMP_JT_R53_R1.bam,
#      Counts_75_DOX_24$MCW_EMP_JT_R54_R1.bam,
#      Counts_75_DMSO_24$MCW_EMP_JT_R56_R1.bam,
#      Counts_75_DOX_24rec$MCW_EMP_JT_R57_R1.bam,
#      Counts_75_DMSO_24rec$MCW_EMP_JT_R59_R1.bam,
#      Counts_75_DOX_144rec$MCW_EMP_JT_R60_R1.bam,
#      Counts_75_DMSO_144rec$MCW_EMP_JT_R62_R1.bam,
#      Counts_84_DOX_24$MCW_EMP_JT_R27_R1.bam,
#      Counts_84_DMSO_24$MCW_EMP_JT_R29_R1.bam,
#      Counts_84_DOX_24rec$MCW_EMP_JT_R30_R1.bam,
#      Counts_84_DMSO_24rec$MCW_EMP_JT_R32_R1.bam,
#      Counts_84_DOX_144rec$MCW_EMP_JT_R33_R1.bam,
#      Counts_84_DMSO_144rec$MCW_EMP_JT_R35_R1.bam,
#      Counts_17_DOX_24$MCW_EMP_JT_R63_R1.bam,
#      Counts_17_DMSO_24$MCW_EMP_JT_R65_R1.bam,
#      Counts_17_DOX_24rec$MCW_EMP_JT_R66_R1.bam,
#      Counts_17_DMSO_24rec$MCW_EMP_JT_R68_R1.bam,
#      Counts_17_DOX_144rec$MCW_EMP_JT_R69_R1.bam,
#      Counts_17_DMSO_144rec$MCW_EMP_JT_R71_R1.bam,
#      Counts_90_DOX_24$MCW_EMP_JT_R72_R1.bam,
#      Counts_90_DMSO_24$MCW_EMP_JT_R74_R1.bam,
#      Counts_90_DOX_24rec$MCW_EMP_JT_R75_R1.bam,
#      Counts_90_DMSO_24rec$MCW_EMP_JT_R77_R1.bam,
#      Counts_90_DOX_144rec$MCW_EMP_JT_R78_R1.bam,
#      Counts_90_DMSO_144rec$MCW_EMP_JT_R80_R1.bam,
#      Counts_90REP_DOX_24$MCW_EMP_JT_R81_R1.bam,
#      Counts_90REP_DMSO_24$MCW_EMP_JT_R83_R1.bam,
#      Counts_90REP_DOX_24rec$MCW_EMP_JT_R84_R1.bam,
#      Counts_90REP_DMSO_24rec$MCW_EMP_JT_R86_R1.bam,
#      Counts_90REP_DOX_144rec$MCW_EMP_JT_R87_R1.bam,
#      Counts_90REP_DMSO_144rec$MCW_EMP_JT_R89_R1.bam
#    )

#now save this as a matrix
# counts_raw_matrix <- counts_raw_df %>% column_to_rownames(var = "X") %>% as.matrix()

counts_raw_matrix <- readRDS("data/new/counts_raw_matrix.RDS")

dim(counts_raw_matrix)
#28395 is my initial amount of genes prior to filtering

#write this to a csv so I can save it for later
# write.csv(counts_raw_matrix, "C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/counts_raw_matrix_EMP_251112.csv")

#I also want to save this as an R object so I don't have to run the counts every time
# saveRDS(counts_raw_matrix, "data/new/counts_raw_matrix.RDS")

#I also want to change the names of the columns for my metadata sheet
# colnames(counts_raw_matrix) <- colnames(filcpm_matrix) 
# counts_raw_matrix_rename <- counts_raw_matrix

# write.csv(counts_raw_matrix_rename, "C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/counts_raw_matrix_rename_EMP_251205.csv")

```
###Include colors and factors for analysis
```{r Colors + Factors}
#I want to include the color schemes I have for my treatment, individuals, and timepoints
####Colors####
# tx_col <- c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")
# col_tx_large <- rep(c("#499FBD" , "#BBBBBC"), 21)
# col_tx_large_2 <- c(rep("#499FBD" , 3), rep("#BBBBBC", 3), 21)

# ind_col <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169", "#FF2362")

# ind_col_norep <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169")

# time_col <- c("#238B45", "#74C476", "#C7E9C0")

# cond_col <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169")

#this is the updated version of cond_col
txtime_col <- list(
  "DOX_t0" = "#263CA5",
  "VEH_t0" = "#444343",
  "DOX_t24" = "#5B8FD1",
  "VEH_t24" = "#757575",
  "DOX_t144" = "#89C5E5",
  "VEH_t144" = "#AAAAAA"
)

txtime_col_old <- list(
  "DOX_24T" = "#263CA5",
  "VEH_24T" = "#444343",
  "DOX_24R" = "#5B8FD1",
  "VEH_24R" = "#757575",
  "DOX_144R" = "#89C5E5",
  "VEH_144R" = "#AAAAAA"
)

#updated colors and factors:
ind_col <- list(
  "1" = "#FF9F64",
  "2" = "#78EBDA",
  "3" = "#ADCD77",
  "4" = "#E6CC50",
  "5" = "#A68AC0",
  "6" = "#F16F90",
  "6R" = "#C61E4E"
)

ind_col_nr <- list(
  "1" = "#FF9F64",
  "2" = "#78EBDA",
  "3" = "#ADCD77",
  "4" = "#E6CC50",
  "5" = "#A68AC0",
  "6" = "#F16F90"
)

time_col <- list(
  "t0" = "#005A4C",
  "t24" = "#328477",
  "t144" = "#8FB9B1")

tx_col <- list(
  "DOX" = "#499FBD", 
  "VEH" = "#BBBBBC")
  
```

#QC Mapping Plots
```{r QC Mapping Plots}
#this dataframe contains my alignment percentages from Subread
##already filtered to only include DOX + DMSO samples

#I want to change these to reflect the final order of samples
# fC_DOXCounts <- fC_DOXCounts %>%
#   mutate(
#     Ind = case_when(
#       Line == "87-1" ~ "1",
#       Line == "78-1" ~ "2",
#       Line == "75-1" ~ "3",
#       Line == "84-1" ~ "4",
#       Line == "17-3" ~ "5",
#       Line == "90-1" ~ "6",
#       Line == "90-1REP" ~ "6R",
#       TRUE ~ NA_character_
#     ),
#   Tx = ifelse(Treatment == "DMSO", "VEH", "DOX"),
#   Timepoint = case_when(
#     Time == "24" ~ "t0",
#     Time == "24rec" ~ "t24",
#     Time == "144rec" ~ "t144",
#     TRUE ~ NA_character_
#                      ),
#     Condition = paste0(Tx, "_", Timepoint, "_", Ind)
#   )


# fC_DOXCounts <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/fC_DOXCounts.RDS")
# #factor individual
# fC_DOXCounts <- fC_DOXCounts %>% 
#   mutate(
#     Ind = factor(Ind, levels = c("1", "2", "3", "4", "5", "6", "6R"),
#                  ordered = TRUE)
#   )


# fC_DOXCounts <- fC_DOXCounts %>%
#   mutate(
#     Ind = factor(Ind, levels = c("1", "2", "3", "4", "5", "6", "6R"), 
#                  ordered = TRUE),
#         Timepoint = factor(Timepoint, levels = c("t0", "t24", "t144"), 
#                        ordered = TRUE),
#         Tx = factor(Tx, levels = c("DOX", "VEH"), 
#                     ordered = TRUE)
#   ) %>%
#   mutate(
#     Condition = factor(
#       Condition,
#       levels = expand.grid(
#         Tx = levels(Tx),
#         Timepoint = levels(Timepoint),
#         Ind = levels(Ind)
#       ) %>%
#         transmute(Condition = paste(Tx, Timepoint, Ind, sep = "_")) %>%
#         pull(Condition),
#       ordered = TRUE
#     )
#   )

# saveRDS(fC_DOXCounts, "data/featureCounts_DOXdata_updatedind.RDS")
fC_DOXCounts <- readRDS("data/featureCounts_DOXdata_updatedind.RDS")

#Now I want to plot these values out

####Reads by Sample####
reads_by_sample <- c("DOX" = "#499FBD", "VEH" = "#BBBBBC")
fC_DOXCounts %>% 
  ggplot(., aes (x = Condition, y = Total_Align, fill = Tx, group_by = Ind))+
  geom_col()+
 geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_custom()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Read Counts by Treatment####
fC_DOXCounts %>% 
  ggplot(., aes (x = Tx, y= Total_Align, fill = Tx))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of reads by treatment"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Reads Per Individual####
fC_DOXCounts %>% 
  ggplot(., aes (x =as.factor(Ind), y=Total_Align))+
  geom_boxplot(aes(fill=as.factor(Ind)))+
 scale_fill_brewer(palette = "Dark2", name = "Individual")+
  ggtitle(expression("Total number of reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Reads Per Timepoint####
reads_by_time <- c("t0" = "#263CA5",
                 "t24" = "#5B8FD1",
                 "t144" = "#89c5e5")

map_by_time <- fC_DOXCounts %>% 
  ggplot(., aes (x = Condition, y = Assigned_Align, 
                 fill = Timepoint, group_by = Ind))+
  geom_col()+
 geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_time)+
  ggtitle(expression("Total number of mapped reads by timepoint"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_custom()+
  theme(
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.2),
        strip.text.y = element_text(color = "white"))

fC_DOXCounts$Time <- factor(fC_DOXCounts$Time, 
                            levels = c("t0", "t24", "t144"))


map_time_box <- fC_DOXCounts %>% 
  ggplot(., aes (x = Timepoint, y= Assigned_Align, fill = Timepoint))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_time)+
  ggtitle(expression("Total number of mapped reads by timepoint"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_custom()+
  theme(axis.ticks = element_line(linewidth = 1),
        axis.text.y = element_text(angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.2),
        strip.text.y = element_text(color = "white"))

# save_plot(plot = map_time_box,
          # filename = "MappedReads_Boxplot_Supp1C_EMP_",
          # folder = output_folder)

####Total Mapped Reads Per Drug####

reads_by_sample <- c("DOX" = "#5B8FD1", "VEH" = "#BBBBBC")
map_sample_plot <- fC_DOXCounts %>% 
  ggplot(., aes (x = Condition, y = Assigned_Align, fill = Tx,
                 group_by = Ind))+
  geom_col()+
 geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of mapped reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_custom()+
  theme(
        axis.text.y = element_text(angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.2),
        strip.text.y = element_text(color = "white"))

# save_plot(
#   plot = map_sample_plot,
#   filename = "MappedReads_Sample_Supp1A_EMP_",
#   folder = output_folder,
#   height = 5,
#   width = 8
# )

####Read Counts by Treatment####
map_tx_bp <- fC_DOXCounts %>% 
  ggplot(., aes (x =Tx, y= Assigned_Align, fill = Tx))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of mapped reads by treatment"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_custom()+
  theme(axis.text.y = element_text(angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.2),
        strip.text.y = element_text(color = "white"))

# save_plot(plot = map_tx_bp,
#           filename = "MappedReads_Treatment_Supp1B_EMP_",
#           folder = output_folder)

####Total Reads Per Individual####
fC_DOXCounts %>% 
  ggplot(., aes (x =as.factor(Ind), y=Assigned_Align))+
  geom_boxplot(aes(fill=as.factor(Ind)))+
 scale_fill_brewer(palette = "Dark2", name = "Individual")+
  ggtitle(expression("Total number of mapped reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

```

Now, I want to filter my dataframe
Before I can filter by rowMeans, I must convert to log2cpm
#Filter my Dataframe and Convert to log2cpm
```{r Dataframe Filtering}
#transform counts to cpm as a first step
counts_cpm_unfilt <- cpm(counts_raw_matrix, log = TRUE)
dim(counts_cpm_unfilt)
#I should have 28395 genes here since this is unfiltered

hist(counts_cpm_unfilt,  
     main = "Histogram of Unfiltered Counts", 
     xlab = expression("Log"[2]*" counts-per-million"), 
     col = 4)

###filter my data by rowMeans > 0 to exclude lowly expressed genes

filcpm_matrix <- subset(counts_cpm_unfilt, (rowMeans(counts_cpm_unfilt) > 0))
dim(filcpm_matrix)
#I should have 14319 genes here

#now let's make a histogram of this to check the difference
hist(filcpm_matrix,  
     main = "Histogram of Filtered Counts by rowMeans > 0", 
     xlab = expression("Log"[2]*" counts-per-million"), 
     col = 2)

#change the column names to match my samples - make sure that they are in the right order
#Individual 1 = 87-1 (F)
#Individual 2 = 78-1 (F)
#Individual 3 = 75-1 (F)
#Individual 4 = 84-1 (M)
#Individual 5 = 17-3 (M)
#Individual 6 = 90-1 (M)
#Individual 6REP = 90-1REP (M)

#Treatment/time should follow this order:
#DOX24tx
#DMSO24tx
#DOX24rec
#DMSO24rec
#DOX144rec
#DMSO144rec

# colnames(filcpm_matrix) <- c("DOX_24T_Ind1",
#                                 "DMSO_24T_Ind1",
#                                 "DOX_24R_Ind1",
#                                 "DMSO_24R_Ind1",
#                                 "DOX_144R_Ind1",
#                                 "DMSO_144R_Ind1",
#                                 "DOX_24T_Ind2",
#                                 "DMSO_24T_Ind2",
#                                 "DOX_24R_Ind2",
#                                 "DMSO_24R_Ind2",
#                                 "DOX_144R_Ind2",
#                                 "DMSO_144R_Ind2",
#                                 "DOX_24T_Ind3",
#                                 "DMSO_24T_Ind3",
#                                 "DOX_24R_Ind3",
#                                 "DMSO_24R_Ind3",
#                                 "DOX_144R_Ind3",
#                                 "DMSO_144R_Ind3",
#                                 "DOX_24T_Ind4",
#                                 "DMSO_24T_Ind4",
#                                 "DOX_24R_Ind4",
#                                 "DMSO_24R_Ind4",
#                                 "DOX_144R_Ind4",
#                                 "DMSO_144R_Ind4",
#                                 "DOX_24T_Ind5",
#                                 "DMSO_24T_Ind5",
#                                 "DOX_24R_Ind5",
#                                 "DMSO_24R_Ind5",
#                                 "DOX_144R_Ind5",
#                                 "DMSO_144R_Ind5",
#                                 "DOX_24T_Ind6",
#                                 "DMSO_24T_Ind6",
#                                 "DOX_24R_Ind6",
#                                 "DMSO_24R_Ind6",
#                                 "DOX_144R_Ind6",
#                                 "DMSO_144R_Ind6",
#                                 "DOX_24T_Ind6REP",
#                                 "DMSO_24T_Ind6REP",
#                                 "DOX_24R_Ind6REP",
#                                 "DMSO_24R_Ind6REP",
#                                 "DOX_144R_Ind6REP",
#                                 "DMSO_144R_Ind6REP")

#export this as a csv
# write.csv(filcpm_matrix, "data/new/filcpm_final_matrix.csv")

# saveRDS(filcpm_matrix, "data/new/filcpm_final_matrix_newind.RDS")
filcpm_matrix <- readRDS("data/new/filcpm_final_matrix_newind.RDS")

```
##QC Boxplots of Filtered vs Unfiltered Data
```{r QC Filtering Boxplots}
#make boxplots of all counts vs log2cpm filtered counts

#set the margins so the x axis isn't cut off
##I don't mind if this one is partially cut off since all you need is the library number and not the whole name
par(mar = c(8,4,2,2))
#boxplot of unfiltered cpm matrix
boxplot(counts_cpm_unfilt, 
        main = "Boxplots of Unfiltered log2cpm", 
        names = colnames(counts_cpm_unfilt), 
        adj=1, las = 2, cex.axis = 0.7)

#set the margins so the x axis isn't cut off
par(mar = c(8,4,2,2))
#boxplot of filtered cpm matrix
boxplot(filcpm_matrix, 
        main = "Boxplots of Filtered log2cpm (rowMeans > 0)", 
        names = colnames(filcpm_matrix), 
        adj=1, las = 2, cex.axis = 0.7)

```

After making my final matrix, I pulled the gene symbols from the entrez IDs I had as my rownames
I ran this initially and then moved the column into my final matrix
My final matrix is called filcpm_final_matrix.csv saved under data
#Put together my Data for Filtered Gene List
```{r Put Together My Data for Filtered Gene List}
##I did this earlier so don't run again, I put the list into the filcpm_final_matrix.csv (also already changed 84-1 to 4)

#load in my data
# sample_data <- read.csv("data/new/filcpm_final_matrix.csv")
#ensure Entrez_ID is present and in character Format 
# Check column names
# print(colnames(sample_data))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# sample_data <- sample_data %>% dplyr::rename(Entrez_ID = "X")
# # Convert Entrez_ID to character
# sample_data <- sample_data %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_data$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# ----------------- Join Back to Main Data -----------------
# sample_annotated <- left_join(sample_data, gene_symbols, by = c("Entrez_ID" = "ENTREZID"))
# ----------------- Save Annotated Output -----------------
# write_csv(sample_annotated, "data/Sample_annotated.csv")

#Since I ran this before, Sample_annotated.csv columns of EntrezID and Symbol have been copied into my final matrix - so disregard this file except for record-keeping

```

Now that I have my final matrix, I would like to check some key genes
I want to make sure that these genes are responding as we expect
We have triple checked this dataset to ensure that columns are in order
#Check my Response Genes in log2cpm format
```{r Check Response Genes log2cpm}
#Load in my count matrix
boxplot1 <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/filcpm_matrix_genes.RDS")
#this is the corrected individual!
# filcpm_matrix <- readRDS("data/new/filcpm_final_matrix_newind.RDS")


#save boxplot1 as an object filcpm_matrix_genes
# saveRDS(boxplot1, "data/new/filcpm_matrix_genes.RDS")

#Define gene list(s)
initial_test_genes <- c("CDKN1A", "MDM2", "BAX", "RARG", "TP53", "TOP2B", "TOP2A")  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data <- function(gene) {
  gene_data <- boxplot1 %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes) {
  gene_data <- process_gene_data(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene)) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```


Now I've confirmed with some boxplots that my genes are present and (mostly) behaving as they should
- Sayan's CDKN1A and MDM2 are initially high at 24hr in DOX 0.5
- My CDKN1A and MDM2 are similar to DMSO at 24hr DOX 0.5
  - These genes increase at DOX24R
  - These genes are also high at DOX144R but not as high as 24R
However, TP53 and BAX are acting similarly across our data
#PCA Analysis
```{r PCA Analysis}
#Now I want to check if my data is as expected on a PCA plot
#perform PCA calculations
prcomp_res_unfilt <- prcomp(t(counts_cpm_unfilt %>% as.matrix()), center =  TRUE)

prcomp_res_filt <- prcomp(t(filcpm_matrix %>% as.matrix()), center =  TRUE)

#read in my metadata annotations
#this has already had the individual number changed to move 84-1
Metadata <- read.csv("data/Metadata_update.csv")
#84-1 is now Ind4


#add in labels for individual numbers
ind_num <- c("1", "1", "1", "1", "1", "1", 
             "2", "2", "2", "2", "2", "2", 
             "3", "3", "3", "3", "3", "3", 
             "4", "4", "4", "4", "4", "4", 
             "5", "5", "5", "5", "5", "5", 
             "6", "6", "6", "6", "6", "6", 
             "6R", "6R", "6R", "6R", "6R", "6R")

# saveRDS(ind_num, "data/new/ind_num.RDS")


#now plot my PCA for unfiltered log2cpm
####PC1/PC2####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Cond", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=txtime_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Cond"
                  , shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=txtime_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()

####PC3/PC4####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Cond", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=txtime_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()


#Now plot my PCA for filtered log2cpm
####PC1/PC2####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Cond", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=txtime_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()


ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Cond", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=txtime_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()


####PC2/PC3####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Cond", shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=txtime_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()

####PC3/PC4####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()



ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Cond", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=txtime_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()

#now make a version for supplementary figure 2
autoplot(prcomp_res_filt,
         data = Metadata,
         colour = "Cond",
         shape = "Time",
         size = 5,
         x = 1,
         y = 2) +
  theme_custom() +
  # scale_color_manual(values = txtime_col) +
  geom_text_repel(aes(label = ind_num),       # use aes() here
                  nudge_y = 0.05,            # small nudge instead of vjust
                  max.overlaps = 50,
                  size = 5,                   # cex is not needed in ggplot2
                  segment.color = "grey50") + 
  ggtitle("PCA of global gene expression (pre-RUV)")

#save for figure generation

# ggsave("SuppFig2_pca_6x8_EMP.pdf", width = 8, height = 6, device = cairo_pdf,dpi = 300, path = output_folder)

```
#Correlation Heatmaps
```{r Correlation Heatmaps, fig.width=12, fig.height=10}

#check to make sure that the column names are correct
lcpm_2 <- filcpm_matrix
colnames(lcpm_2) <- Metadata$Final_sample_name

#compute the correlation matrices, one pearson and one spearman
cor_matrix_pearson <- cor(lcpm_2, 
                          y = NULL, 
                          use = "everything",  
                          method = "pearson")
cor_matrix_spearman <- cor(lcpm_2,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

# Extract metadata columns
Individual <- as.character(Metadata$Ind)
Time <- as.character(Metadata$Time)
Treatment <- as.character(Metadata$Treatment)

# Define color palettes for annotations
annot_col_cor = list(drugs = c("DOX" = "#499FBD", 
                               "VEH" = "#BBBBBC"),
                     individuals = c("1" = "#FFA364", 
                                     "2" = "#78EFDE", 
                                     "3" = "#A4D177", 
                                     "4" = "#EAD050", 
                                     "5" = "#A68AC0", 
                                     "6" = "#F16F90", 
                                     "6R" = "#C61E4E"),
                     timepoints = c("t0" = "#005A4C",
                                    "t24" = "#328477", 
                                    "t144" = "#8FB9B1"))

drug_colors <- c("DOX" = "#499FBD",
                 "VEH" = "#BBBBBC")
ind_colors <- c("1" = "#FFA364",
                "2" = "#78EFDE",
                "3" = "#A4D177",
                "4" = "#EAD050",
                "5" = "#A68AC0",
                "6" = "#F16F90",
                "6R" = "#C61E4E")
time_colors <- c("t0" = "#005A4C",
                 "t24" = "#328477",
                 "t144" = "#8FB9B1")

# Create annotations
top_annotation <- HeatmapAnnotation(
  Individual = Individual, 
  Time = Time,
  Treatment = Treatment,
  col = list(
    Individual = ind_colors, 
    Time = time_colors,
    Treatment = drug_colors
  )
)

####ANNOTATED HEATMAPS####
# pheatmap(cor_matrix_pearson, border_color = "black", legend = TRUE, angle_col = 90, display_numbers = FALSE, number_color = "black", fontsize = 10, fontsize_number = 5, annotation_col = top_annotation, annotation_colors = annot_col)

####Pearson Heatmap####
heatmap_pearson <- Heatmap(cor_matrix_pearson,
                           name = "Pearson",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE)

# Draw the heatmap
draw(heatmap_pearson)

####Spearman Heatmap####
heatmap_spearman <- Heatmap(cor_matrix_spearman,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE)

# Draw the heatmap
draw(heatmap_spearman)

```
#Make my Filtered Gene List
```{r Make Filtered Gene List}
#Now I want to make a filtered gene list (my rownames)
##I will use this to filter my counts for limma + Cormotif

filt_gene_list <- rownames(filcpm_matrix)
#save this filtered gene list as I'll use it to filter my counts
#saveRDS(filt_gene_list, "data/new/filt_gene_list.RDS")

```

##Filter my Counts For DE Analysis
```{r Filter Counts for DE}
# counts_raw_matrix <- readRDS("data/new/counts_raw_matrix.RDS")
#change column names to match samples for my raw counts matrix
#update them to the new nomenclature so I can have everything match up with Metadata new
# colnames(counts_raw_matrix) <- c("DOX_t0_1",
#                                 "VEH_t0_1",
#                                 "DOX_t24_1",
#                                 "VEH_t24_1",
#                                 "DOX_t144_1",
#                                 "VEH_t144_1",
#                                 "DOX_t0_2",
#                                 "VEH_t0_2",
#                                 "DOX_t24_2",
#                                 "VEH_t24_2",
#                                 "DOX_t144_2",
#                                 "VEH_t144_2",
#                                 "DOX_t0_3",
#                                 "VEH_t0_3",
#                                 "DOX_t24_3",
#                                 "VEH_t24_3",
#                                 "DOX_t144_3",
#                                 "VEH_t144_3",
#                                 "DOX_t0_4",
#                                 "VEH_t0_4",
#                                 "DOX_t24_4",
#                                 "VEH_t24_4",
#                                 "DOX_t144_4",
#                                 "VEH_t144_4",
#                                 "DOX_t0_5",
#                                 "VEH_t0_5",
#                                 "DOX_t24_5",
#                                 "VEH_t24_5",
#                                 "DOX_t144_5",
#                                 "VEH_t144_5",
#                                 "DOX_t0_6",
#                                 "VEH_t0_6",
#                                 "DOX_t24_6",
#                                 "VEH_t24_6",
#                                 "DOX_t144_6",
#                                 "VEH_t144_6",
#                                 "DOX_t0_6R",
#                                 "VEH_t0_6R",
#                                 "DOX_t24_6R",
#                                 "VEH_t24_6R",
#                                 "DOX_t144_6R",
#                                 "VEH_t144_6R")

# saveRDS(counts_raw_matrix, "data/new/counts_raw_matrix.RDS")

counts_raw_matrix <- readRDS("data/new/counts_raw_matrix.RDS")

#subset my count matrix based on filtered CPM matrix
x <- counts_raw_matrix[row.names(filcpm_matrix),]
dim(x)
# saveRDS(x, "data/new/x_dge_counts_allind_updated.RDS")
#14319 genes as expected!
#this is still in counts form

#remove my replicate individual at this time
x_norep <- x[,1:36]

# saveRDS(x_norep, "data/new/x_norep.RDS")

Metadata <- read.csv("data/Metadata_update.csv")

#modify my metadata to match
Metadata_2 <- Metadata[1:36,]
rownames(Metadata_2) <- Metadata_2$Sample_bam
colnames(x_norep) <- Metadata_2$Sample_ID
rownames(Metadata_2) <- Metadata_2$Sample_ID

Metadata_2$Condition <- make.names(Metadata_2$Cond)
Metadata_2$Ind <- as.character(Metadata_2$Ind)

# saveRDS(Metadata_2, "data/Metadata_2_norep_update.RDS")

Metadata_2 <- readRDS("data/Metadata_2_norep_update.RDS")
```
#Perform Differential Expression Analysis 
```{r Differential Expression Analysis}

#create DGEList object
dge <- DGEList(counts = x_norep)
dge$samples$group <- factor(Metadata_2$Condition)
dge <- calcNormFactors(dge, method = "TMM")

# saveRDS(dge, "data/new/dge_matrix.RDS")

# check normalization factors from TMM normalization of LIBRARIES
dge$samples

#create my design matrix for DE
design <- model.matrix(~ 0 + Metadata_2$Condition)
colnames(design) <- gsub("Metadata_2\\$Condition", "", colnames(design))

#take care that the matrix automatically sorts cols alphabetically
##currently DOX_t0, DOX_t144, DOX_t24, VEH_t0, VEH_t144, VEH_t24

#run duplicate correlation for individual effect
corfit <- duplicateCorrelation(object = dge$counts, design = design, block = Metadata_2$Ind)

#voom transformation and plot
v <- voom(dge, design, block = Metadata_2$Ind, correlation = corfit$consensus.correlation, plot = TRUE)

#fit my linear model
fit <- lmFit(v, design, block = Metadata_2$Ind, correlation = corfit$consensus.correlation)

#make my contrast matrix to compare across tx and veh
contrast_matrix <- makeContrasts(
  V.D24T = DOX_t0 - VEH_t0,
  V.D24R = DOX_t24 - VEH_t24, 
  V.D144R = DOX_t144 - VEH_t144,
  levels = design
)

#apply these contrasts to compare DOX to DMSO VEH
fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2)

#plot the mean-variance trend
plotSA(fit2, main = "Final model: Mean-Variance trend")

#look at the summary of your results
##this tells you the number of DEGs in each condition
results_summary <- decideTests(fit2, adjust.method = "BH", p.value = 0.05)
summary(results_summary)
#        V.D24 V.D24r V.D144r
# Down    4723   3593     359
# NotSig  5076   7151   13810
# Up      4520   3575     150

vennDiagram(object = results_summary, include = c("up", "down"))

```
##Create Toptables of my DEGs
```{r Make Toptables of DEGs}

# Generate Top Table for Specific Comparisons

Toptable_V.D24T <- topTable(fit = fit2, coef = "V.D24T", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24T, "data/new/DEGs/Toptable_V.D24T.csv")

Toptable_V.D24R <- topTable(fit = fit2, coef = "V.D24R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24R, "data/new/DEGs/Toptable_V.D24R.csv")

Toptable_V.D144R <- topTable(fit = fit2, coef = "V.D144R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D144R, "data/new/DEGs/Toptable_V.D144R.csv")

#save all of these toptables as R objects
# saveRDS(list(
#   V.D24T = Toptable_V.D24T,
#   V.D24R = Toptable_V.D24R,
#   V.D144R = Toptable_V.D144R
# ), file = "data/new/Toptable_list.RDS")

Toptable_list <- readRDS("data/new/Toptable_list.RDS")

```

##Top 5 DEGs after DE Analysis per Condition
```{r Top 5 DEGs Limma}
#use your three toptables so I can pull out top 5 genes from each based on adj. p val

top5_D24T <- Toptable_V.D24T[order(Toptable_V.D24T$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")
top5_D24R <- Toptable_V.D24R[order(Toptable_V.D24R$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")
top5_D144R <- Toptable_V.D144R[order(Toptable_V.D144R$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")

#now that I've pulled the top 5 DEGs from each, make a list to pull them from my log2cpm data

boxplot1 <- readRDS("data/new/filcpm_matrix_genes.RDS") %>% 
  as.data.frame()

#Define gene list
#these are the top 5 genes pulled from my toptables
top5_D24T_geneslist <- c(top5_D24T$Entrez_ID)
top5_D24R_geneslist <- c(top5_D24R$Entrez_ID)
top5_D144R_geneslist <- c(top5_D144R$Entrez_ID)
#Add more gene symbols as needed or add more categories

#now pull these from my log2cpm matrix
top5_D24T_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D24T_geneslist,]
dim(top5_D24T_genes)
#5 genes in 44 cols
top5_D24R_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D24R_geneslist,]
dim(top5_D24R_genes)
#5 genes in 44 cols
top5_D144R_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D144R_geneslist,]
dim(top5_D144R_genes)
#5 genes in 44 cols

#Now put in the function I want to use to generate boxplots of genes
#####D24T#####
process_top5_D24T <- function(gene) {
  gene_data <- top5_D24T_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24T_geneslist) {
  gene_data <- process_top5_D24T(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D24T")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D24R#####
process_top5_D24R <- function(gene) {
  gene_data <- top5_D24R_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24R_geneslist) {
  gene_data <- process_top5_D24R(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D24R")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D144R#####
process_top5_D144R <- function(gene) {
  gene_data <- top5_D144R_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D144R_geneslist) {
  gene_data <- process_top5_D144R(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D144R")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```
##LogFC Boxplots for All Conditions
```{r DOX24T DEGs logFC all Conditions}
# Toptable_V.D24T

# Load DEGs Data
DOX_24T <- read.csv("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- read.csv("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- read.csv("data/new/DEGs/Toptable_V.D144R.csv")

#make a list of all of the genes in this set so I can plot the logFC in other sets
D24T_DEGs <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)
#9243 genes in length after adj. p value cutoff
#if I did p value only - 9658 genes

#now that I have a list of my DEGs from D24T - pull these genes out from the other DEG lists
# D24R_DEGs <- Toptable_V.D24R[Toptable_V.D24R$adj.P.Val < 0.05,]

# D24R_DEGs_D24T <- D24R_DEGs %>%  
#   rownames_to_column(., var = "Entrez_ID")

# D24R_DEGs_D24T <- D24R_DEGs_D24T[D24R_DEGs_D24T$Entrez_ID %in% D24T_DEGs,]
# dim(D24R_DEGs_D24T)
#4831 genes in common here after adj p value cutoff

# D144R_DEGs <- Toptable_V.D144R[Toptable_V.D144R$adj.P.Val < 0.05,]
# 
# D144R_DEGs_D24T <- D144R_DEGs %>%  
#   rownames_to_column(., var = "Entrez_ID")
# 
# D144R_DEGs_D24T <- D144R_DEGs_D24T[D144R_DEGs_D24T$Entrez_ID %in% D24T_DEGs,]
# dim(D144R_DEGs_D24T)
#322 genes in common after adj p value cutoff

#now I want to plot the logFC of these

#ignore the above for now, just plot those full gene sets in logFC
D24T_DEGs <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)

D24R_DEGs <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
length(D24R_DEGs)

D144R_DEGs <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]
length(D144R_DEGs)
#now that I have the full list of genes, I want to plot the logFC across conditions
#to do this - make a combined toptable

# Toptable_list

#plot the set of genes across conditions
# 
# logFC_long_allsets <- imap_dfr(Toptable_list, function(tbl, condition) {
#   tbl %>% 
#     rownames_to_column(var = "Entrez_ID") %>% 
#     dplyr::select(Entrez_ID, logFC) %>% 
#     mutate(Condition = condition)
# })
# 
# 
# ggplot(logFC_long_allsets, aes(x = Condition, y = logFC, group = Entrez_ID, color = Entrez_ID)) +
#   geom_boxplot() +
#   geom_point(size = 2) +
#   labs(
#     title = "logFC of Genes Across Conditions",
#     x = "Condition",
#     y = "logFC"
#   ) +
#   theme_minimal()


####Try this####

#Combine the toptables I have from pairwise analysis into a single dataframe
d0_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "t0")

d24_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "t24")

d144_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "t144")

combined_toptables_dxr <- bind_rows(
  d0_toptable_dxr,
  d24_toptable_dxr,
  d144_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D24T_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("t0", "t24", "t144"), labels = c("tx+0", "tx+24", "tx+144"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D24T DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now do the same with the other conditions

filt_toptable_dxr_24r <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D24R_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D24R DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#D144R

filt_toptable_dxr_144r <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D144R_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D144R DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now put the names of these graphs to print them
filt_toptable_dxr
filt_toptable_dxr_24r
filt_toptable_dxr_144r


```

#Perform RUVs Correction
##Set Up Data and Perform PCAs on Un-normalized Data
```{r RUVs Correction Data Setup - no RUV yet, fig.height=6, fig.width=8}

filt_gene_list <- rownames(filcpm_matrix)
#14319 genes as usual

#in order to make this match with annot later down the line, change the col names for counts_raw_matrix to match final_sample_names in annot

#i'll also want to make sure I keep the replicate for this set

colnames(counts_raw_matrix) <- Metadata$Final_sample_name

RUV_filt_counts <- counts_raw_matrix %>% 
  as.data.frame() %>% 
  dplyr::filter(., row.names(.)%in% filt_gene_list)

#add in the annotation files
ind_num <- readRDS("data/new/ind_num.RDS")
annot <- read.csv("data/Metadata_update.csv")
#same as Metadata


#  counts need to be integer values and in a numeric matrix
# note: the log transformation needs to be accounted for in the isLog argument in RUVs function.
counts <- as.matrix(RUV_filt_counts)
  
# saveRDS(counts, "data/new/RUV/filt_counts_matrix.RDS")

# Create a DataFrame for the phenoData
phenoData <- DataFrame(annot)

# Now create the RangedSummarizedExperiment necessary for RUVs input
# looks like it did need both the phenodata and the counts.
set <- SummarizedExperiment(assays =  counts, metadata = phenoData)

# Generate a background matrix
# The column "Cond" holds the comparisons that you actually want to make. DOX_24, DMSO_24,5FU_24, DOX_3,etc.
scIdx <- RUVSeq::makeGroups(phenoData$Cond)
scIdx

#now I've made all of the data I need for this - they are located in each section for k values

#DO NOT USE THESE COUNTS FOR LINEAR MODELING

#colors for all of the plots
# txtime_col
# ind_col
# time_col
# tx_col

# before ruv (counts PCA)
prcomp_res_counts <- prcomp(t(counts), scale. = FALSE, center = TRUE)
annot_prcomp_res <- prcomp_res_counts$x %>% cbind(., annot)

group_2 <- annot$Cond

#now plot my PCA for filtered counts
####PC1/PC2####
ggplot2::autoplot(prcomp_res_counts, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size = 4, 
                  x = 1, 
                  y = 2) +
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values = txtime_col) +
  ggtitle(expression("PCA of Filtered Counts")) +
  theme_custom()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_counts, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size = 4, 
                  x = 2, 
                  y = 3) +
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values = txtime_col) +
  ggtitle(expression("PCA of Filtered Counts")) +
  theme_custom()

#go ahead and plot PCA of log2cpm to compare (somewhat) later since the norm counts output isn't possible with these data since they don't undergo correction

prcomp_res_cpm <- prcomp(t(filcpm_matrix %>% as.matrix()), center =  TRUE)

####PC1/PC2####
ggplot2::autoplot(prcomp_res_cpm, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size = 4, 
                  x = 1, 
                  y = 2) +
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values = txtime_col) +
  ggtitle(expression("PCA of log2cpm no RUVs")) +
  theme_custom()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_cpm, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size = 4, 
                  x = 2, 
                  y = 3) +
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values = txtime_col) +
  ggtitle(expression("PCA of log2cpm no RUVs")) +
  theme_custom()


####new PCA plots no correction####
#PCA plots for each value of k attached in each section

#####Now start performing RUV 1-3###

```
##RUVs with k = 1 
```{r RUVs k1, fig.height=6, fig.width=8}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set1 <- RUVSeq::RUVs(x = counts, k =1, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=1
RUV_df1 <- set1$W %>% as.data.frame()
RUV_df1$Names <- rownames(RUV_df1)

#Check that the names match
#k=1
RUV_df_rm1 <- RUV_df1[RUV_df1$Names %in% annot$Final_sample_name, ] 
RUV_1 <-  RUV_df_rm1$W_1

# saveRDS(RUV_df_rm1, "data/new/RUV_df_rm1.RDS")
# saveRDS(RUV_1, "data/new/RUV_1.RDS")

#PCA checks
#k=1
prcomp_res_1 <- prcomp(t(set1$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_1 <- prcomp_res_1$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_1, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size =4, 
                  x = 1, 
                  y = 2)+
  theme_custom()+
  scale_color_manual(values = txtime_col)+
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 NormCounts")

ggplot2::autoplot(prcomp_res_1, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size = 4, 
                  x = 2,
                  y = 3)+
  theme_custom()+
  scale_color_manual(values = txtime_col)+
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 NormCounts")

#also try by converting these values to log2cpm

RUV_df_rm1_cpm <- cpm(set1$normalizedCounts, log = TRUE)

prcomp_res_1_cpm <- prcomp(t(RUV_df_rm1_cpm), scale. = FALSE, center = TRUE)
annot_prcomp_res_1_cpm <- prcomp_res_1_cpm$x %>% cbind(., annot)

##PC1/2
ggplot2::autoplot(prcomp_res_1_cpm, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size = 4,
                  x = 1,
                  y = 2)+
  theme_custom()+
  scale_color_manual(values = txtime_col)+
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 50)+
  ggtitle("RUVs Correction k=1 log2cpm")


###PC2/3
ggplot2::autoplot(prcomp_res_1_cpm, 
                  data = annot, 
                  colour = "Cond", 
                  shape = "Time", 
                  size = 4, 
                  x = 2, 
                  y = 3)+
  theme_custom()+
  scale_color_manual(values = txtime_col)+
  ggrepel::geom_text_repel(label = ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 log2cpm")


#make a larger version where the points stay together for figures

fig2a <- autoplot(prcomp_res_1_cpm,
         data = annot,
         colour = "Cond",
         shape = "Time",
         size = 5,
         x = 1,
         y = 2) +
  theme_custom() +
  scale_color_manual(values = txtime_col) +
  geom_text_repel(aes(label = ind_num),       
                  nudge_y = 0.05,            
                  max.overlaps = 100,                   
                  segment.color = "grey40") + 
  ggtitle("RUVs Correction k=1 log2cpm")

#save for figure generation

#before I knew how to save things - keep for posterity for now
# ggsave("fig2a_pca_6x8_EMP_new_251121.pdf", width = 6, height = 8, device = cairo_pdf)

# save_plot(plot = fig2a,
#           filename = "Fig2A_PCA_6x8_EMP",
#           folder = output_folder,
#           width = 6,
#           height = 8)


```

##RUVs with k = 2
```{r RUVs k2, fig.height=6, fig.width=8, include = FALSE}
# #Apply RUVs function from RUVSeq
# #"k" will be iteratively adjusted over time depending on your PCA.
# set2 <- RUVSeq::RUVs(x = counts, k =2, scIdx = scIdx, isLog = FALSE)
# 
# #get the ruv weights to put into the linear model. n weights = k.
# #k=2
# RUV_df2 <- set2$W %>% as.data.frame()
# RUV_df2$Names <- rownames(RUV_df2)
# 
# #Check that the names match
# #k=2
# RUV_df_rm2 <- RUV_df2[RUV_df2$Names %in% annot$Final_sample_name, ] 
# RUV_2 <-  RUV_df_rm2$W_2
# 
# #PCA checks
# #k=2
# prcomp_res_2 <- prcomp(t(set2$normalizedCounts), scale. = FALSE, center = TRUE)
# annot_prcomp_res_2 <- prcomp_res_2$x %>% cbind(., annot)
# 
# ##PC1/2
# ggplot2::autoplot(prcomp_res_2, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=1,
#                   y=2)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=2 NormCounts")
# 
# ###PC2/3
# ggplot2::autoplot(prcomp_res_2, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=2, 
#                   y=3)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=2 NormCounts")
# 
# #now convert this to log2cpm using the normalized counts from set2
# 
# RUV_df_rm2_cpm <- cpm(set2$normalizedCounts, log = TRUE)
# 
# prcomp_res_2_cpm <- prcomp(t(RUV_df_rm2_cpm), scale. = FALSE, center = TRUE)
# annot_prcomp_res_2_cpm <- prcomp_res_2_cpm$x %>% cbind(., annot)
# 
# ggplot2::autoplot(prcomp_res_2_cpm, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=1, 
#                   y=2)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=2 log2cpm")
# 
# ###PC2/3
# ggplot2::autoplot(prcomp_res_2_cpm, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=2, 
#                   y=3)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=2 log2cpm")

```

#RUVs with k = 3
```{r RUVs k3, fig.height=6, fig.width=8, include=FALSE}

# #Apply RUVs function from RUVSeq
# #"k" will be iteratively adjusted over time depending on your PCA.
# set3 <- RUVSeq::RUVs(x = counts, k =3, scIdx = scIdx, isLog = FALSE)
# 
# #get the ruv weights to put into the linear model. n weights = k.
# #k=3
# RUV_df3 <- set3$W %>% as.data.frame()
# RUV_df3$Names <- rownames(RUV_df3)
# 
# #Check that the names match
# #k=3
# RUV_df_rm3 <- RUV_df3[RUV_df3$Names %in% annot$Final_sample_name, ] 
# RUV_3 <-  RUV_df_rm3$W_3
# 
# #PCA checks
# #k=3
# prcomp_res_3 <- prcomp(t(set3$normalizedCounts), scale. = FALSE, center = TRUE)
# annot_prcomp_res_3 <- prcomp_res_3$x %>% cbind(., annot)
# 
# ###PC1/2
# ggplot2::autoplot(prcomp_res_3, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=1, 
#                   y=2)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=3 NormCounts")
# 
# ###PC2/3
# ggplot2::autoplot(prcomp_res_3, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=2, 
#                   y=3)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=3 NormCounts")
# 
# #now convert this to log2cpm using the normalized counts from set3
# 
# RUV_df_rm3_cpm <- cpm(set3$normalizedCounts, log = TRUE)
# 
# prcomp_res_3_cpm <- prcomp(t(RUV_df_rm3_cpm), scale. = FALSE, center = TRUE)
# annot_prcomp_res_3_cpm <- prcomp_res_3_cpm$x %>% cbind(., annot)
# 
# ##PC1/2
# ggplot2::autoplot(prcomp_res_3_cpm, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=1, 
#                   y=2)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=3 log2cpm")
# 
# ###PC2/3
# ggplot2::autoplot(prcomp_res_3_cpm, 
#                   data = annot, 
#                   colour = "Condition", 
#                   shape = "Time", 
#                   size =4, 
#                   x=2, 
#                   y=3)+
#   theme_bw()+
#   scale_color_manual(values=cond_col)+
#   ggrepel::geom_text_repel(label= ind_num, 
#                            vjust = -0.5, 
#                            max.overlaps = 30)+
#   ggtitle("RUVs Correction k=3 log2cpm")

```

#Plot Spearman Heatmaps for RUVs Normalized Counts Data
```{r RUVs HM Spearman, fig.height=10, fig.width=12}
#Now that I've put together the PCA plots for both normalized counts and log2cpm
#I want to make these into heatmaps

#first change your Metadata to have the new names for my supp figures
# Metadata <- Metadata %>% 
#    mutate(
#     # Map time labels to standard timepoints
#     Timepoint = case_when(
#       Time == "24T" ~ "t0",
#       Time == "24R" ~ "t24",
#       Time == "144R" ~ "t144",
#       TRUE ~ NA_character_
#     ),
#     
#     # Map drug labels to treatment shorthand
#     Treatment = case_when(
#       Drug == "DOX" ~ "DOX",
#       Drug == "DMSO" ~ "VEH",
#       TRUE ~ NA_character_
#     ),
#     
#     # Combine them into a unified condition string
#     Condition = paste(Treatment, Timepoint, Ind, sep = "_")
#   ) %>%
#   mutate(
#     # Factorize Ind, Timepoint, Treatment, and Condition for plotting consistency
#     Ind = factor(Ind, 
#                  levels = c("1", "2", "3", "4", "5", "6", "6R"), 
#                  ordered = TRUE),
#     Timepoint = factor(Timepoint, levels = c("t0", "t24", "t144"),
#                        ordered = TRUE),
#     Treatment = factor(Treatment, levels = c("DOX", "VEH"),
#                        ordered = TRUE),
#     Condition = factor(
#       Condition,
#       levels = expand.grid(
#         Treatment = levels(Treatment),
#         Timepoint = levels(Timepoint),
#         Ind = levels(Ind)
#       ) %>%
#         transmute(Condition = paste(Treatment, Timepoint, Ind, sep = "_")) %>%
#         pull(Condition),
#       ordered = TRUE
#     )
#   )
#also change Ind 1 to Ind4 to keep all F and all M together
line_to_ind <- c(
  "87-1"  = "Ind1",   #originally Ind2
  "78-1"  = "Ind2",   #originally Ind3
  "75-1"  = "Ind3",   #originally Ind4
  "84-1"  = "Ind4",   #renamed from Ind1 to Ind4
  "17-3"  = "Ind5",   #unchanged
  "90-1"  = "Ind6",   #unchanged
  "90-1REP" = "Ind6R"   #unchanged
)

# Update Ind column in Metadata
# Metadata$Old_Ind <- Metadata$Ind

# Metadata$Ind <- line_to_ind[Metadata$Line]
# Metadata$Ind <- gsub("Ind", "", Metadata$Ind)

#update sample names columns in csv

# saveRDS(Metadata, "data/Metadata_update.RDS")
# write.csv(Metadata, "data/Metadata_update.csv")
# Metadata <- read.csv("data/Metadata_update.csv")

####RUVs k=1-3
#check to make sure that the column names are correct
dim(RUV_filt_counts)
dim(set1$normalizedCounts)
# dim(set2$normalizedCounts)
# dim(set3$normalizedCounts)

#take the normalized counts from k=1 and put together a dataframe with the correct columns
normcounts_k0 <- RUV_filt_counts
normcounts_k1 <- set1$normalizedCounts %>% as.data.frame()
# #do the same with k=2 and k=3
# normcounts_k2 <- set2$normalizedCounts %>% as.data.frame()
# normcounts_k3 <- set3$normalizedCounts %>% as.data.frame()

#do the same with the log2cpm conversion
cpm_k0 <- cpm(normcounts_k0, log = TRUE) %>% as.data.frame()
cpm_k1 <- cpm(set1$normalizedCounts, log = TRUE) %>% as.data.frame()
# cpm_k2 <- cpm(set2$normalizedCounts, log = TRUE) %>% as.data.frame()
# cpm_k3 <- cpm(set3$normalizedCounts, log = TRUE) %>% as.data.frame()

#compute the correlation matrices for RUVs 1-3 with normalized counts
#k=0
cor_matrix_spmn_k0 <- cor(normcounts_k0,
                          y = NULL,
                          use = "everything", 
                          method = "spearman")
#k=1
cor_matrix_spmn_k1 <- cor(normcounts_k1,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

# #k=2
# cor_matrix_spmn_k2 <- cor(normcounts_k2,
#                           y = NULL,
#                           use = "everything",
#                           method = "spearman")
# 
# #k=3
# cor_matrix_spmn_k3 <- cor(normcounts_k3,
#                           y = NULL,
#                           use = "everything",
#                           method = "spearman")

#Do the same with the log2cpm converted versions
#k=0
cor_matrix_spmn_k0_cpm <- cor(cpm_k0,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#k=1
cor_matrix_spmn_k1_cpm <- cor(cpm_k1,
                           y = NULL,
                           use = "everything",
                           method = "spearman")


# #k=2
# cor_matrix_spmn_k2_cpm <- cor(cpm_k2,
#                           y = NULL,
#                           use = "everything",
#                           method = "spearman")
# 
# #k=3
# cor_matrix_spmn_k3_cpm <- cor(cpm_k3,
#                           y = NULL,
#                           use = "everything",
#                           method = "spearman")

#extract metadata columns
Individual <- as.character(Metadata$Ind)
Time <- as.character(Metadata$Time)
Treatment <- as.character(Metadata$Treatment)

# Define color palettes for annotations
annot_col_cor = list(Treatment = c("DOX" = "#499FBD", 
                               "VEH" = "#BBBBBC"),
                     Individual = c("1" = "#FFA364", 
                                     "2" = "#78EFDE", 
                                     "3" = "#A4D177", 
                                     "4" = "#EAD050", 
                                     "5" = "#A68AC0", 
                                     "6" = "#F16F90", 
                                     "6R" = "#C61E4E"),
                     Timepoint = c("t0" = "#238B45",
                                    "t24" = "#74C476", 
                                    "t144" = "#C7E9C0"))

tx_colors <- c("DOX" = "#499FBD",
                 "VEH" = "#BBBBBC")
ind_colors <- c("1" = "#FFA364",
                "2" = "#78EFDE",
                "3" = "#A4D177",
                "4" = "#EAD050",
                "5" = "#A68AC0",
                "6" = "#F16F90",
                "6R" = "#C61E4E")
time_colors <- c("t0" = "#238B45",
                 "t24" = "#74C476",
                 "t144" = "#C7E9C0")

# Create annotations
top_annotation <- HeatmapAnnotation(
  Individual = Individual, 
  Time = Time,
  Treatment = Treatment,
  col = list(
    Individual = ind_colors, 
    Time = time_colors,
    Treatment = tx_colors
  )
)

####ANNOTATED HEATMAPS####
###Spearman Heatmap k=0 ####
heatmap_spmn_k0 <- Heatmap(cor_matrix_spmn_k0,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Filtered Counts no RUVs")

# Draw the heatmap k=0
draw(heatmap_spmn_k0)

####Spearman Heatmap k=1 ####
heatmap_spmn_k1 <- Heatmap(cor_matrix_spmn_k1,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Normalized Counts k=1")

# Draw the heatmap k=1
draw(heatmap_spmn_k1)

# ####Spearman Heatmap k=2####
# heatmap_spmn_k2 <- Heatmap(cor_matrix_spmn_k2,
#                            name = "Spearman",
#                            top_annotation = top_annotation,
#                            show_row_names = TRUE,
#                            show_column_names = TRUE,
#                            cluster_rows = TRUE,
#                            cluster_columns = TRUE,
#                            border = TRUE, 
#                            column_title = "Normalized Counts k=2")
# 
# # Draw the heatmap k=2
# draw(heatmap_spmn_k2)
# 
# ####Spearman Heatmap k=3####
# heatmap_spmn_k3 <- Heatmap(cor_matrix_spmn_k3,
#                            name = "Spearman",
#                            top_annotation = top_annotation,
#                            show_row_names = TRUE,
#                            show_column_names = TRUE,
#                            cluster_rows = TRUE,
#                            cluster_columns = TRUE,
#                            border = TRUE, 
#                            column_title = "Normalized Counts k=3")
# 
# # Draw the heatmap k=3
# draw(heatmap_spmn_k3)


####Spearman Heatmap k=0 log2cpm####
heatmap_spmn_k0_cpm <- Heatmap(cor_matrix_spmn_k0_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Filtered Counts no RUVs")

# Draw the heatmap k=0 log2cpm
draw(heatmap_spmn_k0_cpm)

####Spearman Heatmap k=1 log2cpm####
heatmap_spmn_k1_cpm <- Heatmap(cor_matrix_spmn_k1_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Normalized Counts k=1")

# Draw the heatmap k=1 log2cpm
draw(heatmap_spmn_k1_cpm)

# ####Spearman Heatmap k=2 log2cpm####
# heatmap_spmn_k2_cpm <- Heatmap(cor_matrix_spmn_k2_cpm,
#                            name = "Spearman",
#                            top_annotation = top_annotation,
#                            show_row_names = TRUE,
#                            show_column_names = TRUE,
#                            cluster_rows = TRUE,
#                            cluster_columns = TRUE,
#                            border = TRUE, 
#                            column_title = "log2cpm of Normalized Counts k=2")
# 
# # Draw the heatmap k=2 log2cpm
# draw(heatmap_spmn_k2_cpm)
# 
# ####Spearman Heatmap k=3 log2cpm####
# heatmap_spmn_k3_cpm <- Heatmap(cor_matrix_spmn_k3_cpm,
#                            name = "Spearman",
#                            top_annotation = top_annotation,
#                            show_row_names = TRUE,
#                            show_column_names = TRUE,
#                            cluster_rows = TRUE,
#                            cluster_columns = TRUE,
#                            border = TRUE, 
#                            column_title = "log2cpm of Normalized Counts k=3")
# 
# # Draw the heatmap k=3 log2cpm
# draw(heatmap_spmn_k3_cpm)

#now that I know I'll be using the k=1 RUVs Spearman cor, find the median for all comparisons and also do a sign test to see significance
# Remove diagonal (self-correlations) and get lower triangle only
spearman_vals <- cor_matrix_spmn_k1_cpm[lower.tri(cor_matrix_spmn_k1_cpm, diag = FALSE)]

# Median of Spearman correlation coefficients
median_spearman <- median(spearman_vals, na.rm = TRUE)

# Sign test: number of positive vs negative correlations
# H0: median = 0, HA: median > 0 (one-sided test)

# Count number of positive and negative values
n_pos <- sum(spearman_vals > 0, na.rm = TRUE)
n_neg <- sum(spearman_vals < 0, na.rm = TRUE)
n_total <- n_pos + n_neg

# Perform a binomial test (sign test)
sign_test <- binom.test(x = n_pos, n = n_total, p = 0.5, alternative = "greater")

# Output results
cat("Median Spearman correlation:", median_spearman, "\n")
cat("Sign test p-value (greater than 0):", sign_test$p.value, "\n")

#Median Spearman correlation: 0.9547968 
#Sign test p-value (greater than 0): 6.503898e-260 

#now I want to test correlations by timepoint with DOX vs DMSO
#list your timepoints
cor_time_sp <- c("t0", "t24", "t144")

for (tp in cor_time_sp) {
  
  # Match DOX and DMSO samples at this timepoint
  dox_samples <- grep(paste0("^DOX_", tp), colnames(cor_matrix_spmn_k1_cpm), value = TRUE)
  dmso_samples <- grep(paste0("^VEH_", tp), colnames(cor_matrix_spmn_k1_cpm), value = TRUE)
  
  # Extract Spearman correlations between DOX and DMSO at this timepoint
  cor_vals <- as.vector(cor_matrix_spmn_k1_cpm[dox_samples, dmso_samples])
  
  # Calculate median
  median_cor <- median(cor_vals, na.rm = TRUE)
  
  # Sign test (are most correlations > 0?)
  n_pos <- sum(cor_vals > 0, na.rm = TRUE)
  n_neg <- sum(cor_vals < 0, na.rm = TRUE)
  n_total <- n_pos + n_neg
  
  # Perform binomial test if valid
  if (n_total > 0) {
    sign_test <- binom.test(x = n_pos, n = n_total, p = 0.5,
                            alternative = "greater")
    p_val <- sign_test$p.value
  } else {
    p_val <- NA
  }
  
  # Output
  cat("====", tp, "====\n")
  cat("Median Spearman correlation (DOX vs VEH):", round(median_cor, 4), "\n")
  cat("Sign test p-value:", p_val, "\n\n")
}

# output
# ==== t0 ====
# Median Spearman correlation (DOX vs VEH): 0.8899 
# Sign test p-value: 1.776357e-15 
# 
# ==== t24 ====
# Median Spearman correlation (DOX vs VEH): 0.9347 
# Sign test p-value: 1.776357e-15 
# 
# ==== t144 ====
# Median Spearman correlation (DOX vs VEH): 0.9767 
# Sign test p-value: 1.776357e-15 

#this means that my DOX and VEH are highly similar and significant according to P values

```

```{r Spearman Correlation Heatmap RUVs k1 Supp}
#Make your supplement heatmap 

#rename your columns for your matrix cpm_k1 to be correct
# I RENAMED THESE EARLIER 
# new_colname <- colnames(cpm_k1) %>%
#   gsub("24T", "t0", .) %>%
#   gsub("24R", "t24", .) %>%
#   gsub("144R", "t144", .) %>%
#   gsub("DMSO", "VEH", .)

# cpm_k1_rename <- cpm_k1

# colnames(cpm_k1_rename) <- new_colname

cpm_k1 <- cpm_k1_rename

cor_matrix_spmn_k1_cpm_new <- cor(cpm_k1,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#create ComplexHeatmap
heatmap_spmn_supp <- Heatmap(
  cor_matrix_spmn_k1_cpm,
  name = "Spearman",
  top_annotation = top_annotation,
  show_row_names = TRUE,
  show_column_names = TRUE,
  cluster_rows = TRUE,
  cluster_columns = TRUE, 
  show_row_dend = FALSE,
  show_column_dend = FALSE,
  row_names_gp = gpar(fontsize = 7),
  column_names_gp = gpar(fontsize = 7),
  column_names_centered = TRUE,
  row_names_centered = TRUE,
  rect_gp = gpar(col = "black", lwd = 0.5), 
  border = gpar(col = "black", lwd = 1),
  column_title = "log2cpm of normalized counts RUVs corrected",
  column_title_gp = gpar(fontsize = 10, fontface = "plain"),
  heatmap_legend_param = list(
    title_gp = gpar(fontsize = 8, fontface = "plain"),
    labels_gp = gpar(fontsize = 7)
  )
)

#make a function to save complex heatmaps
save_complex_heatmap <- function(plot, filename, folder, width = 6, height = 8) {
  if (!dir.exists(folder)) dir.create(folder, recursive = TRUE)
    path <- file.path(folder, filename)
    pdf(path, width = width, height = height)
    draw(plot, heatmap_legend_side = "right")
    dev.off()
  message("Saved heatmap to: ", path)
}

# Save to PDF in your output folder
# save_complex_heatmap(
#   plot = heatmap_spmn_supp,
#   filename = "SuppFig3_SpearmanCorHM_RUV_log2cpm_EMP_251121.pdf",
#   folder = output_folder,
#   width = 8,
#   height = 6
# )
```




#Perform Differential Expression Analysis with k = 1 RUVs Correction
```{r DE RUVs k1}
#same DGEList object as before
dge <- readRDS("data/new/dge_matrix.RDS")

#check normalization factors from TMM normalization of LIBRARIES
dge$samples

#read in my covariate information RUV_1 dataframe + remove 6R
RUV_df_rm1 <- readRDS("data/new/RUV_df_rm1.RDS")

#filter out 6R for DE analysis
RUV_1_df_filt <- RUV_df_rm1[!grepl("6R$", rownames(RUV_df_rm1)), , drop = FALSE]

Metadata_2$W_1 <- RUV_1_df_filt$W_1

#now ensure that RUV_1 has the right number of cols after removing rep
length(RUV_1_df_filt$W_1)
#36 

#now make this into a list
RUV_1_DE <-  RUV_1_df_filt$W_1

# saveRDS(RUV_1_DE, "data/new/RUV_1_DE.RDS")

#create my design matrix for DE + RUVs covariate k=1
design1 <- model.matrix(~0 + RUV_1_DE + Metadata_2$Condition)
colnames(design1) <- gsub("Metadata_2\\$Condition", "", colnames(design1))

#take care that the matrix automatically sorts cols alphabetically

#run duplicate correlation for individual effect
corfit1 <- duplicateCorrelation(object = dge$counts, design = design1, block = Metadata_2$Ind)

#voom transformation and plot
v1 <- voom(dge, design1, block = Metadata_2$Ind, correlation = corfit1$consensus.correlation, plot = TRUE)

#fit my linear model
fit1 <- lmFit(v1, design1, block = Metadata_2$Ind, correlation = corfit1$consensus.correlation)

#make my contrast matrix to compare across tx and veh
contrast_matrix_RUV <- makeContrasts(
  V.D24T = DOX_t0 - VEH_t0,
  V.D24R = DOX_t24 - VEH_t24, 
  V.D144R = DOX_t144 - VEH_t144,
  RUV_1_24T = RUV_1_DE - VEH_t0,
  RUV_1_24R = RUV_1_DE - VEH_t24,
  RUV_1_144R = RUV_1_DE - VEH_t144,  
  levels = design1
)

#apply these contrasts to compare DOX to DMSO VEH
fit_RUV <- contrasts.fit(fit1, contrast_matrix_RUV)
fit_RUV <- eBayes(fit_RUV)

#plot the mean-variance trend
plotSA(fit_RUV, main = "Mean-Variance Trend, RUVs k=1")

#look at the summary of your results
##this tells you the number of DEGs in each condition
results_summary1 <- decideTests(fit_RUV, adjust.method = "BH", p.value = 0.05)

summary(results_summary1)
#        V.D24T V.D24R V.D144R
# Down     4866   3727     466  
# NotSig   4899   7107   13659    
# Up       4554   3485     194

#compare this to my previous DEGs I found
# summary(results_summary)
#        V.D24T V.D24R V.D144R
# Down     4723   3593     359
# NotSig   5076   7151   13810
# Up       4520   3575     150


#overall, there are more DEGs found after RUVs k=1 correction 
#this was an expected result as it increases tx effect w/ correction

```
##Generate Toptables RUVs
```{r TopTables DE RUV}
# Generate Top Table for Specific Comparisons

Toptable_V.D24T_k1 <- topTable(fit = fit_RUV, coef = "V.D24T", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
# write.csv(Toptable_V.D24T_k1, "data/new/DEGs/Toptable_V.D24T_k1.csv")

Toptable_V.D24R_k1 <- topTable(fit = fit_RUV, coef = "V.D24R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
# write.csv(Toptable_V.D24R_k1, "data/new/DEGs/Toptable_V.D24R_k1.csv")

Toptable_V.D144R_k1 <- topTable(fit = fit_RUV, coef = "V.D144R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
write.csv(Toptable_V.D144R_k1, "data/new/DEGs/Toptable_V.D144R_k1.csv")

# save all of these toptables as R objects
# saveRDS(list(
#   V.D24T_k1 = Toptable_V.D24T_k1,
#   V.D24R_k1 = Toptable_V.D24R_k1,
#   V.D144R_k1 = Toptable_V.D144R_k1
# ), file = "data/new/Toptable_list_RUVk1.RDS")

Toptable_list_RUVk1 <- readRDS("data/new/Toptable_list_RUVk1.RDS")

#################################################################
#this section is commented out since it only needs to run once
#kept the code for posterity

# #I want to add the hgnc symbols to my toptables as well
# ####D24T####
# #load in data
sample_toptab_24T <- read_csv("data/new/DEGs/Toptable_V.D24T_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
print(colnames(sample_toptab_24T))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
colnames(sample_toptab_24T)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
sample_toptab_24T <- sample_toptab_24T %>%
  mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
gene_symbols1 <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = sample_toptab_24T$Entrez_ID,
  columns = c("SYMBOL"),
  keytype = "ENTREZID"
)
# # ----------------- Join Back to Main Data -----------------
Toptable_RUV_24T <- left_join(sample_toptab_24T, gene_symbols1, by = c("Entrez_ID" = "ENTREZID"))
Toptable_RUV_24T %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# write_csv(Toptable_RUV_24T, "data/new/DEGs/Toptable_RUV_24T.csv")
# 
# #now do this again for my other two toptables
# 
# ####24R####
# #load in data
# sample_toptab_24R <- read_csv("data/new/DEGs/Toptable_V.D24R_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_24R))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_24R)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_24R <- sample_toptab_24R %>%
  # mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols2 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_24R$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_24R <- left_join(sample_toptab_24R, gene_symbols2, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_24R %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #I'll make these symbols into rownames later for my volcano plots
# write_csv(Toptable_RUV_24R, "data/new/DEGs/Toptable_RUV_24R.csv")
# 
# 
# ####D144R####
# #load in data
# sample_toptab_144R <- read_csv("data/new/DEGs/Toptable_V.D144R_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_144R))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_144R)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_144R <- sample_toptab_144R %>%
  # mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols3 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_144R$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_144R <- left_join(sample_toptab_144R, gene_symbols3, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_144R %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #I'll make these symbols into rownames later for my volcano plots
# write_csv(Toptable_RUV_144R, "data/new/DEGs/Toptable_RUV_144R.csv")
# 
# write.csv(Toptable_RUV_24T, "data/new/DEGs/Toptable_RUV_24T_final.csv")
# write.csv(Toptable_RUV_24R, "data/new/DEGs/Toptable_RUV_24R_final.csv")
# write.csv(Toptable_RUV_144R, "data/new/DEGs/Toptable_RUV_144R_final.csv")

Toptable_RUV_24T <- read_csv("data/new/DEGs/Toptable_RUV_24T_final.csv",
                             col_select = -1)
Toptable_RUV_24R <- read_csv("data/new/DEGs/Toptable_RUV_24R_final.csv",
                             col_select = -1)
Toptable_RUV_144R <- read_csv("data/new/DEGs/Toptable_RUV_144R_final.csv",
                              col_select = -1)

# save all of these toptables as R objects
# saveRDS(list(
#   V.D24T_RUV = Toptable_RUV_24T,
#   V.D24R_RUV = Toptable_RUV_24R,
#   V.D144R_RUV = Toptable_RUV_144R
# ), file = "data/new/Toptable_list_RUVk1_Symbols.RDS")

Toptable_list_RUVk1_symbols <- readRDS("data/new/Toptable_list_RUVk1_Symbols.RDS")

```

##Volcano Plots of Original DEGs
```{r Volcano Plots of DEGs Original}
#make a function to generate volcano plots + add gene numbers
generate_volcano_plot <- function(toptable, title) {
  
  #make significance labels
  toptable$Significance <- "Not Significant"
  toptable$Significance[toptable$logFC > 0 & toptable$adj.P.Val < 0.05] <- "Upregulated"
  toptable$Significance[toptable$logFC < 0 & toptable$adj.P.Val < 0.05] <- "Downregulated"
  
  #add number of genes for each significance label
  upgenes <- toptable %>% filter(Significance == "Upregulated") %>% nrow()
  nsgenes <- toptable %>% filter(Significance == "Not Significant") %>% nrow()
  downgenes <- toptable %>% filter(Significance == "Downregulated") %>% nrow()

  #make legend labels for no of genes
  legend_lab <- c(
    str_c("Upregulated: ", upgenes),
    str_c("Not Significant: ", nsgenes),
    str_c("Downregulated: ", downgenes)
  )
  
  #specify the colors for the legend
  legend_col <- c(
    str_c("Upregulated: " = "blue"),
    str_c("Not Significant: " = "gray"),
    str_c("Downregulated: " = "red")
  )

  #generate volcano plot w/ legend
  ggplot(toptable, aes(x = logFC, 
                       y = -log10(P.Value), 
                       color = Significance)) +
    geom_point(alpha = 0.4, size = 2) + 
    scale_color_manual(values = c("Upregulated" = "blue",
                                  "Not Significant" = "gray",
                                  "Downregulated" = "red"), 
                       labels = legend_lab) +
    xlim(-10, 10) +
    labs(title = title, 
         x = expression(x = "log"[2]*"FC"), 
         y = expression(y = "-log"[10]*"P-value")) +
    theme_bw()+
    guides(color = guide_legend(override.aes = list(color = legend_col)))+
    theme(legend.position = "right", 
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25)))
}

#generate volcano plots across each comparison
volcano_plots <- list(
  "V.D24T" = generate_volcano_plot(Toptable_V.D24T, "Volcano Plot DOX 24hr (adj P-val<0.05)"),
  "V.D24R" = generate_volcano_plot(Toptable_V.D24R, "Volcano Plot DOX 24hr Recovery (adj P-val<0.05)"),
  "V.D144R" = generate_volcano_plot(Toptable_V.D144R, "Volcano Plot DOX 144hr Recovery (adj P-val<0.05)")
)

# Display each volcano plot
for (plot_name in names(volcano_plots)) {
  print(volcano_plots[[plot_name]])
}


```
##Top 5 DEGs after RUVs k=1 Correction
```{r RUV Top5 DEGs}
#use your three toptables so I can pull out top 5 genes from each based on adj. p val

top5_D24T_1 <- Toptable_RUV_24T[order(Toptable_RUV_24T$adj.P.Val), ][1:5,] 
top5_D24R_1 <- Toptable_RUV_24R[order(Toptable_RUV_24R$adj.P.Val), ][1:5,] 
top5_D144R_1 <- Toptable_RUV_144R[order(Toptable_RUV_144R$adj.P.Val), ][1:5,]

#now that I've pulled the top 5 DEGs from each, make a list to pull them from my log2cpm data

boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()

#Define gene list
#these are the top 5 genes pulled from my toptables
top5_D24T_geneslist_1 <- c(top5_D24T_1$Entrez_ID)
top5_D24R_geneslist_1 <- c(top5_D24R_1$Entrez_ID)
top5_D144R_geneslist_1 <- c(top5_D144R_1$Entrez_ID)
#Add more gene symbols as needed or add more categories

#now pull these from my log2cpm matrix
top5_D24T_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D24T_geneslist_1,]
dim(top5_D24T_genes_1)
#5 genes in 44 cols
top5_D24R_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D24R_geneslist_1,]
dim(top5_D24R_genes_1)
#5 genes in 44 cols
top5_D144R_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D144R_geneslist_1,]
dim(top5_D144R_genes_1)
#5 genes in 44 cols

#Now put in the function I want to use to generate boxplots of genes
#####D24T#####
process_top5_D24T_1 <- function(gene) {
  gene_data <- top5_D24T_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24T_geneslist_1) {
  gene_data <- process_top5_D24T_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D24T RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D24R#####
process_top5_D24R_1 <- function(gene) {
  gene_data <- top5_D24R_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24R_geneslist_1) {
  gene_data <- process_top5_D24R_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D24R RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D144R#####
process_top5_D144R_1 <- function(gene) {
  gene_data <- top5_D144R_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D144R_geneslist_1) {
  gene_data <- process_top5_D144R_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D144R RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```
```{r Top DEGs all timepoints list}
#find the top 10 DEGs for the entire dataset with my combined toptables
#Combine the toptables I have from pairwise analysis into a single dataframe
# d0_toptable_dxr_RUV <- Toptable_RUV_24T %>% 
#   mutate(Time = "t0")
# 
# d24_toptable_dxr_RUV <- Toptable_RUV_24R %>% 
#   mutate(Time = "t24")
# 
# d144_toptable_dxr_RUV <- Toptable_RUV_144R %>% 
#   mutate(Time = "t144")

# combined_toptables_dxr_RUV <- bind_rows(
#   d0_toptable_dxr_RUV,
#   d24_toptable_dxr_RUV,
#   d144_toptable_dxr_RUV)

# combined_toptables_dxr_RUV

# saveRDS(combined_toptables_dxr_RUV, "data/new/RUV/combined_toptables_RUVs.RDS")

combined_toptables_dxr_RUV <- readRDS("data/new/RUV/combined_toptables_RUVs.RDS")

top10_DEGs_RUV <- combined_toptables_dxr_RUV[order(combined_toptables_dxr_RUV$adj.P.Val), ][1:10,]

print(top10_DEGs_RUV$SYMBOL)
print(top10_DEGs_RUV$Entrez_ID)

```


##LogFC DEGs RUVs k=1 All Conditions
```{r RUV logFC DEGs all Conditions}
# Toptable_RUV_24T
# Toptable_RUV_24R
# Toptable_RUV_144R

# Load DEGs Data

#make a list of all of the genes in this set so I can plot the logFC in other sets
D24T_DEGs_1 <- DOX_24T_1$Entrez_ID[DOX_24T_1$adj.P.Val < 0.05]
length(D24T_DEGs_1)
#9243 genes

D24R_DEGs_1 <- DOX_24R_1$Entrez_ID[DOX_24R_1$adj.P.Val < 0.05]
length(D24R_DEGs_1)
#7168 genes

D144R_DEGs_1 <- DOX_144R_1$Entrez_ID[DOX_144R_1$adj.P.Val < 0.05]
length(D144R_DEGs_1)
#509 genes

#plot those full gene sets in logFC
D24T_DEGs_1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs_1)

D24R_DEGs_1 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
length(D24R_DEGs_1)

D144R_DEGs_1 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]
length(D144R_DEGs_1)
#now that I have the full list of genes, I want to plot the logFC across conditions


#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr_1 <- Toptable_RUV_24T %>% 
  mutate(Time = "24")

d24r_toptable_dxr_1 <- Toptable_RUV_24R %>% 
  mutate(Time = "24R")

d144r_toptable_dxr_1 <- Toptable_RUV_144R %>% 
  mutate(Time = "144R")

combined_toptables_dxr_RUV <- bind_rows(
  d24_toptable_dxr_1,
  d24r_toptable_dxr_1,
  d144r_toptable_dxr_1)

#Filter the data based on each motif
filt_toptable_dxr_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D24T_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D24T DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now do the same with the other conditions

filt_toptable_dxr_24r_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D24R_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D24R DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#D144R

filt_toptable_dxr_144r_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D144R_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D144R DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now put the names of these graphs to print them
filt_toptable_dxr_RUV
filt_toptable_dxr_24r_RUV
filt_toptable_dxr_144r_RUV


```

##LogFC Heatmap Across Timepoints RUVs
```{r LogFC HM RUVs Timepoint Comparisons}
#format my data so that I have a matrix of my logFC values and genes

logFC_wide_RUV <- combined_toptables_dxr_RUV %>%
  mutate(absFC = abs(logFC)) %>% 
  dplyr::select(Entrez_ID, Time, logFC) %>%
  pivot_wider(names_from = Time, values_from = logFC) %>%
  drop_na() %>% 
  column_to_rownames("Entrez_ID") 

logFCabs_wide_RUV <- combined_toptables_dxr_RUV %>% 
  mutate(absFC = abs(logFC)) %>% 
  dplyr::select(Entrez_ID, Time, absFC) %>% 
  pivot_wider(names_from = Time, values_from = absFC) %>% 
  drop_na() %>% 
  column_to_rownames("Entrez_ID")

#now that I've pivoted my logFC data into a wide format I can compute the Spearman correlation between the timepoints

#convert to matrix + remove gene column
logFC_matrix_RUV <- as.matrix(logFC_wide_RUV)

logFCabs_matrix_RUV <- as.matrix(logFCabs_wide_RUV)

# Compute Spearman correlation between columns (timepoints)
logFC_cor_RUV <- cor(logFC_matrix_RUV, 
                     y = NULL,
                     use = "everything",
                     method = "spearman")

logFCabs_cor_RUV <- cor(logFCabs_matrix_RUV, 
                     y = NULL,
                     use = "everything",
                     method = "spearman")

# Define color palettes for annotations
annot_col_cor = list(timepoints = c("24T" = "#238B45",
                                    "24R" = "#74C476",
                                    "144R" = "#C7E9C0"))

time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

timepoints <- c("24T", "24R", "144R")

# Create annotations
top_annotation_RUV_time <- HeatmapAnnotation(
  Timepoint = timepoints,
  col = list(Timepoint = time_colors),
  annotation_name_side = "left"
)


# Draw heatmap logFC
Heatmap(logFC_cor_RUV,
        name = "Spearman",
        col = colorRamp2(c(0, 0.5, 1), c("blue", "white", "red")),
        top_annotation = top_annotation_RUV_time,
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(sprintf("%.2f", logFC_cor_RUV[i, j]), x, y, 
                    gp = gpar(fontsize = 10))
        },
        column_title = "Spearman Correlation of logFC")

#draw heatmap abs logFC
Heatmap(logFCabs_cor_RUV,
        name = "Spearman",
        col = colorRamp2(c(0, 0.5, 1), c("blue", "white", "red")),
        top_annotation = top_annotation_RUV_time,
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(sprintf("%.2f", logFC_cor_RUV[i, j]), x, y, 
                    gp = gpar(fontsize = 10))
        },
        column_title = "Spearman Correlation of |logFC|")


####Spearman Heatmap####
heatmap_spearman_RUV_time <- Heatmap(logFC_cor_RUV,
                           name = "Spearman",
                           top_annotation = top_annotation_RUV_time,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = FALSE,
                           border = TRUE)

heatmap_spearman_RUV_time_abs <- Heatmap(logFCabs_cor_RUV,
                           name = "Spearman",
                           top_annotation = top_annotation_RUV_time,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = FALSE,
                           border = TRUE)


# Draw the heatmap
draw(heatmap_spearman_RUV_time)
draw(heatmap_spearman_RUV_time_abs)


```

#Scatterplot Spearman Cor Heatmap Fig2
```{r logFC scatterplot}

# Define the timepoints from your data
timepoints <- c("t0", "t24", "t144")

comparison_order <- c("t0 vs t24", "t24 vs t144", "t0 vs t144")

# Make all pairwise combinations
pairs_df <- t(combn(timepoints, 2)) %>%
  as.data.frame(stringsAsFactors = FALSE) %>%
  setNames(c("time_x", "time_y"))


# Function to prepare scatter data for each pair
prepare_pair_data <- function(time_x, time_y, df) {
  rho <- cor(df[[time_x]], df[[time_y]], method = "spearman")
  df %>%
    mutate(
      x_val = .data[[time_x]],
      y_val = .data[[time_y]],
      comparison = paste0(time_x, " vs ", time_y),
      rho_label = paste0("rho = ", round(rho, 2)),
      x_lab = paste0("log2FC", time_x),
      y_lab = paste0("log2FC", time_y)
    )
}

comparison_colors <- c(
  "t0 vs t24"  = "#4167BD",
  "t24 vs t144" = "#72AEE0",
  "t0 vs t144" = "#5780C5"
)

# Build combined plotting dataset
scatter_df <- map2_df(pairs_df$time_x, pairs_df$time_y,
                      ~prepare_pair_data(.x, .y, logFC_wide_RUV)) %>%
  mutate(comparison = factor(comparison, levels = comparison_order))

facet_labels <- scatter_df %>%
  distinct(comparison, x_lab, y_lab) %>%
  mutate(label = paste0(comparison, "\n", x_lab, " | ", y_lab)) %>%
  select(comparison, label) %>%
  deframe()

#split data by comparison
split_data <- split(scatter_df, scatter_df$comparison)

make_scatter <- function(df_sub) {
  comp <- df_sub$comparison[1] 
  ggplot(df_sub, aes(x = x_val, y = y_val)) +
    geom_point_rast(alpha = 0.5, raster.dpi = 300, color = comparison_colors[comp]) +
    geom_smooth(method = "lm", se = FALSE, linetype = "dashed", color = "black") +
    geom_text(
      data = df_sub %>% distinct(comparison, rho_label),
      aes(x = -Inf, y = Inf, label = rho_label),
    inherit.aes = FALSE,
    hjust = -0.1, vjust = 1.5,
    size = 4
  ) +
    coord_fixed(xlim = c(-9,9), ylim = c(-9,9), ratio = 1) +
    labs(
      x = unique(df_sub$x_lab),
      y = unique(df_sub$y_lab)
    ) +
    theme_custom() +
    theme(
      axis.line = element_line(linewidth = 1, 
                               color = "black"),
      axis.ticks.length = unit(0.05, "in"),
      axis.text = element_text(color = "black"),
      panel.background = element_blank(),
      panel.border = element_blank(),
      legend.position = "none"
    )
}

#my custom theme for these figures
# theme_plots <- function(base_size = 14) {
#   theme_bw(base_size = base_size) %+replace%
#     theme(
#       axis.line = element_line(linewidth = 1, color = "black"),
#       axis.ticks.length = unit(0.05, "in"),
#       axis.text = element_text(color = "black"),
#       panel.background = element_blank(),
#       panel.border = element_blank()
#     )
# }
#   

#make plot
plot_list <- lapply(split_data, make_scatter)
#wrap all three together to get the final plot
scatterplot_fig2d_wide <- wrap_plots(plot_list, ncol  = length(plot_list))
scatterplot_fig2d_tall <- wrap_plots(plot_list, nrow = length(plot_list))
scatterplot_fig2d_wide
scatterplot_fig2d_tall

#save plot to a pdf and to a png
ggsave("Fig2D_Scatterplot_fixedlims_EMP_251121.pdf", scatterplot_fig2d_wide, width = 8, height = 6, device = cairo_pdf, path = "C:/Users/emmap/OneDrive/Desktop/DXR Manuscript Materials/Fig pdfs")
ggsave("Fig2D_Scatterplot_fixedlims_EMP_251121.png", scatterplot_fig2d_wide, width = 12, height = 4, dpi = 300, type = "cairo", path = "C:/Users/emmap/OneDrive/Desktop/DXR Manuscript Materials/Fig pdfs")

#make a rasterized version (old)
# ggplot(scatter_df, aes(x = x_val, y = y_val, color = comparison)) +
#   geom_point_rast(alpha = 0.5, raster.dpi = 300) +   #rasterized points
#   geom_smooth(method = "lm", se = FALSE, linetype = "dashed", color = "black") +
#   facet_wrap(~comparison, scales = "fixed", labeller = labeller(comparison = facet_labels)) +
#   coord_cartesian(xlim = c(-9, 9), ylim = c(-9, 9)) +
#   geom_text(
#     data = scatter_df %>% distinct(comparison, rho_label),
#     aes(x = -Inf, y = Inf, label = rho_label),
#     inherit.aes = FALSE,
#     hjust = -0.1, vjust = 1.5,
#     size = 4
#   ) +
#   scale_color_manual(values = c("#05136b", "#5b8fd1", "#aed6f1")) +
#   labs(
#     x = "",
#     y = "",
#     title = "Pairwise Scatterplots of log2FC Spearman Correlation"
#   ) +
#   theme_classic(base_size = 14) +
#   theme(legend.position = "none")

```
#Updated Fig2D Scatterplots
```{r Scatterplots Timepoint Comparisons}

#define timepoints
timepoints <- c("t0", "t24", "t144")
comparison_order <- c("t0 vs t24", "t24 vs t144", "t0 vs t144")

#make all pairwise combinations
pairs_df <- t(combn(timepoints, 2)) %>%
  as.data.frame(stringsAsFactors = FALSE) %>%
  setNames(c("time_x", "time_y"))

#function: prepare scatter data plus add rho + p-value
prepare_pair_data_new <- function(time_x, time_y, df) {
  ct <- cor.test(df[[time_x]], df[[time_y]], method = "spearman")
  
  formatted_p <- if(ct$p.value < 0.001) "< 0.001" else signif(ct$p.value, 2)

  df %>%
    mutate(
      x_val = .data[[time_x]],
      y_val = .data[[time_y]],
      comparison = paste0(time_x, " vs ", time_y),
      rho_label = paste0("rho = ", round(ct$estimate, 2),
                         "\np = ", signif(ct$p.value)),
      rho = ct$estimate,
      pval = ct$p.value,
      x_lab = paste0("log2FC ", time_x),
      y_lab = paste0("log2FC ", time_y)
    )
  
  print(ct)
}

# Colors
comparison_colors <- c(
  "t0 vs t24"   = "#4A1A2A",
  "t24 vs t144" = "#B07891",
  "t0 vs t144"  = "#7B435B"
)

# Build combined plotting dataset
scatter_df <- map2_df(
  pairs_df$time_x, pairs_df$time_y,
  ~ prepare_pair_data(.x, .y, logFC_wide_RUV)
) %>%
  mutate(comparison = factor(comparison, levels = comparison_order))

# Split data by comparison
split_data <- split(scatter_df, scatter_df$comparison)

# Plot function
make_scatter <- function(df_sub) {
  comp <- df_sub$comparison[1]

  ggplot(df_sub, aes(x = x_val, y = y_val)) +
    geom_point_rast(alpha = 0.8, size = 1.25, raster.dpi = 300,
                    color = comparison_colors[comp]) +
    geom_smooth(method = "lm", se = FALSE,
                linetype = "dashed", color = "black") +
    geom_text(
      data = df_sub %>% distinct(comparison, rho_label),
      aes(x = -Inf, y = Inf, label = rho_label),
      hjust = -0.1, vjust = 1.5,
      size = 4,
      inherit.aes = FALSE
    ) +
    coord_fixed(xlim = c(-9, 9), ylim = c(-9, 9), ratio = 1) +
    labs(
      x = unique(df_sub$x_lab),
      y = unique(df_sub$y_lab)
    ) +
    theme_custom()
    # theme(
    #   axis.line = element_line(linewidth = 1, color = "black"),
    #   axis.ticks.length = unit(0.05, "in"),
    #   axis.text = element_text(color = "black"),
    #   panel.background = element_blank(),
    #   panel.border = element_blank(),
    #   legend.position = "none"
    # )

}

# Make list of plots
plot_list <- lapply(split_data, make_scatter)

#tall version
# scatterplot_tall <- wrap_plots(plot_list, nrow = length(plot_list))
# scatterplot_tall

#wide version
scatterplot_wide <- wrap_plots(plot_list, ncol = length(plot_list))
scatterplot_wide

#summary table for stats
comparison_summary <- scatter_df %>%
  distinct(comparison, rho, pval) %>%
  arrange(comparison)

comparison_summary
```


##Volcano Plots of RUVs Corrected Data k=1
```{r Volcano Plots RUVs Corrected k1}
#make a function to generate volcano plots + add gene numbers
#ensure the gene symbols are in a col so I can plot names of top 15
generate_volcano_plot_RUV <- function(toptable, title) {
  
  #make significance labels
  toptable$Significance <- "Not Significant"
  toptable$Significance[toptable$logFC > 0 & toptable$adj.P.Val < 0.05] <- "Upregulated"
  toptable$Significance[toptable$logFC < 0 & toptable$adj.P.Val < 0.05] <- "Downregulated"
  
  #add number of genes for each significance label
  upgenes <- toptable %>% filter(Significance == "Upregulated") %>% nrow()
  nsgenes <- toptable %>% filter(Significance == "Not Significant") %>% nrow()
  downgenes <- toptable %>% filter(Significance == "Downregulated") %>% nrow()

  #make legend labels for no of genes
  legend_lab <- c(
    str_c("up = ", upgenes),
    str_c("ns = ", nsgenes),
    str_c("down = ", downgenes)
  )
  
  #specify the colors for the legend
  legend_col <- c(
    str_c("up = " = "blue"),
    str_c("ns = " = "gray"),
    str_c("down = " = "red")
  )
  
  #add the top 15 genes by adj. p value
  # top_genes <- toptable %>%
  #   filter(!is.na(SYMBOL)) %>%
  #   arrange(adj.P.Val) %>%
  #   slice_head(n = 15)
  
  #generate volcano plot w/ legend
 p <- ggplot(toptable, aes(x = logFC, 
                            y = -log10(P.Value), 
                            color = Significance)) +
    geom_point_rast(alpha = 0.6, size = 2) +  #rasterize
    scale_color_manual(values = legend_col,
                       labels = legend_lab) +
    # geom_text(
    #   data = top_genes,
    #   aes(label = SYMBOL),
    #   size = 2.5,
    #   vjust = 1.2,
    #   check_overlap = TRUE,
    #   show.legend = FALSE
    # ) +
    xlim(-10, 10) +
    ylim(0, 25) +
    labs(title = title, 
         x = expression("log"[2]*"FC"), 
         y = expression("-log"[10]*"P-value")) +
    theme_custom() +
    theme(legend.position = "bottom")
  
  return(p)
}


#generate volcano plots across each comparison
volcano_plots_RUV <- list(
  "Volcano_Supp4_1_EMP" = generate_volcano_plot_RUV(Toptable_RUV_24T, "t0"),
  "Volcano_Supp4_2_EMP" = generate_volcano_plot_RUV(Toptable_RUV_24R, "t24"),
  "Volcano_Supp4_3_EMP" = generate_volcano_plot_RUV(Toptable_RUV_144R, "t144")
)

# Display each volcano plot
for (plot_name in names(volcano_plots_RUV)) {
  print(volcano_plots_RUV[[plot_name]])
}

#save all volcano plots
for (plot_name in names(volcano_plots_RUV)) {
  save_plot(
    filename = paste0(plot_name, "_EMP.pdf"),
    plot = volcano_plots_RUV[[plot_name]],
    height = 4,
    width = 4,
    folder = output_folder
  )
}



```

##Plot DNA Damage Response Genes (DDR) with Original Data
```{r DDR Genes logFC, fig.height=14, fig.width=8}
#DDR Gene Expression Heatmap  DOX Over Recovery Time (68 genes, with categories)

# Load libraries
# library(circlize)
# library(grid)
# library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

# Final Entrez IDs and categories (68 genes)
entrez_category_DDR <- tribble(
  ~ENTREZID, ~Category,
  317, "Apoptosis", 355, "Apoptosis", 581, "Apoptosis", 637, "Apoptosis",
  836, "Apoptosis", 841, "Apoptosis", 842, "Apoptosis", 27113, "Apoptosis",
  5366, "Apoptosis", 54205, "Apoptosis", 55367, "Apoptosis", 8795, "Apoptosis",
  1026, "Cell Cycle / Checkpoint", 1027, "Cell Cycle / Checkpoint", 595, "Cell Cycle / Checkpoint",
  894, "Cell Cycle / Checkpoint", 896, "Cell Cycle / Checkpoint", 898, "Cell Cycle / Checkpoint",
  9133, "Cell Cycle / Checkpoint", 9134, "Cell Cycle / Checkpoint", 891, "Cell Cycle / Checkpoint",
  983, "Cell Cycle / Checkpoint", 1017, "Cell Cycle / Checkpoint", 1019, "Cell Cycle / Checkpoint",
  1020, "Cell Cycle / Checkpoint", 1021, "Cell Cycle / Checkpoint", 993, "Cell Cycle / Checkpoint",
  995, "Cell Cycle / Checkpoint", 1869, "Cell Cycle / Checkpoint", 4609, "Cell Cycle / Checkpoint",
  5925, "Cell Cycle / Checkpoint", 9874, "Cell Cycle / Checkpoint", 11011, "Cell Cycle / Checkpoint",
  1385, "Cell Cycle / Checkpoint",
  472, "Damage Sensors / Signal Transducers", 545, "Damage Sensors / Signal Transducers",
  5591, "Damage Sensors / Signal Transducers", 5810, "Damage Sensors / Signal Transducers",
  5883, "Damage Sensors / Signal Transducers", 5884, "Damage Sensors / Signal Transducers",
  6118, "Damage Sensors / Signal Transducers", 4361, "Damage Sensors / Signal Transducers",
  10111, "Damage Sensors / Signal Transducers", 4683, "Damage Sensors / Signal Transducers",
  84126, "Damage Sensors / Signal Transducers", 3014, "Damage Sensors / Signal Transducers",
  672, "DNA Repair", 2177, "DNA Repair", 5888, "DNA Repair", 5893, "DNA Repair",
  1647, "DNA Repair", 4616, "DNA Repair", 10912, "DNA Repair", 1111, "DNA Repair",
  11200, "DNA Repair", 1643, "DNA Repair", 8243, "DNA Repair", 5981, "DNA Repair",
  7157, "p53 Regulators / Targets", 4193, "p53 Regulators / Targets", 5371, "p53 Regulators / Targets",
  27244, "p53 Regulators / Targets", 50484, "p53 Regulators / Targets",
  207, "Miscellaneous / Broad", 25, "Miscellaneous / Broad"
)

entrez_ids_DDR <- entrez_category_DDR$ENTREZID

# Extract relevant DEG values
extract_data_DDR <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DDR) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_DDR <- bind_rows(mapply(extract_data_DDR, deg_list, names(deg_list), SIMPLIFY = FALSE)) %>%
  left_join(entrez_category_DDR, by = c("Entrez_ID" = "ENTREZID"))

# Create matrices
logFC_matddr <- acast(all_data_DDR, Gene ~ Condition, value.var = "logFC")
signif_matddr <- acast(all_data_DDR, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DDR <- logFC_matddr[, desired_order, drop = FALSE]
signif_mat_DDR <- signif_matddr[, desired_order, drop = FALSE]

# Column annotation
meta_DDR <- str_split_fixed(colnames(logFC_mat_DDR), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DDR[, 1],
  Time = meta_DDR[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Row annotation
gene_order_df_DDR <- all_data_DDR %>%
  distinct(Gene, Category) %>%
  arrange(factor(Category, levels = sort(unique(entrez_category_DDR$Category))), Gene)

ordered_genes_DDR <- gene_order_df_DDR$Gene
logFC_mat_DDR <- logFC_mat_DDR[ordered_genes_DDR, ]
signif_mat_DDR <- signif_mat_DDR[ordered_genes_DDR, ]

category_levels <- sort(unique(entrez_category_DDR$Category))

category_colors_DDR <- setNames(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple"),
  category_levels
  )


ha_left_DDR <- rowAnnotation(
  Category = gene_order_df_DDR$Category,
  col = list(Category = category_colors_DDR),
  annotation_name_side = "top"
)

# Final Heatmap
Heatmap(logFC_mat_DDR,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DDR,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "DDR Gene Expression Response (n = 68)\n DOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold"),
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DDR[i, j], x, y, gp = gpar(fontsize = 9))
        }
)
```

##Plot DOX Cardiotox Genes logFC HM Original Data
```{r DIC Genes logFC HM noRUVs}
#plot a list of 29 functionally validated DIC genes
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
DIC_genes <- tribble(
  ~SYMBOL, ~Category,
  "CAT", "ROS Generation / Handling",
  "CBR1", "ROS Generation / Handling",
  "CBR3", "ROS Generation / Handling",
  "ERBB2", "ROS Generation / Handling",
  "GPX3", "ROS Generation / Handling",
  "GSTM1", "ROS Generation / Handling",
  "GSTP", "ROS Generation / Handling",
  "HAS3", "ROS Generation / Handling",
  "NOS3", "ROS Generation / Handling",
  "PLCE1", "ROS Generation / Handling",
  "RAC2", "ROS Generation / Handling",
  "SPG7", "ROS Generation / Handling",
  "PRDM2", "DNA Damage", 
  "MLH1", "DNA Damage",
  "RARG", "DNA Damage",
  "HFE", "Iron Uptake & Homeostasis",
  "SLC22A17", "DOX Uptake",
  "SLC28A1", "DOX Uptake",
  "SLC28A3", "DOX Uptake",
  "ABCB4", "DOX Efflux",
  "ABCC2", "DOX Efflux",
  "ABCC5", "DOX Efflux", 
  "ABCC9", "DOX Efflux",
  "ABCC10", "DOX Efflux",
  "CELF4", "Calcium Handling",
  "MYH7", "Calcium Handling",
  "CYP2J2", "Cardiac Electrical Activity",
  "RIN3", "Cardiac Electrical Activity",
  "ZFN521", "Cardiac Electrical Activity")

gene_df_DIC <- tibble(HGNC = DIC_genes)


gene_df_DIC <- gene_df_DIC %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = DIC_genes$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_DIC <- gene_df_DIC$Entrez_ID

# saveRDS(entrez_ids_DIC, "data/new/RUV/DIC_genes_entrezid.RDS")

# Extract relevant DEG values
extract_data_DIC <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DIC) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_DIC <- bind_rows(mapply(extract_data_DIC, 
                             deg_list, 
                             names(deg_list), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_DIC, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matdic <- acast(all_data_DIC, Gene ~ Condition, value.var = "logFC")
signif_matdic <- acast(all_data_DIC, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DIC <- logFC_matdic[, desired_order, drop = FALSE]
signif_mat_DIC <- signif_matdic[, desired_order, drop = FALSE]

# Column annotation
meta_DIC <- str_split_fixed(colnames(logFC_mat_DIC), "_", 3)
meta_DIC <- str_split_fixed(colnames(logFC_mat_DIC), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DIC[, 1],
  Time = meta_DIC[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)
#for this I can leave off the DMSO as it's already from a pairwise comparison

#make an extra object with my category order as well
category_order_DIC <- c(
  "ROS Generation / Handling",
  "DNA Damage",
  "Calcium Handling",
  "DOX Uptake",
  "Iron Uptake & Homeostasis",
  "DOX Efflux",
  "Cardiac Electrical Activity"
)

# Row annotation
gene_order_df_DIC <- all_data_DIC %>%
  distinct(Gene, Category) %>%
  mutate(Category = factor(Category, levels = category_order_DIC)) %>% 
  arrange(Category, Gene)

ordered_genes_DIC <- gene_order_df_DIC$Gene
logFC_mat_DIC <- logFC_mat_DIC[ordered_genes_DIC, ]
signif_mat_DIC <- signif_mat_DIC[ordered_genes_DIC, ]

#add in your colors for each category
 category_colors_DIC <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = category_order_DIC
)

ha_left_DIC <- rowAnnotation(
  Category = gene_order_df_DIC$Category,
  col = list(Category = category_colors_DIC),
  annotation_name_side = "top"
)

# Draw heatmap
Heatmap(logFC_mat_DIC,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DIC,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DIC[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "DIC Genes Expression (n=29)\nDOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)


```

##Plot p53 Target Genes logFC HM Original Data
```{r p53 Target Genes logFC HM, fig.height=12, fig.width=10}
# Load libraries
# library(tidyverse)
# library(ComplexHeatmap)
# library(circlize)
# library(grid)
# library(org.Hs.eg.db)
# library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

#P53 target Entrez_ID
entrez_ids_p53 <- c(1026,50484,4193,9766,9518,7832,1643,1647,1263,57103,51065,8795,51499,64393,581,
                5228,5429,8493,55959,7508,64782,282991,355,53836,4814,10769,9050,27244,9540,94241,
                26154,57763,900,26999,55332,26263,23479,23612,29950,9618,10346,8824,134147,55294,
                22824,4254,6560,467,27113,60492,8444,60401,1969,220965,2232,3976,55191,84284,93129,
                5564,7803,83667,7779,132671,7039,51768,137695,93134,7633,10973,340485,307,27350,
                23245,3732,29965,1363,1435,196513,8507,8061,2517,51278,53354,54858,23228,5366,5912,
                6236,51222,26152,59,1907,50650,91012,780,9249,11072,144455,64787,116151,27165,2876,
                57822,55733,57722,121457,375449,85377,4851,5875,127544,29901,84958,8797,8793,441631,
                220001,54541,5889,5054,25816,25987,5111,98,317,598,604,10904,1294,80315,53944,
                1606,2770,3628,3675,3985,4035,4163,84552,29085,55367,5371,5791,54884,5980,8794,
                1462,50808,220,583,694,1056,9076,10978,54677,1612,55040,114907,2274,127707,4000,
                8079,4646,4747,27445,5143,80055,79156,5360,5364,23654,5565,5613,5625,10076,56963,
                6004,390,255488,6326,6330,23513,7869,283130,204962,83959,6548,6774,9263,10228,
                22954,10475,85363,494514,10142,79714,1006,8446,9648,79828,5507,55240,63874,25841,
                9289,84883,154810,51321,421,8553,655,119032,84280,10950,824,839,57828,857,8812,
                8837,94027,113189,22837,132864,10898,3300,81704,1847,1849,1947,9538,24139,5168,
                147965,115548,9873,23768,2632,2817,3280,3265,23308,3490,51477,182,3856,8844,144811,
                9404,4043,9848,2872,23041,740,343263,4638,26509,4792,22861,57523,55214,80025,164091,
                57060,64065,51090,5453,8496,333926,55671,5900,55544,23179,8601,389,6223,55800,6385,
                4088,6643,122809,257397,285343,7011,54790,374618,55362,51754,7157,9537,22906,7205,
                80705,219699,55245,83719,7748,25946,118738)

# p53_genes <- saveRDS(entrez_ids_p53, "data/new/RUV/p53_genelist_entrezid.RDS")

# Function to extract relevant data
extract_data_p53 <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_p53) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                         column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}

# Collect all data
# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_p53 <- bind_rows(mapply(extract_data_p53, deg_list, names(deg_list), SIMPLIFY = FALSE)) 
#unnecessary to join again as there are not categories on this list of entrezids
# %>%
#   left_join(entrez_ids, by = c("Entrez_ID" = "ENTREZID"))

# Create matrices
logFC_mat53 <- acast(all_data_p53, Gene ~ Condition, value.var = "logFC")
signif_mat53 <- acast(all_data_p53, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_p53 <- logFC_mat53[, desired_order]
signif_mat_p53 <- signif_mat53[, desired_order]

# Column annotation
meta_p53 <- str_split_fixed(colnames(logFC_mat_p53), "_", 3)
meta_p53 <- str_split_fixed(colnames(logFC_mat_p53), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_p53[, 1],
  Time = meta_p53[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_p53,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

```

##Create a Venn Diagram of DEGs from Original DEA
```{r Overlap of DEGs Original}
#plot a venn diagram with all of your conditions from your toptables

# Load DEGs Data
DOX_24T <- read.csv("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- read.csv("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- read.csv("data/new/DEGs/Toptable_V.D144R.csv")

# Extract Significant DEGs
DEG1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
DEG2 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
DEG3 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]


venntest <- list(DEG1, DEG2, DEG3)
ggVennDiagram(
  venntest,
  category.names = c("DOX_24T", "DOX_24R", "DOX_144R")
) + ggtitle("DXR Specific and Shared DEGs")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#Now that I've made my venn diagram, I want to compare these DEGs
#set 1 : 4362 DOX24T specific genes
#set2 : 4362 + 4550 + 50 + 272 genes shared across DOX24T (all genes)
#how many of these are downregulated and how many are upregulated?

# Extract Significant DEGs
# Create a list of DEGs for each sample

# Example gene sets

DEG1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
DEG2 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
DEG3 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]

#try and use the VennDetail package to extract the genes from each condition
#Set 1 - DOX_24T only genes
#Set 2 - DOX_24T shared genes
plot.new()
venn_test <- venndetail(venntest)
plot(venn_test)
detail(venn_test)
#now that I have the genes subsetted by condition, I can pull out the genes I want to look at

venn_DOX_24T <- getSet(object = venn_test, subset = c("Group 1"))
dim(venn_DOX_24T)
#4362 genes in DOX_24T only

venn_DOX_shared <- getSet(object = venn_test, subset = c("Shared", "Group 1", "Group 1_Group 2", "Group 1_Group 3"))
dim(venn_DOX_shared)
#total of 9243 genes:
  #4559 DOX_24T only 
  #272 shared all
  #50 DOX_24T + DOX_144R
  #4362 DOX_24T + DOX_24R

venn_DOX144R_shared <- getSet(object = venn_test, subset = c("Shared", "Group 3", "Group 2_Group 3", "Group 1_Group 3"))
dim(venn_DOX144R_shared)
#total of 509 genes:
 #272 shared all
 #32 DOX144R Specific
 #50 DOX24T + DOX144R
 #155 DOX24R + DOX144R

#now I can look at these sets to see which ones are up and down regulated in each
#after that, run GO analysis
venn_shared_DEGs <- venn_DOX_shared %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_sharedD144R_DEGs <- venn_DOX144R_shared %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_DOX24T_DEGs <- venn_DOX_24T %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")


#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs <- Toptable_list$V.D24T[row.names(venn_DOX24T_DEGs),]
DOX_24T_shared_DEGs <- Toptable_list$V.D24T[row.names(venn_shared_DEGs),]
DOX_144R_shared_DEGs <- Toptable_list$V.D144R[row.names(venn_sharedD144R_DEGs),]
#I want to go ahead and do this for every condition so I can see the genes in there
#I also want to filter these by their logFC being up or down for GO/KEGG

DOX24T_DEGs_GO <- DOX_24T_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX24T_DEGs_GO_up <- DOX24T_DEGs_GO %>% 
  dplyr::filter(., logFC > 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4029 genes

DOX24T_DEGs_GO_down <- DOX24T_DEGs_GO %>% 
  dplyr::filter(., logFC < 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4305 genes

#shared genes venn diagram
DOX24Tshare_DEGs_GO <- DOX_24T_shared_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05) 

DOX24T_share_DEGs_GO_plot <- DOX24Tshare_DEGs_GO %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::select("Entrez_ID")

DOX24Tshare_DEGs_GO_up <- DOX24Tshare_DEGs_GO %>% 
  dplyr::filter(., logFC > 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4731 genes

DOX24Tshare_DEGs_GO_down <- DOX24Tshare_DEGs_GO %>% 
  dplyr::filter(., logFC < 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")

DOX144Rshare_DEGs_GO <- DOX_144R_shared_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX144Rshare_DEGs_GO_plot <- DOX144Rshare_DEGs_GO %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::select("Entrez_ID")


#now go ahead and do this for each condition as well

#DOX24T
venn_DOX_24T <- getSet(object = venn_test, subset = c("Group 1"))
dim(venn_DOX_24T)
#4362 genes in DOX_24T only

venn_DOX24T_DEGs <- venn_DOX_24T %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs <- Toptable_list$V.D24T[row.names(venn_DOX24T_DEGs),]

DOX24T_DEGs_GO <- DOX_24T_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#DOX24R
venn_DOX_24R <- getSet(object = venn_test, subset = c("Group 2"))
dim(venn_DOX_24R)
#2182 genes in DOX_24R only

venn_DOX24R_DEGs <- venn_DOX_24R %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24R_DEGs <- Toptable_list$V.D24R[row.names(venn_DOX24R_DEGs),]

DOX24R_DEGs_GO <- DOX_24R_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")


#DOX144R
venn_DOX_144R <- getSet(object = venn_test, subset = c("Group 3"))
dim(venn_DOX_144R)
#32 genes in DOX_144R only

venn_DOX144R_DEGs <- venn_DOX_144R %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_144R_DEGs <- Toptable_list$V.D144R[row.names(venn_DOX144R_DEGs),]

DOX144R_DEGs_GO <- DOX_144R_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#this set doesn't yield a GO/KEGG plot as there are too few genes
#instead, I pulled all genes associated with DOX144R

```

##Venn Diagrams of DEG Overlap after RUVs Correction k=1
```{r RUVs Overlap of DEGs}
#plot a venn diagram with all of your conditions from your toptables

# Load DEGs Data (replaced with new set)
DOX_t0 <- read_csv("data/new/DEGs/Toptable_RUV_24T_final.csv") #this one no X col
DOX_t24 <- read_csv("data/new/DEGs/Toptable_RUV_24R_final.csv", 
                    col_select = -1)
DOX_t144 <- read_csv("data/new/DEGs/Toptable_RUV_144R_final.csv", 
                     col_select = -1)

# Extract Significant DEGs (change names to timepoint)
DEG_t0_RUV <- DOX_t0$Entrez_ID[DOX_t0$adj.P.Val < 0.05]
DEG_t24_RUV <- DOX_t24$Entrez_ID[DOX_t24$adj.P.Val < 0.05]
DEG_t144_RUV <- DOX_t144$Entrez_ID[DOX_t144$adj.P.Val < 0.05]

venn_test_RUV <- list(DEG_t0_RUV, DEG_t24_RUV, DEG_t144_RUV)
ggVennDiagram(
  venn_test_RUV,
  category.names = c("DOX_t0", "DOX_t24", "DOX_t144")
) + ggtitle("DXR Specific and Shared DEGs RUVs")+
  theme_custom() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

####I want to make this proportional
#use the eulerr package to do so

# library(eulerr)

venn_prop_RUV <- euler(list(
  "t0" = DEG_t0_RUV,
  "t24" = DEG_t24_RUV,
  "t144" = DEG_t144_RUV
))

plot(venn_prop_RUV,
     fills = list(fill = c("#263CA5", "#5B8FD1", "#89C5E5"), 
                  alpha = 1),
     labels = list(font = 4),
     quantities = list(cex = 0.75),
     main = "")


#try and use the VennDetail package to extract the genes from each condition
#Set 1 - DOX_24T only genes
#Set 2 - DOX_24T shared genes
#Set 3 - DOX_144R shared genes
plot.new()
venn_test_RUV <- venndetail(venn_test_RUV)
plot(venn_test_RUV)
detail(venn_test_RUV)
#now that I have the genes subsetted by condition, I can pull out the genes I want to look at

venn_genes_t0_RUV <- getSet(object = venn_test_RUV, subset = c("Group 1"))
dim(venn_genes_t0_RUV)
#4411 genes in DOX_24T only

venn_genes_shared_RUV <- getSet(object = venn_test_RUV, subset = c("Shared", "Group 1_Group 2", "Group 1_Group 3"))
dim(venn_genes_shared_RUV)
#total of 5009 genes in this set which does not include D24T specific genes

venn_genes_t144_shared_RUV <- getSet(object = venn_test_RUV, subset = c("Shared", "Group 3", "Group 2_Group 3", "Group 1_Group 3"))
dim(venn_genes_t144_shared_RUV)
#total of 660 genes: (original 509)
 #342 shared all
 #32 DOX_t144 Specific
 #85 DOX_t0 + DOX_t144
 #181 DOX_t24 + DOX_t144

#after that, run GO analysis
venn_shared_DEGs_RUV <- venn_genes_shared_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_genes_t0_DEGs_RUV <- venn_genes_t0_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_genes_t144_DEGs_RUV <- venn_genes_t144_shared_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_t0_DEGs_RUV <-
  Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_genes_t0_DEGs_RUV),]
DOX_t0_shared_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_shared_DEGs_RUV),]
DOX_t144_shared_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D144R_RUV[row.names(venn_genes_t144_DEGs_RUV),]

#next, make the vectors that I need for plotting after cutting off by adj. p value < 0.05
DOX_t0_DEGs_GO_RUV <- DOX_t0_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05)

#shared D24T genes venn diagram
DOX_t0_share_DEGs_GO_RUV <- DOX_t0_shared_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) 

DOX_t0_share_DEGs_GO_plot_RUV <- DOX_t0_share_DEGs_GO_RUV %>% 
  dplyr::select("Entrez_ID")

#shared DOX_t144 genes venn diagram

DOX_t144_share_DEGs_GO_RUV <- DOX_t144_shared_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX_t144_share_DEGs_GO_plot_RUV <- DOX_t144_share_DEGs_GO_RUV %>% 
  dplyr::select("Entrez_ID")

#now go ahead and do this for each condition as well

#DOX_t0
venn_DOX_t0_RUV <- getSet(object = venn_test_RUV, subset = c("Group 1"))
dim(venn_DOX_t0_RUV)
#4411 genes in DOX_24T only

venn_DOX_t0_DEGs_RUV <- venn_DOX_t0_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_t0_DEGs_RUV <- Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_DOX_t0_DEGs_RUV),]

DOX_t0_DEGs_GO_RUV <- DOX_t0_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#DOX_t24
venn_DOX_t24_RUV <- getSet(object = venn_test_RUV, subset = c("Group 2"))
dim(venn_DOX_t24_RUV)
#2107 genes in DOX_24R only

venn_DOX_t24_DEGs_RUV <- venn_DOX_t24_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_t24_DEGs_RUV <- Toptable_list_RUVk1_symbols$V.D24R_RUV[row.names(venn_DOX_t24_DEGs_RUV),]

DOX_t24_DEGs_GO_RUV <- DOX_t24_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")


#DOX144R
venn_DOX_t144_RUV <- getSet(object = venn_test_RUV, subset = c("Group 3"))
dim(venn_DOX_t144_RUV)
#52 genes in DOX_144R only

venn_DOX_t144_DEGs_RUV <- venn_DOX_t144_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_t144_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D144R_RUV[row.names(venn_DOX_t144_DEGs_RUV),]

DOX_t144_DEGs_GO_RUV <- DOX_t144_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")
```
###Proportion of DEGs in Gene Set RUVs corrected
```{r Proportion of DEGs}
#check the proportion of my genes in my gene set that are DEGs by timepoint

#make this into a pie chart or a bar graph
#read in my full gene set
all_genes <- readRDS("data/new/RUV/all_genes_set.RDS") 

#convert Entrez_ID to Gene Symbols
all_genes_set <- mapIds(org.Hs.eg.db, 
                        keys = all_genes,
                        column = "SYMBOL",
                        keytype = "ENTREZID",
                        multiVals = "first")

#load in my DEGs (replaced with new set)
DOX_24T_R <- read_csv("data/new/DEGs/Toptable_RUV_24T_final.csv") #this one no X col
DOX_24R_R <- read_csv("data/new/DEGs/Toptable_RUV_24R_final.csv",
                    col_select = -1)
DOX_144R_R <- read_csv("data/new/DEGs/Toptable_RUV_144R_final.csv",
                     col_select = -1)

# Extract Significant DEGs (change names to timepoint)
DEG_24T_RUV <- DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05]
DEG_24R_RUV <- DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05]
DEG_144R_RUV <- DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]

# saveRDS(DEG_24T_RUV, "data/new/RUV/DEGs_sig_list_24T_RUVs_set.RDS")
# saveRDS(DEG_24R_RUV, "data/new/RUV/DEGs_sig_list_24R_RUVs_set.RDS")
# saveRDS(DEG_144R_RUV, "data/new/RUV/DEGs_sig_list_144R_RUVs_set.RDS")

#make a list of all of my significant DEGs
timepoint_DEGs_RUV <- list(
  "24T" = DEG_24T_RUV,
  "24R" = DEG_24R_RUV,
  "144R" = DEG_144R_RUV
)

# Function to compute proportions
get_proportions_degs <- function(degs, total_genes) {
  deg_count <- length(degs)
  non_deg_count <- total_genes - deg_count
  data.frame(
    Category = c("DEGs", "Non-DEGs"),
    Count = c(deg_count, non_deg_count),
    Proportion = c(deg_count / total_genes, non_deg_count / total_genes)
  )
}

# Compute proportions for each timepoint
prop_t0 <- get_proportions_degs(DEG_24T_RUV, length(all_genes_set))
prop_t24 <- get_proportions_degs(DEG_24R_RUV, length(all_genes_set))
prop_t144 <- get_proportions_degs(DEG_144R_RUV, length(all_genes_set))

# Combine for bar plot
prop_bar <- rbind(
  cbind(Timepoint = "t0", prop_t0),
  cbind(Timepoint = "t24", prop_t24),
  cbind(Timepoint = "t144", prop_t144)
)

#pie chart for t0
ggplot(prop_t0, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  labs(title = "DEGs vs Non-DEGs (t0)") +
  theme_void()

#pie chart for t24
ggplot(prop_t24, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  labs(title = "DEGs vs Non-DEGs (t24)") +
  theme_void()

#pie chart for t144
ggplot(prop_t144, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  labs(title = "DEGs vs Non-DEGs (t144)") +
  theme_void()

# library(patchwork)

#put the desired colors here for your pie charts
degs_prop_colors <- c("DEGs" = "red", "Non-DEGs" = "blue")

#labels for percentage based on proportion
prop_t0$Label <- paste0(round(prop_t0$Proportion * 100, 1), "")
prop_t24$Label <- paste0(round(prop_t24$Proportion * 100, 1), "")
prop_t144$Label <- paste0(round(prop_t144$Proportion * 100, 1), "")

#create each plot and assign to variables
plot_t0 <- ggplot(prop_t0, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = Label), 
            position = position_stack(vjust = 0.6), 
            color = "white", 
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "t0") +
  theme_void()

plot_t24 <- ggplot(prop_t24, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = Label), 
            position = position_stack(vjust = 0.6), 
            color = "white", 
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "t24") +
  theme_void()

plot_t144 <- ggplot(prop_t144, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = Label), 
            position = position_stack(vjust = 0.6), 
            color = "white", 
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "t144") +
  theme_void()

#combine all three pie charts in a row
combined_prop_degs_plots <- 
  plot_t0 + 
  plot_t24 + 
  plot_t144 +
  plot_layout(ncol = 3, nrow = 1, guides = "collect") + 
  plot_annotation(title = "Proportion of DEGs vs Non-DEGs")

#show the combined pie chart plot
combined_prop_degs_plots

#combine all three pie charts in a column
combined_prop_degs_plots_col <- 
  plot_t0 + 
  plot_t24 + 
  plot_t144 +
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation(title = "Proportion of DEGs vs Non-DEGs")

#show the combined pie chart plot in 1 column
combined_prop_degs_plots_col

####proportion bar plots####
#first factor the timepoints so that they are in the right order
prop_bar$Timepoint <- factor(prop_bar$Timepoint, 
                             levels = c("t0", "t24", "t144"))

#percentage labels
prop_bar$Label <- paste0(round(prop_bar$Proportion * 100, 1), "")

#plot the bar plot
barplot_deg_perc <- ggplot(prop_bar, aes(x = Timepoint, 
                     y = Proportion, 
                     fill = Category)) +
  geom_bar(stat = "identity", 
           position = "fill") +
  geom_text(aes(label = Label),
            position = position_fill(vjust = 0.5),
            color = "white",
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "Percentage of DEGs vs nonDEGs by Timepoint",
       y = "Percentage of DEGs (%)", 
       x = "") +
  scale_y_continuous(labels = c(0, 25, 50, 75, 100)) +
  theme_custom()

#save this barplot

# save_plot(
#   plot = barplot_deg_perc,
#   filename = "DEGvsnonDEG_Barplot_update_EMP",
#   folder = output_folder
# )

```
#I FINISHED CHANGING NAMES HERE

###GO KEGG Overlap of DEGs From Original Data
```{r GO KEGG Overlap DEGs Original}
#####DOX24 Genes#####
# library(gprofiler2)

#define your background gene set (all expressed genes for me)
all_genes <- rownames(filcpm_matrix)

D24_DEGs_mat <- as.matrix(DOX24T_DEGs_GO)

DOX_24_dxr_gene <- gost(query = D24_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_gost_genes <- gostplot(DOX_24_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_gost_genes

table_DOX24_genes <- DOX_24_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24_genes_GOBP <- table_DOX24_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))


table_DOX24_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_genes_KEGG <- table_DOX24_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T shared DEGs GO KEGG#####
D24Tshare_DEGs_mat <- as.matrix(DOX24T_share_DEGs_GO_plot)

DOX_24Tshare_dxr_gene <- gost(query = D24Tshare_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_gost_genes <- gostplot(DOX_24Tshare_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_gost_genes

table_DOX24Tshare_genes <- DOX_24Tshare_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24Tshare_genes_GOBP <- table_DOX24Tshare_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_genes_KEGG <- table_DOX24Tshare_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R DEGs GO KEGG#####
D24R_DEGs_mat <- as.matrix(DOX24R_DEGs_GO)

DOX_24R_dxr_gene <- gost(query = D24R_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24R_gost_genes <- gostplot(DOX_24R_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24R_gost_genes

table_DOX24R_genes <- DOX_24R_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24R_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24R_genes_GOBP <- table_DOX24R_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R Specific DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24R_genes_KEGG <- table_DOX24R_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R DEGs GO KEGG#####
# D144R_DEGs_mat <- as.matrix(DOX144R_DEGs_GO)
# 
# DOX_144R_dxr_gene <- gost(query = D144R_DEGs_mat,
#                       organism = "hsapiens",
#                       ordered_query = FALSE,
#                       measure_underrepresentation = FALSE,
#                       evcodes = FALSE,
#                       user_threshold = 0.05,
#                       correction_method = c("fdr"),
#                       sources = c("GO:BP", "KEGG"))
# 
# DOX_144R_gost_genes <- gostplot(DOX_144R_dxr_gene, capped = FALSE, interactive = TRUE)
# DOX_144R_gost_genes
# 
# table_DOX144R_genes <- DOX_144R_dxr_gene$result %>% 
#   dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))
# 
# table_DOX144R_genes %>% 
#   mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
#   kableExtra::kable(.,) %>% 
#   kableExtra::kable_paper("striped", full_width = FALSE) %>% 
#   kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
#   kableExtra::scroll_box(width = "100%", height = "400px")
# 
# #GO:BP
# table_DOX144R_genes_GOBP <- table_DOX144R_genes %>% 
#   dplyr::filter(source=="GO:BP") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144R_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R Specific DEGs Enriched GO:BP Terms")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("GO:BP term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
# 
# #KEGG
# table_DOX144R_genes_KEGG <- table_DOX144R_genes %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144R_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R DEGs Enriched KEGG Terms")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R shared DEGs GO KEGG#####
D144Rshare_DEGs_mat <- as.matrix(DOX144Rshare_DEGs_GO_plot)

DOX_144Rshare_dxr_gene <- gost(query = D144Rshare_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_144Rshare_gost_genes <- gostplot(DOX_144Rshare_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_144Rshare_gost_genes

table_DOX144Rshare_genes <- DOX_144Rshare_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144Rshare_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144Rshare_genes_GOBP <- table_DOX144Rshare_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX144Rshare_genes_KEGG <- table_DOX144Rshare_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```

###GO/KEGG Analysis of Upreg and Downreg Genes Original Data
```{r GO KEGG Overlap DEGs Up/Down}
# library(gprofiler2)
#####DOX24 Upregulated Genes#####
D24_DEGs_up_mat <- as.matrix(DOX24T_DEGs_GO_up)

DOX_24_up_dxr_gene <- gost(query = D24_DEGs_up_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_up_gost_genes <- gostplot(DOX_24_up_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_up_gost_genes

table_DOX24_up_genes <- DOX_24_up_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_up_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24_up_genes, "output/table_DOX24_upreg_genes.csv")

#GO:BP
table_DOX24_up_genes_GOBP <- table_DOX24_up_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24_up_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Up DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_up_genes_KEGG <- table_DOX24_up_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_up_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Up DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24 Downregulated Genes#####
D24_DEGs_down_mat <- as.matrix(DOX24T_DEGs_GO_down)

DOX_24_down_dxr_gene <- gost(query = D24_DEGs_down_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_down_gost_genes <- gostplot(DOX_24_down_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_down_gost_genes

table_DOX24_down_genes <- DOX_24_down_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_down_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24_down_genes, "output/table_DOX24_downreg_genes.csv")

#GO:BP
table_DOX24_down_genes_GOBP <- table_DOX24_down_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24_down_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Down DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_down_genes_KEGG <- table_DOX24_down_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_down_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Down DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T share Upregulated DEGs GO KEGG#####
D24Tshare_DEGs_up_mat <- as.matrix(DOX24Tshare_DEGs_GO_up)

DOX_24Tshare_up_dxr_gene <- gost(query = D24Tshare_DEGs_up_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_up_gost_genes <- gostplot(DOX_24Tshare_up_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_up_gost_genes

table_DOX24Tshare_up_genes <- DOX_24Tshare_up_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_up_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24R_up_genes, "output/table_DOX24R_upreg_genes.csv")

#GO:BP
table_DOX24Tshare_up_genes_GOBP <- table_DOX24Tshare_up_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24Tshare_up_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Up DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_up_genes_KEGG <- table_DOX24Tshare_up_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_up_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Up DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R Downregulated DEGs GO KEGG#####
D24Tshare_DEGs_down_mat <- as.matrix(DOX24Tshare_DEGs_GO_down)

DOX_24Tshare_down_dxr_gene <- gost(query = D24Tshare_DEGs_down_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_down_gost_genes <- gostplot(DOX_24Tshare_down_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_down_gost_genes

table_DOX24Tshare_down_genes <- DOX_24Tshare_down_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_down_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24R_down_genes, "output/table_DOX24R_downreg_genes.csv")

#GO:BP
table_DOX24Tshare_down_genes_GOBP <- table_DOX24Tshare_down_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24Tshare_down_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Down DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_down_genes_KEGG <- table_DOX24Tshare_down_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_down_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Down DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))
```
###RUVs GO/KEGG for All Conditions
```{r RUVs GO KEGG}
#####DOX24 Genes Specific#####
D24_DEGs_mat_RUV <- as.matrix(DOX24T_DEGs_GO_RUV)
D24_DEGs_vec_RUV <- as.character(DOX24T_DEGs_GO_RUV$Entrez_ID)

#saveRDS(D24_DEGs_mat_RUV, "data/new/RUV/D24_DEGs_mat_RUV.RDS")

DOX_24_dxr_gene_RUV <- gost(query = D24_DEGs_vec_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24_gost_genes_RUV <- gostplot(DOX_24_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24_gost_genes_RUV

table_DOX24_genes_RUV <- DOX_24_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")


#GO:BP
table_DOX24_genes_GOBP_RUV <- table_DOX24_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))


table_DOX24_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG - no KEGG terms popped up for this one?
# table_DOX24_genes_KEGG_RUV <- table_DOX24_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24T Specific DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T shared DEGs GO KEGG#####
D24Tshare_DEGs_mat_RUV <- as.matrix(DOX24T_share_DEGs_GO_plot_RUV)

DOX_24Tshare_dxr_gene_RUV <- gost(query = D24Tshare_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24Tshare_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24Tshare_gost_genes_RUV <- 
  gostplot(DOX_24Tshare_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24Tshare_gost_genes_RUV

table_DOX24Tshare_genes_RUV <- DOX_24Tshare_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24Tshare_genes_GOBP_RUV <- table_DOX24Tshare_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX24Tshare_genes_KEGG_RUV <- table_DOX24Tshare_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24Tshare_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24T Shared DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R DEGs GO KEGG#####
D24R_DEGs_mat_RUV <- as.matrix(DOX24R_DEGs_GO_RUV)

DOX_24R_dxr_gene_RUV <- gost(query = D24R_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24R_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24R_gost_genes_RUV <- 
  gostplot(DOX_24R_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24R_gost_genes_RUV

table_DOX24R_genes_RUV <- DOX_24R_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24R_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24R_genes_GOBP_RUV <- table_DOX24R_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX24R_genes_KEGG_RUV <- table_DOX24R_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24R_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24R DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

####DOX144R DEGs GO KEGG#####
D144R_DEGs_mat_RUV <- as.matrix(DOX144R_DEGs_GO_RUV)

DOX_144R_dxr_gene_RUV <- gost(query = D144R_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_144R_dxr_gene_RUV$result$source)
#GO:BP and KEGG appearing here

DOX_144R_gost_genes_RUV <- 
  gostplot(DOX_144R_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_144R_gost_genes_RUV

table_DOX144R_genes_RUV <- DOX_144R_dxr_gene_RUV$result %>%
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144R_genes_RUV %>%
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>%
  kableExtra::kable(.,) %>%
  kableExtra::kable_paper("striped", full_width = FALSE) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>%
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144R_genes_GOBP_RUV <- table_DOX144R_genes_RUV %>%
  dplyr::filter(source=="GO:BP") %>%
  dplyr::select(p_value, term_name, intersection_size) %>%
  dplyr::slice_min(., n=10, order_by=p_value) %>%
  mutate(log_val = -log10(p_value))

table_DOX144R_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX144R_genes_KEGG_RUV <- table_DOX144R_genes_RUV %>%
  dplyr::filter(source=="KEGG") %>%
  dplyr::select(p_value, term_name, intersection_size) %>%
  dplyr::slice_min(., n=10, order_by=p_value) %>%
  mutate(log_val = -log10(p_value))

table_DOX144R_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R DEGs Enriched KEGG Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R shared DEGs GO KEGG#####
D144Rshare_DEGs_mat_RUV <- as.matrix(DOX144Rshare_DEGs_GO_plot_RUV)

DOX_144Rshare_dxr_gene_RUV <- gost(query = D144Rshare_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if any KEGG terms are appearing
unique(DOX_144Rshare_dxr_gene_RUV$result$source)
#only GO:BP appearing here

DOX_144Rshare_gost_genes_RUV <- 
  gostplot(DOX_144Rshare_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_144Rshare_gost_genes_RUV

table_DOX144Rshare_genes_RUV <- DOX_144Rshare_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144Rshare_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144Rshare_genes_GOBP_RUV <- table_DOX144Rshare_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX144Rshare_genes_KEGG_RUV <- table_DOX144Rshare_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144Rshare_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R Shared DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
```
#Plot DDR Genes logFC Heatmap RUVs k=1 
```{r RUVs DDR Genes logFC, fig.height=14, fig.width=8}
#DDR Gene Expression Heatmap  DOX Over Recovery Time (68 genes, with categories)
#now add in the RUV corrected data and see if this makes a difference at all!

# Load libraries
# library(circlize)
# library(grid)
# library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

# Final Entrez IDs and categories (68 genes)
#no need to change the name of this as it's the same
entrez_category_DDR <- tribble(
  ~ENTREZID, ~Category,
  317, "Apoptosis", 355, "Apoptosis", 581, "Apoptosis", 637, "Apoptosis",
  836, "Apoptosis", 841, "Apoptosis", 842, "Apoptosis", 27113, "Apoptosis",
  5366, "Apoptosis", 54205, "Apoptosis", 55367, "Apoptosis", 8795, "Apoptosis",
  1026, "Cell Cycle / Checkpoint", 1027, "Cell Cycle / Checkpoint", 595, "Cell Cycle / Checkpoint",
  894, "Cell Cycle / Checkpoint", 896, "Cell Cycle / Checkpoint", 898, "Cell Cycle / Checkpoint",
  9133, "Cell Cycle / Checkpoint", 9134, "Cell Cycle / Checkpoint", 891, "Cell Cycle / Checkpoint",
  983, "Cell Cycle / Checkpoint", 1017, "Cell Cycle / Checkpoint", 1019, "Cell Cycle / Checkpoint",
  1020, "Cell Cycle / Checkpoint", 1021, "Cell Cycle / Checkpoint", 993, "Cell Cycle / Checkpoint",
  995, "Cell Cycle / Checkpoint", 1869, "Cell Cycle / Checkpoint", 4609, "Cell Cycle / Checkpoint",
  5925, "Cell Cycle / Checkpoint", 9874, "Cell Cycle / Checkpoint", 11011, "Cell Cycle / Checkpoint",
  1385, "Cell Cycle / Checkpoint",
  472, "Damage Sensors / Signal Transducers", 545, "Damage Sensors / Signal Transducers",
  5591, "Damage Sensors / Signal Transducers", 5810, "Damage Sensors / Signal Transducers",
  5883, "Damage Sensors / Signal Transducers", 5884, "Damage Sensors / Signal Transducers",
  6118, "Damage Sensors / Signal Transducers", 4361, "Damage Sensors / Signal Transducers",
  10111, "Damage Sensors / Signal Transducers", 4683, "Damage Sensors / Signal Transducers",
  84126, "Damage Sensors / Signal Transducers", 3014, "Damage Sensors / Signal Transducers",
  672, "DNA Repair", 2177, "DNA Repair", 5888, "DNA Repair", 5893, "DNA Repair",
  1647, "DNA Repair", 4616, "DNA Repair", 10912, "DNA Repair", 1111, "DNA Repair",
  11200, "DNA Repair", 1643, "DNA Repair", 8243, "DNA Repair", 5981, "DNA Repair",
  7157, "p53 Regulators / Targets", 4193, "p53 Regulators / Targets", 5371, "p53 Regulators / Targets",
  27244, "p53 Regulators / Targets", 50484, "p53 Regulators / Targets",
  207, "Miscellaneous / Broad", 25, "Miscellaneous / Broad"
)

entrez_ids_DDR_R <- entrez_category_DDR$ENTREZID

# saveRDS(entrez_ids_DDR_R, "data/new/RUV/DDR_genes_entrezid.RDS")

# Extract relevant DEG values
extract_data_DDR_R <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DDR_R) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_DDR_RUV <- bind_rows(mapply(extract_data_DDR_R, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) %>%
  left_join(entrez_category_DDR, by = c("Entrez_ID" = "ENTREZID"))

# DDR_genesymbols_list_RUV <- all_data_DDR_RUV$Gene
# write.csv(DDR_genesymbols_list_RUV, "data/new/RUV/DDR_Genes_list_RUV.csv")
# saveRDS(DDR_genesymbols_list_RUV, "data/new/RUV/DDR_Genes_list_RUV.RDS")

# Create matrices
logFC_matddr_R <- acast(all_data_DDR_RUV, Gene ~ Condition, value.var = "logFC")
signif_matddr_R <- acast(all_data_DDR_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DDR_RUV <- logFC_matddr_R[, desired_order, drop = FALSE]
signif_mat_DDR_RUV <- signif_matddr_R[, desired_order, drop = FALSE]

# Column annotation
meta_DDR_R <- str_split_fixed(colnames(logFC_mat_DDR_RUV), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DDR_R[, 1],
  Time = meta_DDR_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Row annotation
gene_order_df_DDR_RUV <- all_data_DDR_RUV %>%
  distinct(Gene, Category) %>%
  arrange(factor(Category, levels = sort(unique(entrez_category_DDR$Category))), Gene)

ordered_genes_DDR_RUV <- gene_order_df_DDR_RUV$Gene
logFC_mat_DDR_RUV <- logFC_mat_DDR_RUV[ordered_genes_DDR_RUV, ]
signif_mat_DDR_RUV <- signif_mat_DDR_RUV[ordered_genes_DDR_RUV, ]

category_levels <- sort(unique(entrez_category_DDR$Category))

category_colors_DDR <- setNames(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple"),
  category_levels
)

ha_left_DDR_RUV <- rowAnnotation(
  Category = gene_order_df_DDR_RUV$Category,
  col = list(Category = category_colors_DDR),
  annotation_name_side = "top"
)

# Final Heatmap
Heatmap(logFC_mat_DDR_RUV,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DDR_RUV,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "DDR Gene Expression Response (n = 65)\n DOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold"),
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DDR[i, j], x, y, gp = gpar(fontsize = 9))
        }
)
```

##LogFC of DDR Gene Set after RUVs Correction
```{r logFC DDR Boxplots RUVs Genes}
# library(car)

#get an overall idea of the response occurring in all genes with logFC across time
#start with the logFC and then do the abs logFC

####data setup####
#Read DNA Damage Response Gene List

#this had an extra column that was unncessesary
# DNA_damage <- read.csv("data/new/RUV/DDR_Genes_list_RUV.csv", stringsAsFactors = FALSE) %>% 
#   dplyr::select(-(X))
#   
# names(DNA_damage)[names(DNA_damage) == "x"] <- "Symbol"
#   
#saveRDS(DNA_damage, "data/new/RUV/DNA_damage_genesymbols.RDS")

#this is the final processed version with a single list of symbols with col name
DNA_damage <- readRDS("data/new/RUV/DNA_damage_genesymbols.RDS")

#Convert gene symbols to Entrez IDs
DNA_damage <- DNA_damage %>%
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = Symbol,
                            column = "ENTREZID",
                            keytype = "SYMBOL",
                            multiVals = "first"))

DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)

time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

#load in my DEGs which I'll use to create a combined toptable
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)


filtered_toptables_RUV <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DNA_damage_genes)

filtered_toptables_RUV <- filtered_toptables_RUV %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

levene_results_RUV <- filtered_toptables_RUV %>%
  group_by(Timepoint) %>%
  summarise(p_value = leveneTest(logFC ~ Timepoint, data = .)$`Pr(>F)`[1], .groups = "drop") %>%
  mutate(significance = ifelse(p_value < 0.05, "*", ""))  # Use p < 0.05 threshold for stars

# ** Determine Y-axis position for Stars**
star_positions <- filtered_toptables_RUV %>%
  group_by(Timepoint,Drug) %>%
  summarise(y_pos = max(logFC, na.rm = TRUE) + 0.5, .groups = "drop") %>%
  group_by(Timepoint) %>%
  summarise(y_pos = max(y_pos), .groups = "drop")

# ** Merge Levene test results with Y positions**
levene_results_plot_RUV <- levene_results_RUV %>%
  left_join(star_positions, by = c("Timepoint")) %>%
  mutate(x_position = 1.5)

ggplot(filtered_toptables_RUV, aes(x = Drug, y = logFC, fill = Timepoint)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Violin plot for logFC
  geom_boxplot(width = 0.1, outlier.shape = NA, color = "black", alpha = 0.5) +  # Add boxplot inside violin
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_grid(Drug ~ Timepoint) +  
  geom_text(
    data = levene_results_plot_RUV %>% filter(significance == "*"),  # Only plot significant comparisons
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("LogFC Distribution for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

```
```{r DDR RUVs Genes Proportion}
# Read DNA Damage Genes List
# DNA_damage
# 
# # Convert gene symbols to Entrez IDs
# DNA_damage <- DNA_damage %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = Symbol,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))
# 
# # Extract DNA damage gene Entrez IDs
# DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)
# total_DNA_damage_genes <- length(DNA_damage_genes)  # Total number of DNA damage genes
# 
# # Define DEG lists (with significant ones only)
# DOX_DEGs <- list(
#   "DOX_24T" = DEG1_RUV, "DOX_24R" = DEG2_RUV, "DOX_144R" = DEG3_RUV
# )
# 
# # Function to calculate the presence of DNA damage genes in DEGs 
# calculate_proportion_DDR <- function(deg_list, drug_name) {
#   data.frame(
#     Sample = names(deg_list),
#     Drug = drug_name,
#     DNA_Damage_DEGs = sapply(deg_list, function(ids) sum(ids %in% DNA_damage_genes)),  # DEGs present in DNA damage set
#     Non_DNA_Damage_DEGs = sapply(deg_list, function(ids) total_DNA_damage_genes - sum(ids %in% DNA_damage_genes))  # Remaining DNA damage genes
#   ) %>%
#     mutate(
#       Yes_Proportion = (DNA_Damage_DEGs / total_DNA_damage_genes) * 100,  # Percentage of DEGs in DNA damage genes
#       No_Proportion = (Non_DNA_Damage_DEGs / total_DNA_damage_genes) * 100  # Remaining DNA damage genes as No
#     )
# }
# 
# # Calculate proportions for CX-5461 and DOX
# DOX_proportion <- calculate_proportion_DDR(DOX_DEGs, "DOX")
# 
# # Convert to long format for stacked bar plot
# proportion_long <- DOX_proportion %>%
#   dplyr::select(Sample, Drug, Yes_Proportion, No_Proportion) %>%
#   pivot_longer(cols = c(Yes_Proportion, No_Proportion), names_to = "Category", values_to = "Percentage") %>%
#   mutate(Category = ifelse(Category == "Yes_Proportion", "Yes", "No"))
# 
# # **Ensure correct order of samples on X-axis**
# sample_order <- c(
#   "DOX_24T", "DOX_24R", "DOX_144R"
# )
# proportion_long$Sample <- factor(proportion_long$Sample, levels = sample_order, ordered = TRUE)
# 
# # **Fix: Ensure "Yes" is on top and "No" is at the bottom in stacked bars**
# proportion_long$Category <- factor(proportion_long$Category, levels = c("Yes", "No"))  # Ensures "Yes" on top, "No" at bottom
# 
# # **Perform Chi-Square Test for DOX across timepoints**
# chi_square_results <- data.frame(Sample = character(), P_Value = numeric())
# 
# for (i in seq(1, 6)) {  #comparing across timepoints
#   tx24_sample <- sample_order[i] #DOX24T
#   rec24_sample <- sample_order[i + 6]   #DOX24R
#   rec144_sample <- sample_order[i + 12] #DOX144R
#   
#   tx24_data <- filter(DOX_proportion, Sample == tx24_sample)
#   rec24_data <- filter(DOX_proportion, Sample == rec24_sample)
#   rec144_data <- filter(DOX_proportion, Sample == rec144_sample)
#   
#   # Construct contingency table for Chi-Square test
#   contingency_table <- matrix(
#     c(tx24_data$DNA_Damage_DEGs, tx24_data$Non_DNA_Damage_DEGs,
#       rec24_data$DNA_Damage_DEGs, rec24_data$Non_DNA_Damage_DEGs,
#       rec144_data$DNA_Damage_DEGs, rec144_data$Non_DNA_Damage_DEGs),
#     nrow = 3, byrow = TRUE
#   )
#   
#   # Run Chi-Square Test
#   test_result <- chisq.test(contingency_table)
#   p_value <- test_result$p.value
#   
#   # Store results
#   chi_square_results <- rbind(chi_square_results, data.frame(Sample = tx24_sample, P_Value = p_value))
# }
# 
# # Add significance stars
# chi_square_results$Significant <- ifelse(chi_square_results$P_Value < 0.05, "*", "")
# 
# # Merge Chi-Square results
# proportion_long <- left_join(proportion_long, chi_square_results, by = "Sample")
# 
# # **Save output**
# write.csv(proportion_long, "C:/Work/Postdoc_UTMB/CX-5461 Project/Transcriptome literatures/lit2/Proportion_Stacked_DNA_Damage_DEGs_with_ChiSquare.csv", row.names = FALSE)
# 
# 
# # Define correct factor orders for samples
# sample_order <- c(
#   "CX_0.1_3", "CX_0.1_24", "CX_0.1_48", "CX_0.5_3", "CX_0.5_24", "CX_0.5_48",
#   "DOX_0.1_3", "DOX_0.1_24", "DOX_0.1_48", "DOX_0.5_3", "DOX_0.5_24", "DOX_0.5_48"
# )
# 
# # Reapply factor levels for correct order in both proportion_data and proportion_long
# proportion_data$Sample <- factor(proportion_data$Sample, levels = sample_order, ordered = TRUE)
# proportion_long$Sample <- factor(proportion_long$Sample, levels = sample_order, ordered = TRUE)
# 
# # **Fix: Ensure "Yes" is on top and "No" is at the bottom in stacked bars**
# proportion_long$Category <- factor(proportion_long$Category, levels = c("Yes", "No")
```

##LogFC of DDR Genes Across Timepoints RUVs
```{r logFC DDR Genes RUVs Across Timepoints}
# library(rstatix)
# Read DNA Damage Response Gene List
# DNA_damage as above

# Convert gene symbols to Entrez IDs
# DNA_damage <- DNA_damage %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = Symbol,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))

# DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)

# saveRDS(DNA_damage_genes, "data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

DNA_damage_genes <- readRDS("data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DNA_damage_genes) %>%
  mutate(abs_logFC = abs(logFC))

filtered_toptables_RUV <- filtered_toptables_RUV %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results <- filtered_toptables_RUV %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", ""))

#make a little thing of your timepoint comparisons
pairs <- wilcox_results %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint <- filtered_toptables_RUV %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions <- pairs %>%
  left_join(max_per_timepoint, by = c("group1" = "Timepoint"))
names(star_positions)[names(star_positions) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions <- star_positions %>%
  left_join(max_per_timepoint, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions)[names(star_positions) == "max_logFC"] <- "max2"

star_positions <- star_positions %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

wilcox_results_plot <- wilcox_results %>%
  left_join(star_positions, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot <- wilcox_results_plot %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot <- wilcox_results_plot %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )
```


#DIC Genes RUVs Corrected
```{r RUVs DIC Genes logFC HM}
#plot a list of 29 functionally validated DIC genes
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
DIC_genes <- tribble(
  ~SYMBOL, ~Category,
  "CAT", "ROS Generation / Handling",
  "CBR1", "ROS Generation / Handling",
  "CBR3", "ROS Generation / Handling",
  "ERBB2", "ROS Generation / Handling",
  "GPX3", "ROS Generation / Handling",
  "GSTM1", "ROS Generation / Handling",
  "GSTP", "ROS Generation / Handling",
  "HAS3", "ROS Generation / Handling",
  "NOS3", "ROS Generation / Handling",
  "PLCE1", "ROS Generation / Handling",
  "RAC2", "ROS Generation / Handling",
  "SPG7", "ROS Generation / Handling",
  "PRDM2", "DNA Damage", 
  "MLH1", "DNA Damage",
  "RARG", "DNA Damage",
  "HFE", "Iron Uptake & Homeostasis",
  "SLC22A17", "DOX Uptake",
  "SLC28A1", "DOX Uptake",
  "SLC28A3", "DOX Uptake",
  "ABCB4", "DOX Efflux",
  "ABCC2", "DOX Efflux",
  "ABCC5", "DOX Efflux", 
  "ABCC9", "DOX Efflux",
  "ABCC10", "DOX Efflux",
  "CELF4", "Calcium Handling",
  "MYH7", "Calcium Handling",
  "CYP2J2", "Cardiac Electrical Activity",
  "RIN3", "Cardiac Electrical Activity",
  "ZFN521", "Cardiac Electrical Activity")

gene_df_DIC_RUV <- tibble(HGNC = DIC_genes)

gene_df_DIC_RUV <- gene_df_DIC_RUV %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = DIC_genes$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

# DIC_genes_symb <- gene_df_DIC_RUV %>% 
#   dplyr::select("SYMBOL", "Entrez_ID")
# saveRDS(DIC_genes_symb, "data/new/RUV/DIC_genelist_symbolentrez_RUV.RDS")

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_DIC_RUV <- gene_df_DIC_RUV$Entrez_ID

# Extract relevant DEG values
extract_data_DIC_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DIC_RUV) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_DIC_RUV <- bind_rows(mapply(extract_data_DIC_RUV, 
                             deg_list_RUV, 
                             names(deg_list_RUV), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_DIC_RUV, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matdic_RUV <- acast(all_data_DIC_RUV, Gene ~ Condition, value.var = "logFC")
signif_matdic_RUV <- acast(all_data_DIC_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DIC_RUV <- logFC_matdic_RUV[, desired_order, drop = FALSE]
signif_mat_DIC_RUV <- signif_matdic_RUV[, desired_order, drop = FALSE]

# Column annotation
meta_DIC_R <- str_split_fixed(colnames(logFC_mat_DIC_RUV), "_", 3)
meta_DIC_R <- str_split_fixed(colnames(logFC_mat_DIC_RUV), "_", 2)
col_annot_RUV <- HeatmapAnnotation(
  Drug = meta_DIC_R[, 1],
  Time = meta_DIC_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)
#for this I can leave off the DMSO as it's already from a pairwise comparison

#make an extra object with my category order as well
category_order_DIC <- c(
  "ROS Generation / Handling",
  "DNA Damage",
  "Calcium Handling",
  "DOX Uptake",
  "Iron Uptake & Homeostasis",
  "DOX Efflux",
  "Cardiac Electrical Activity"
)

# Row annotation
gene_order_df_DIC_RUV <- all_data_DIC_RUV %>%
  distinct(Gene, Category) %>%
  mutate(Category = factor(Category, levels = category_order_DIC)) %>% 
  arrange(Category, Gene)

ordered_genes_DIC_RUV <- gene_order_df_DIC_RUV$Gene
logFC_mat_DIC_RUV <- logFC_mat_DIC_RUV[ordered_genes_DIC_RUV, ]
signif_mat_DIC_RUV <- signif_mat_DIC_RUV[ordered_genes_DIC_RUV, ]

#add in your colors for each category
 category_colors_DIC <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = category_order_DIC
)

ha_left_DIC_RUV <- rowAnnotation(
  Category = gene_order_df_DIC_RUV$Category,
  col = list(Category = category_colors_DIC),
  annotation_name_side = "top"
)

# Draw heatmap
Heatmap(logFC_mat_DIC_RUV,
        name = "logFC",
        top_annotation = col_annot_RUV,
        left_annotation = ha_left_DIC_RUV,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DIC_RUV[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "DIC Genes Expression (n=29)\nDOX Recovery (RUVs Corrected)",`
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)
```

```{r logFC Boxplots DIC RUVs Genes}
#get an overall idea of the logFC of these genes over timepoints
# library(rstatix)
# Read DIC gene list - named DOX_cardiotox

# DOX_cardiotox <- readRDS("data/new/RUV/DIC_genelist_symbolentrez_RUV.RDS")
# 
# # Convert gene symbols to Entrez IDs
# DOX_cardiotox <- DOX_cardiotox %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = SYMBOL,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))
# 
# DOX_cardiotox_genes <- na.omit(DOX_cardiotox$Entrez_ID)

# saveRDS(DOX_cardiotox_genes, "data/new/RUV/DIC_genes_symbolentrez.RDS")
#this already has both SYMBOL and Entrez_ID

DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_symbolentrez.RDS")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV_DIC <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DOX_cardiotox_genes) %>%
  mutate(abs_logFC = abs(logFC))

filtered_toptables_RUV_DIC <- filtered_toptables_RUV_DIC %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results_DIC <- filtered_toptables_RUV_DIC %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", ""))

#make a little thing of your timepoint comparisons
pairs_DIC <- wilcox_results_DIC %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint_DIC <- filtered_toptables_RUV_DIC %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions_DIC <- pairs_DIC %>%
  left_join(max_per_timepoint_DIC, by = c("group1" = "Timepoint"))
names(star_positions_DIC)[names(star_positions_DIC) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions_DIC <- star_positions_DIC %>%
  left_join(max_per_timepoint_DIC, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions_DIC)[names(star_positions_DIC) == "max_logFC"] <- "max2"

star_positions_DIC <- star_positions_DIC %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

wilcox_results_plot_DIC <- wilcox_results_DIC %>%
  left_join(star_positions_DIC, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot_DIC <- wilcox_results_plot_DIC %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot_DIC <- wilcox_results_plot_DIC %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV_DIC, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot_DIC, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for DIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV_DIC, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot_DIC, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for DIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )
```

#AIC Genes RUVs Corrected
```{r AIC Genes RUVs logFC HM, fig.height=12, fig.width=8}
#plot a list of 38 AIC genes identified by Renee in her paper
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
AIC_genes_set <- tribble(~SYMBOL,
                         "PELI2", "LGALS3", "LRRTM4", "PCCA", "NCOA2",
                         "NDN", "ADCY2", "TUSC3", "PLAAT1", "SORT1",
                         "GPSM2", "CLCC1", "SUCLA2", "LNPK", "NEDD4L",
                         "PLEKHA5", "GRAMD4", "TTC38", "CDPF1", "CELSR1",
                         "CYREN", "POLR3A", "LPL", "DGCR6", "NSUN7",
                         "APBB2", "DUBR", "PAM", "PPIP5K2", "GIN1",
                         "RARG", "TNS2", "ZNF740", "SLC28A3", "RMI1",
                         "EEF1B2", "FRS2", "HDDC2")

gene_df_AIC_RUV <- tibble(HGNC = AIC_genes_set)

gene_df_AIC_RUV <- gene_df_AIC_RUV %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = AIC_genes_set$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

# AIC_genes_symb <- gene_df_AIC_RUV %>%
#   dplyr::select("SYMBOL", "Entrez_ID")
# saveRDS(AIC_genes_symb, "data/new/RUV/AIC_genelist_symbolentrez_RUV.RDS")

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_AIC_RUV <- gene_df_AIC_RUV$Entrez_ID

# Extract relevant DEG values
extract_data_AIC_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_AIC_RUV) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_AIC_RUV <- bind_rows(mapply(extract_data_AIC_RUV, 
                             deg_list_RUV, 
                             names(deg_list_RUV), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_AIC_RUV, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matAIC_RUV <- acast(all_data_AIC_RUV, Gene ~ Condition, value.var = "logFC")
signif_matAIC_RUV <- acast(all_data_AIC_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_AIC_RUV <- logFC_matAIC_RUV[, desired_order, drop = FALSE]
signif_mat_AIC_RUV <- signif_matAIC_RUV[, desired_order, drop = FALSE]

# Column annotation
meta_AIC_R <- str_split_fixed(colnames(logFC_mat_AIC_RUV), "_", 3)
meta_AIC_R <- str_split_fixed(colnames(logFC_mat_AIC_RUV), "_", 2)
col_annot_RUV <- HeatmapAnnotation(
  Drug = meta_AIC_R[, 1],
  Time = meta_AIC_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)

# Draw heatmap
AIC_RUV_HM <- Heatmap(logFC_mat_AIC_RUV,
        name = "logFC",
        top_annotation = col_annot_RUV,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_AIC_RUV[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "AIC Genes Expression (n=38)\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

AIC_RUV_HM


#plot another one sideways in case I need it for figures
# Transpose the matrices
logFC_mat_AIC_RUV_t <- t(logFC_mat_AIC_RUV)
signif_mat_AIC_RUV_t <- t(signif_mat_AIC_RUV)

# Row annotation instead of column annotation
meta_AIC_R <- str_split_fixed(rownames(logFC_mat_AIC_RUV_t), "_", 2)
row_annot_RUV <- rowAnnotation(
  Drug = meta_AIC_R[, 1],
  Time = meta_AIC_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_width = unit(c(2, 2, 2), "cm")
)

# Draw rotated heatmap
AIC_RUV_HM_flip <- Heatmap(logFC_mat_AIC_RUV_t,
        name = "logFC",
        left_annotation = row_annot_RUV,   # moved annotation to the side
        cluster_columns = TRUE,
        cluster_rows = FALSE,
        show_row_names = FALSE,
        show_column_names = TRUE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_AIC_RUV_t[i, j], x, y, gp = gpar(fontsize = 9))
        },
        row_title = "Conditions",
        column_title = "AIC Genes Expression (n=38)\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

AIC_RUV_HM_flip

```

##AIC Genes RUVs logFC Boxplots
```{r AIC logFC Boxplots RUVs}
#get an overall idea of the logFC of these genes over timepoints

# Read AIC gene list - named AIC_list

AIC_list <- readRDS("data/new/RUV/AIC_genelist_symbolentrez_RUV.RDS")
###this already has both SYMBOL and Entrez_ID###

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV_AIC <- all_toptables_RUV %>%
  filter(Entrez_ID %in% AIC_list$Entrez_ID) %>%
  mutate(abs_logFC = abs(logFC)) %>% 
  dplyr::select(-("X"))

filtered_toptables_RUV_AIC <- filtered_toptables_RUV_AIC %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results_AIC <- filtered_toptables_RUV_AIC %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", ""))

#make a little thing of your timepoint comparisons
pairs_AIC <- wilcox_results_AIC %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint_AIC <- filtered_toptables_RUV_AIC %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions_AIC <- pairs_AIC %>%
  left_join(max_per_timepoint_AIC, by = c("group1" = "Timepoint"))
names(star_positions_AIC)[names(star_positions_AIC) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions_AIC <- star_positions_AIC %>%
  left_join(max_per_timepoint_AIC, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions_AIC)[names(star_positions_AIC) == "max_logFC"] <- "max2"

star_positions_AIC <- star_positions_AIC %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

#I want to leave off the stars for now as they're confusing

wilcox_results_plot_AIC <- wilcox_results_AIC %>%
  left_join(star_positions_AIC, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot_AIC <- wilcox_results_plot_AIC %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot_AIC <- wilcox_results_plot_AIC %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV_AIC, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_AIC, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for AIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV_AIC, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_AIC, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for AIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )


```


#p53 Target Genes logFC Heatmap RUVs Corrected
```{r RUVs p53 Target Genes logFC HM, fig.height=80, fig.width=15}
# Load libraries

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")


#P53 target Entrez_ID
entrez_ids_p53 <- c(1026,50484,4193,9766,9518,7832,1643,1647,1263,57103,51065,8795,51499,64393,581,
                5228,5429,8493,55959,7508,64782,282991,355,53836,4814,10769,9050,27244,9540,94241,
                26154,57763,900,26999,55332,26263,23479,23612,29950,9618,10346,8824,134147,55294,
                22824,4254,6560,467,27113,60492,8444,60401,1969,220965,2232,3976,55191,84284,93129,
                5564,7803,83667,7779,132671,7039,51768,137695,93134,7633,10973,340485,307,27350,
                23245,3732,29965,1363,1435,196513,8507,8061,2517,51278,53354,54858,23228,5366,5912,
                6236,51222,26152,59,1907,50650,91012,780,9249,11072,144455,64787,116151,27165,2876,
                57822,55733,57722,121457,375449,85377,4851,5875,127544,29901,84958,8797,8793,441631,
                220001,54541,5889,5054,25816,25987,5111,98,317,598,604,10904,1294,80315,53944,
                1606,2770,3628,3675,3985,4035,4163,84552,29085,55367,5371,5791,54884,5980,8794,
                1462,50808,220,583,694,1056,9076,10978,54677,1612,55040,114907,2274,127707,4000,
                8079,4646,4747,27445,5143,80055,79156,5360,5364,23654,5565,5613,5625,10076,56963,
                6004,390,255488,6326,6330,23513,7869,283130,204962,83959,6548,6774,9263,10228,
                22954,10475,85363,494514,10142,79714,1006,8446,9648,79828,5507,55240,63874,25841,
                9289,84883,154810,51321,421,8553,655,119032,84280,10950,824,839,57828,857,8812,
                8837,94027,113189,22837,132864,10898,3300,81704,1847,1849,1947,9538,24139,5168,
                147965,115548,9873,23768,2632,2817,3280,3265,23308,3490,51477,182,3856,8844,144811,
                9404,4043,9848,2872,23041,740,343263,4638,26509,4792,22861,57523,55214,80025,164091,
                57060,64065,51090,5453,8496,333926,55671,5900,55544,23179,8601,389,6223,55800,6385,
                4088,6643,122809,257397,285343,7011,54790,374618,55362,51754,7157,9537,22906,7205,
                80705,219699,55245,83719,7748,25946,118738)

# saveRDS(entrez_ids_p53, "data/new/RUV/p53_targetgenes_entrezid.RDS")

# Function to extract relevant data
extract_data_p53_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_p53) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, 
                         as.character(Entrez_ID),
                         column = "SYMBOL", 
                         keytype = "ENTREZID", 
                         multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}


# Collect all data
# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_p53_RUV <- bind_rows(mapply(extract_data_p53_RUV, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) 
#unnecessary to join again as there are not categories on this list of entrezids
# %>%
#   left_join(entrez_ids, by = c("Entrez_ID" = "ENTREZID"))

#make a list of these genes for later analysis
# saveRDS(all_data_p53_RUV, "data/new/RUV/p53_targetgenes_RUV.RDS")

# p53_genes <- all_data_p53_RUV %>% 
#   dplyr::select("SYMBOL", "Entrez_ID")

# saveRDS(p53_genes, "data/new/RUV/p53_genes_symbolentrez.RDS")

# Create matrices
logFC_mat53_RUV <- acast(all_data_p53_RUV, Gene ~ Condition, value.var = "logFC")
signif_mat53_RUV <- acast(all_data_p53_RUV, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_p53_RUV <- logFC_mat53_RUV[, desired_order]
signif_mat_p53_RUV <- signif_mat53_RUV[, desired_order]

# Column annotation
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 3)
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 2)
col_annot_p53_RUV <- HeatmapAnnotation(
  Drug = meta_p53_RUV[, 1],
  Time = meta_p53_RUV[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_p53_RUV,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53_RUV[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

```

Now, I want to convert the above heatmap to only have genes DE at 144R
#p53 HM DEGs D144R
#USE THIS ONE
```{r p53 target genes logFC heatmap D144R, fig.height=10, fig.width=6}

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")


#P53 target Entrez_ID
entrez_ids_p53 <- c(1026,50484,4193,9766,9518,7832,1643,1647,1263,57103,51065,8795,51499,64393,581,
                5228,5429,8493,55959,7508,64782,282991,355,53836,4814,10769,9050,27244,9540,94241,
                26154,57763,900,26999,55332,26263,23479,23612,29950,9618,10346,8824,134147,55294,
                22824,4254,6560,467,27113,60492,8444,60401,1969,220965,2232,3976,55191,84284,93129,
                5564,7803,83667,7779,132671,7039,51768,137695,93134,7633,10973,340485,307,27350,
                23245,3732,29965,1363,1435,196513,8507,8061,2517,51278,53354,54858,23228,5366,5912,
                6236,51222,26152,59,1907,50650,91012,780,9249,11072,144455,64787,116151,27165,2876,
                57822,55733,57722,121457,375449,85377,4851,5875,127544,29901,84958,8797,8793,441631,
                220001,54541,5889,5054,25816,25987,5111,98,317,598,604,10904,1294,80315,53944,
                1606,2770,3628,3675,3985,4035,4163,84552,29085,55367,5371,5791,54884,5980,8794,
                1462,50808,220,583,694,1056,9076,10978,54677,1612,55040,114907,2274,127707,4000,
                8079,4646,4747,27445,5143,80055,79156,5360,5364,23654,5565,5613,5625,10076,56963,
                6004,390,255488,6326,6330,23513,7869,283130,204962,83959,6548,6774,9263,10228,
                22954,10475,85363,494514,10142,79714,1006,8446,9648,79828,5507,55240,63874,25841,
                9289,84883,154810,51321,421,8553,655,119032,84280,10950,824,839,57828,857,8812,
                8837,94027,113189,22837,132864,10898,3300,81704,1847,1849,1947,9538,24139,5168,
                147965,115548,9873,23768,2632,2817,3280,3265,23308,3490,51477,182,3856,8844,144811,
                9404,4043,9848,2872,23041,740,343263,4638,26509,4792,22861,57523,55214,80025,164091,
                57060,64065,51090,5453,8496,333926,55671,5900,55544,23179,8601,389,6223,55800,6385,
                4088,6643,122809,257397,285343,7011,54790,374618,55362,51754,7157,9537,22906,7205,
                80705,219699,55245,83719,7748,25946,118738)

# saveRDS(entrez_ids_p53, "data/new/RUV/p53_targetgenes_entrezid.RDS")

# Function to extract relevant data
extract_data_p53_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_p53) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, 
                         as.character(Entrez_ID),
                         column = "SYMBOL", 
                         keytype = "ENTREZID", 
                         multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}


# Collect all data
# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_p53_RUV <- bind_rows(mapply(extract_data_p53_RUV, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) 

#make a list of these genes for later analysis
# saveRDS(all_data_p53_RUV, "data/new/RUV/p53_targetgenes_RUV.RDS")

# p53_genes <- all_data_p53_RUV %>% 
#   dplyr::select("SYMBOL", "Entrez_ID")

# saveRDS(p53_genes, "data/new/RUV/p53_genes_symbolentrez.RDS")

#now make a filtering step to only include DEGs at 144R
sig_genes_144R <- all_data_p53_RUV %>% 
  dplyr::filter(Condition == "DOX_144R", adj.P.Val < 0.05) %>% 
  pull(Gene) %>% 
  unique()

filt_p53_data_144R <- all_data_p53_RUV %>% 
  dplyr::filter(Gene %in% sig_genes_144R) %>% 
  dplyr::select(-("X"))

# Create matrices
logFC_mat53_RUV <- acast(filt_p53_data_144R, Gene ~ Condition, value.var = "logFC")
signif_mat53_RUV <- acast(filt_p53_data_144R, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_p53_RUV <- logFC_mat53_RUV[, desired_order]
signif_mat_p53_RUV <- signif_mat53_RUV[, desired_order]

# Column annotation
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 3)
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 2)
col_annot_p53_RUV <- HeatmapAnnotation(
  Drug = meta_p53_RUV[, 1],
  Time = meta_p53_RUV[, 2],
  col = list(
    # Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_p53_RUV,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53_RUV[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)


```
#p53 USE THIS
```{r p53 D144R hm}
# library(ComplexHeatmap)
# library(circlize)
# library(grid)
# library(dplyr)
# library(reshape2)
# library(stringr)

# Filter significant genes for 144R
sig_genes_144R <- all_data_p53_RUV %>% 
  filter(Condition == "DOX_144R", adj.P.Val < 0.05) %>% 
  pull(Gene) %>% 
  unique()

filt_p53_data_144R <- all_data_p53_RUV %>% 
  filter(Gene %in% sig_genes_144R) %>% 
  select(-X)

# Create matrices
logFC_mat53_RUV <- acast(filt_p53_data_144R, Gene ~ Condition, value.var = "logFC")
signif_mat53_RUV <- acast(filt_p53_data_144R, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T", "DOX_24R", "DOX_144R")
logFC_mat_p53_RUV <- logFC_mat53_RUV[, desired_order]
signif_mat_p53_RUV <- signif_mat53_RUV[, desired_order]

# Column annotation
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 2)
col_annot_p53_RUV <- HeatmapAnnotation(
  Drug = meta_p53_RUV[, 1],
  Time = meta_p53_RUV[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", "24R" = "#74C476", "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1), "cm")
)

# Define red-white-blue color scale
max_val <- max(abs(logFC_mat_p53_RUV), na.rm = TRUE)
col_fun <- colorRamp2(c(-max_val, 0, max_val), c("blue", "white", "red"))

# Draw heatmap
Heatmap(logFC_mat_p53_RUV,
        name = "logFC",
        col = col_fun,
        top_annotation = col_annot_p53_RUV,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53_RUV[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

```


#USE THIS ONE
```{r DDR target genes logFC heatmap D144R, fig.height=10, fig.width=6}

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")


#target Entrez_ID
entrez_category_DDR <- tribble(
  ~ENTREZID, ~Category,
  317, "Apoptosis", 355, "Apoptosis", 581, "Apoptosis", 637, "Apoptosis",
  836, "Apoptosis", 841, "Apoptosis", 842, "Apoptosis", 27113, "Apoptosis",
  5366, "Apoptosis", 54205, "Apoptosis", 55367, "Apoptosis", 8795, "Apoptosis",
  1026, "Cell Cycle / Checkpoint", 1027, "Cell Cycle / Checkpoint", 595, "Cell Cycle / Checkpoint",
  894, "Cell Cycle / Checkpoint", 896, "Cell Cycle / Checkpoint", 898, "Cell Cycle / Checkpoint",
  9133, "Cell Cycle / Checkpoint", 9134, "Cell Cycle / Checkpoint", 891, "Cell Cycle / Checkpoint",
  983, "Cell Cycle / Checkpoint", 1017, "Cell Cycle / Checkpoint", 1019, "Cell Cycle / Checkpoint",
  1020, "Cell Cycle / Checkpoint", 1021, "Cell Cycle / Checkpoint", 993, "Cell Cycle / Checkpoint",
  995, "Cell Cycle / Checkpoint", 1869, "Cell Cycle / Checkpoint", 4609, "Cell Cycle / Checkpoint",
  5925, "Cell Cycle / Checkpoint", 9874, "Cell Cycle / Checkpoint", 11011, "Cell Cycle / Checkpoint",
  1385, "Cell Cycle / Checkpoint",
  472, "Damage Sensors / Signal Transducers", 545, "Damage Sensors / Signal Transducers",
  5591, "Damage Sensors / Signal Transducers", 5810, "Damage Sensors / Signal Transducers",
  5883, "Damage Sensors / Signal Transducers", 5884, "Damage Sensors / Signal Transducers",
  6118, "Damage Sensors / Signal Transducers", 4361, "Damage Sensors / Signal Transducers",
  10111, "Damage Sensors / Signal Transducers", 4683, "Damage Sensors / Signal Transducers",
  84126, "Damage Sensors / Signal Transducers", 3014, "Damage Sensors / Signal Transducers",
  672, "DNA Repair", 2177, "DNA Repair", 5888, "DNA Repair", 5893, "DNA Repair",
  1647, "DNA Repair", 4616, "DNA Repair", 10912, "DNA Repair", 1111, "DNA Repair",
  11200, "DNA Repair", 1643, "DNA Repair", 8243, "DNA Repair", 5981, "DNA Repair",
  7157, "p53 Regulators / Targets", 4193, "p53 Regulators / Targets", 5371, "p53 Regulators / Targets",
  27244, "p53 Regulators / Targets", 50484, "p53 Regulators / Targets",
  207, "Miscellaneous / Broad", 25, "Miscellaneous / Broad"
)

entrez_ids_DDR_R <- entrez_category_DDR$ENTREZID

# saveRDS(entrez_ids_DDR_R, "data/new/RUV/DDR_genes_entrezid.RDS")

# Function to extract relevant data
extract_data_DDR_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DDR_R) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, 
                         as.character(Entrez_ID),
                         column = "SYMBOL", 
                         keytype = "ENTREZID", 
                         multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}


# Collect all data
# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_DDR_RUV <- bind_rows(mapply(extract_data_DDR_RUV, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) 

#now make a filtering step to only include DEGs at 144R
sig_genes_144R <- all_data_DDR_RUV %>% 
  dplyr::filter(Condition == "DOX_144R", adj.P.Val < 0.05) %>% 
  pull(Gene) %>% 
  unique()

filt_DDR_data_144R <- all_data_DDR_RUV %>% 
  dplyr::filter(Gene %in% sig_genes_144R) %>% 
  dplyr::select(-("X"))

# Create matrices
logFC_mat_DDR_RUV <- acast(filt_DDR_data_144R, Gene ~ Condition, value.var = "logFC")
signif_mat_DDR_RUV <- acast(filt_DDR_data_144R, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DDR_RUV <- logFC_mat_DDR_RUV[, desired_order]
signif_mat_DDR_RUV <- signif_mat_DDR_RUV[, desired_order]

# Column annotation
meta_DDR_RUV <- str_split_fixed(colnames(logFC_mat_DDR_RUV), "_", 3)
meta_DDR_RUV <- str_split_fixed(colnames(logFC_mat_DDR_RUV), "_", 2)
col_annot_DDR_RUV <- HeatmapAnnotation(
  Drug = meta_DDR_RUV[, 1],
  Time = meta_DDR_RUV[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_DDR_RUV,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DDR_RUV[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "DDR Target Genes Expression\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)


```

##p53 logFC boxplots
```{r logFC Boxplots p53 RUVs}

#get an overall idea of the logFC of these genes over timepoints
# library(rstatix)
# Read p53 gene list - named p53_genes

# p53_genes <- readRDS("data/new/RUV/p53_genes_symbolentrez.RDS")
# 
# # Convert gene symbols to Entrez IDs
# p53_targets <- p53_genes %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = SYMBOL,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))
# 
#p53_target_genes <- na.omit(p53_targets$Entrez_ID)

# saveRDS(p53_target_genes, "data/new/RUV/p53_target_genes_symbolentrez.RDS")
#this already has both SYMBOL and Entrez_ID

p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV_p53 <- all_toptables_RUV %>%
  filter(Entrez_ID %in% p53_target_genes) %>%
  mutate(abs_logFC = abs(logFC)) 
  

filtered_toptables_RUV_p53 <- filtered_toptables_RUV_p53 %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results_p53 <- filtered_toptables_RUV_p53 %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", "")) %>% 
  mutate(Conditions = paste(group1, "vs", group2, sep = " "))

#make a little thing of your timepoint comparisons
pairs_p53 <- wilcox_results_p53 %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint_p53 <- filtered_toptables_RUV_p53 %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions_p53 <- pairs_p53 %>%
  left_join(max_per_timepoint_p53, by = c("group1" = "Timepoint"))
names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions_p53 <- star_positions_p53 %>%
  left_join(max_per_timepoint_p53, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max2"

star_positions_p53 <- star_positions_p53 %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

wilcox_results_plot_p53 <- wilcox_results_p53 %>%
  left_join(star_positions_p53, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV_p53, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_p53, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for p53 Target Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV_p53, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_p53, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for p53 Target Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )
```


I am now going to identify the proportion of DDR genes within my timepoints and compare against non-DEGs for all timepoints
#Proportion Barplots of Gene Sets
```{r Proportion Barplot DDR RUVs DEGs vs nonDEGs}

#read in my DDR gene set
DNA_damage <- readRDS("data/new/RUV/DDR_Genes_list_RUV.RDS")
DNA_damage <- as.list(DNA_damage)

#pull out only the unique values that are not NA (there aren't any anyways)
ddr_set <- unique(na.omit(names(DNA_damage)))
#pull out the entrez ids
entrezids_DDR_R <- names(DNA_damage)
#pull out the symbols
gene_symbols_DDR_R <- unname(DNA_damage)
#calculate the total length of my gene set for proportion analysis
total_ddr_genes <- length(ddr_set)
cat("Total DNA damage genes:", total_ddr_genes, "\n")
#should be 65 total genes

#load in DEGs for all timepoints 
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% 
  dplyr::select(-(X))
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% 
  dplyr::select(-(X))
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% 
  dplyr::select(-(X))

# Extract Significant DEGs from these lists
DEGs_24T_R <- DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05]
DEGs_24R_R <- DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05]
DEGs_144R_R <- DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]

#make a list of all of my DEGs
timepoint_DEGs_RUV <- list(
  "24T" = DEGs_24T_R,
  "24R" = DEGs_24R_R,
  "144R" = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)

#fisher's exact test framework
fisher_results_ddr <- purrr::map_dfr(names(timepoint_DEGs_RUV), function(tp_ddr) {
  degs_ddr <- unique(timepoint_DEGs_RUV[[tp_ddr]])
  non_degs_ddr <- setdiff(all_genes, degs_ddr)

  in_deg_ddr     <- sum(degs_ddr %in% ddr_set)
  in_deg_nonddr  <- length(degs_ddr) - in_deg_ddr
  out_deg_ddr    <- sum(non_degs_ddr %in% ddr_set)
  out_deg_nonddr <- length(non_degs_ddr) - out_deg_ddr

  contingency_deg_ddr <- matrix(c(in_deg_ddr, in_deg_nonddr,
                          out_deg_ddr, out_deg_nonddr),
                        nrow = 2, byrow = TRUE)

  test_ddr <- fisher.test(contingency_deg_ddr)
  #print these results
  print(test_ddr)
  
# Print odds ratio and p-value
  cat("Timepoint:", tp_ddr,
      "\n  Odds Ratio:", round(test_ddr$estimate, 3),
      "\n  P-value:", signif(test_ddr$p.value, 4), "\n")

  tibble(
    Timepoint = tp_ddr,
    In_DEG_DDR = in_deg_ddr,
    In_DEG_NonDDR = in_deg_nonddr,
    Out_DEG_DDR = out_deg_ddr,
    Out_DEG_NonDDR = out_deg_nonddr,
    Total_DEGs = length(degs_ddr),
    Proportion_DDR = in_deg_ddr / length(degs_ddr),
    P_Value = test_ddr$p.value,
    Significant = ifelse(test_ddr$p.value < 0.05, "*", "")
  )
})

#configure my results for plotting
time_long_degs_ddr <- fisher_results_ddr %>%
  dplyr::select(Timepoint, In_DEG_DDR, In_DEG_NonDDR, P_Value, Significant) %>%
  pivot_longer(cols = c(In_DEG_DDR, In_DEG_NonDDR),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_DEG_DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Timepoint, FUN = sum)
  )

#set category order (Yes on top)
time_long_degs_ddr$Category <- 
  factor(time_long_degs_ddr$Category, levels = c("Yes", "No"))

#label positions for significance stars
label_positions_degs_ddr <- time_long_degs_ddr %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#plot results in a barplot
ggplot(time_long_degs_ddr, aes(x = Timepoint, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_degs_ddr %>% filter(Significant != ""),
    aes(y = y_pos, label = Significant),
    size = 6,
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DNA Damage Genes in DEGs vs NonDEGs (24T, 24R, 144R)",
    x = "Timepoint",
    y = "Percentage",
    fill = "DNA Damage Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#--- Optional: Print result table ---#
print(fisher_results_ddr)




# ###########################################
# #DDR genes inside each timepoint
# in_24T_DDR <- sum(DEGs_24T_R %in% ddr_set)
# in_24R_DDR <- sum(DEGs_24R_R %in% ddr_set)
# in_144R_DDR <- sum(DEGs_144R_R %in% ddr_set)
# 
# #non-DDR genes inside each motif
# in_24T_nonDDR <- length(DEGs_24T_R) - in_24T_DDR
# in_24R_nonDDR <- length(DEGs_24R_R) - in_24R_DDR
# in_144R_nonDDR <- length(DEGs_144R_R) - in_144R_DDR
# 
# #make contingency tables for fishers exact tests
# contingency_degs_ddr <- matrix(c(
#   in_24T_DDR, in_24T_nonDDR,
#   in_24R_DDR, in_24R_nonDDR,
#   in_144R_DDR, in_144R_nonDDR),
#   nrow = 3, byrow = TRUE
# )
# 
# #print the contingency tables
# print(contingency_degs_ddr)
# 
# #perform a fisher's exact test (small sample size)
# fisher_test_degs_ddr <- fisher.test(contingency_degs_ddr)
# #print fisher's exact test results
# print(fisher_test_degs_ddr)
# 
# #make a summary table of all of these data to plot
# degs_summary_DDR <- tibble(
#   Motif = c("Motif1", "Motif2"),
#   DDR = c(in_motif1_DDR, in_motif2_DDR),
#   non_DDR = c(in_motif1_nonDDR, in_motif2_nonDDR)
# ) %>%
#   pivot_longer(cols = c(DDR, non_DDR), names_to = "Category", values_to = "Count") %>%
#   mutate(
#     Category = ifelse(Category == "DDR", "Yes", "No"),
#     Fraction = Count / ave(Count, Motif, FUN = sum),
#     Significant = ifelse(Category == "Yes" & fisher_test_motifs_DDR$p.value < 0.05, "*", "")
#   )
# 
# #position significance stars just above bars
# label_positions_DDR <- motif_summary_DDR %>%
#   filter(Category == "Yes") %>%
#   mutate(y_pos = Fraction + 1.01)
# 
# #change the ordering so that yes is on the top
# motif_summary_DDR$Category <- factor(motif_summary_DDR$Category, levels = c("Yes", "No"))
# 
# #plot the proportions in a barplot
# ggplot(motif_summary_DDR, aes(x = Motif, y = Fraction, fill = Category)) +
#   geom_bar(stat = "identity", position = "stack") +
#   geom_text(
#     data = label_positions_DDR %>% filter(Significant != ""),
#     aes(x = Motif, y = y_pos, label = Significant),
#     size = 6,
#     color = "black",
#     fontface = "bold"
#   ) +
#   scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
#   scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
#   labs(
#     title = "Proportion of DDR Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
#     x = "Cormotif Motif",
#     y = "Percentage",
#     fill = "DDR Gene"
#   ) +
#   theme_minimal() +
#   theme(
#     axis.title = element_text(size = 14),
#     axis.text = element_text(size = 12),
#     plot.title = element_text(size = 16, hjust = 0.5)
#   )
# 
# 
# #print the proportions and p values
# prop_motif1_DDR <- in_motif1_DDR / length(final_genes_1_RUV)
# prop_motif2_DDR <- in_motif2_DDR / length(final_genes_2_RUV)
# p_val_DDR <- fisher_test_motifs_DDR$p.value
# 
# cat(sprintf("Motif1: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif1_DDR, in_motif1_DDR, length(final_genes_1_RUV)))
# cat(sprintf("Motif2: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif2_DDR, in_motif2_DDR, length(final_genes_2_RUV)))
# cat(sprintf("DDR Fisher's Exact Test p-value: %.5f\n", p_val_DDR))
# cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_DDR$estimate))

```

#Forest Plot DDR
```{r Forest plot of odds ratios DDR}

# Calculate proportions, odds ratios, and Fisher's test results per timepoint
proportion_data_ddr <- purrr::map_dfr(names(timepoint_DEGs_ddr), function(tp_ddr) {
  degs_ddr <- unique(timepoint_DEGs_ddr[[tp_ddr]])
  nondegs_ddr <- setdiff(all_genes, degs_ddr)
  
  in_deg_ddr <- sum(degs_ddr %in% ddr_set)
  in_deg_nonddr <- length(degs_ddr) - in_deg_ddr
  
  in_nondeg_ddr <- sum(nondegs_ddr %in% ddr_set)
  in_nondeg_nonddr <- length(nondegs_ddr) - in_nondeg_ddr
  
  contingency_degs_ddr <- matrix(c(in_deg_ddr, in_deg_nonddr,
                                   in_nondeg_ddr, in_nondeg_nonddr),
                                 nrow = 2, byrow = TRUE)
  
  fisher_res_ddr <- fisher.test(contingency_degs_ddr)
  
  p_val_ddr <- fisher_res_ddr$p.value
  odds_ratio_ddr <- unname(fisher_res_ddr$estimate)
  ci_low_ddr <- fisher_res_ddr$conf.int[1]
  ci_high_ddr <- fisher_res_ddr$conf.int[2]
  
  tibble(
    Timepoint = tp_ddr,
    Odds_Ratio = odds_ratio_ddr,
    CI_low = ci_low_ddr,
    CI_high = ci_high_ddr,
    P_Value = p_val_ddr,
    Significant = p_val_ddr < 0.05
  )
})

# Format Timepoint factor and add significance label/color
proportion_data_ddr <- proportion_data_ddr %>%
  mutate(
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R")),
    Sig_Label = ifelse(Significant, "Significant", "Not Significant")
  )

# Plot horizontal forest plot with color by significance
supp8_forest_ddr_A <- ggplot(proportion_data_ddr, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.3) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "black", "Not Significant" = "pink")) +
  scale_x_log10() +
  labs(
    title = "Odds Ratios of DDR Gene Enrichment by Timepoint",
    y = "Timepoint",
    x = "Odds Ratio (log scale)",
    color = "Significance"
  ) +
  scale_y_discrete(limits = rev(levels(proportion_data_ddr$Timepoint)))+
  theme_custom()

# save_plot( 
#   plot = supp8_forest_ddr_A,
#   filename = "Supp8_ForestDDR_EMP",
#   folder = output_folder,
#   height = 4,
#   width = 6)


```


```{r Forest plot backwards DDR}

# library(forcats)

# =====================
# Load DDR gene set
# =====================
DNA_damage <- readRDS("data/new/RUV/DDR_Genes_list_RUV.RDS")
entrezids_DDR_R <- unlist(names(DNA_damage))
gene_symbols_DDR_R <- unname(DNA_damage)
total_ddr_genes <- length(entrezids_DDR_R)
cat("Total DDR genes:", total_ddr_genes, "\n")

# =====================
# Load DEGs for each timepoint
# =====================
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% dplyr::select(-X)
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% dplyr::select(-X)
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% dplyr::select(-X)

timepoint_DEGs_RUV <- list(
  "24T" = DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05],
  "24R" = DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05],
  "144R" = DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]
)

# =====================
# Build DDR dataframe
# =====================
DDR_df <- map_dfr(names(timepoint_DEGs_RUV), function(tp) {
  degs <- timepoint_DEGs_RUV[[tp]]
  data.frame(
    Entrez_ID = entrezids_DDR_R,
    DEG_status = ifelse(entrezids_DDR_R %in% degs, "DEG", "non-DEG"),
    timepoint = tp
  )
}) %>% mutate(timepoint = factor(timepoint, levels = c("24T", "24R", "144R")))

# Count and compute proportions
prop_df <- DDR_df %>%
  dplyr::count(timepoint, DEG_status) %>%
  tidyr::complete(timepoint = factor(levels = c("24T", "24R", "144R")),
                  DEG_status = c("DEG", "non-DEG"),
                  fill = list(n = 0)) %>%
  dplyr::mutate(prop = n / total_ddr_genes * 100)

# =====================
# Stacked bar plot with annotations
# =====================
# stacked_bar_plot <- ggplot(prop_df, aes(x = timepoint, y = prop, fill = DEG_status)) +
#   geom_bar(stat = "identity", position = "stack", color = "black") +
#   geom_text(aes(label = n), 
#             position = position_stack(vjust = 0.5), 
#             size = 5, color = "white") +
#   scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
#   scale_fill_manual(values = c("DEG" = "red", "non-DEG" = "grey")) +
#   labs(
#     x = "Timepoint",
#     y = "Proportion of DDR Genes (%)",
#     title = "Proportion of DDR Genes that are DEGs vs non-DEGs",
#     fill = "Status"
#   ) +
#   theme_minimal(base_size = 14)
# 
# print(stacked_bar_plot)

# =====================
# Fisher's exact test and forest plot per timepoint
# =====================
forest_df <- map_dfr(names(timepoint_DEGs_RUV), function(tp) {
  degs <- timepoint_DEGs_RUV[[tp]]
  
  # contingency table for DDR vs non-DDR genes
  DEG_in_DDR <- sum(entrezids_DDR_R %in% degs)
  DEG_not_DDR <- length(degs) - DEG_in_DDR
  nonDEG_in_DDR <- total_ddr_genes - DEG_in_DDR
  nonDEG_not_DDR <- (length(unique(c(DOX_24T_R$Entrez_ID,
                                     DOX_24R_R$Entrez_ID,
                                     DOX_144R_R$Entrez_ID))) - total_ddr_genes) - DEG_not_DDR
  
  mat <- matrix(c(DEG_in_DDR, DEG_not_DDR, nonDEG_in_DDR, nonDEG_not_DDR),
                nrow = 2, byrow = TRUE)
  rownames(mat) <- c("DDR", "non-DDR")
  colnames(mat) <- c("DEG", "non-DEG")
  
  test <- fisher.test(mat)
  
  tibble(
    timepoint = tp,
    odds_ratio = as.numeric(test$estimate),
    conf_low = test$conf.int[1],
    conf_high = test$conf.int[2],
    p_value = test$p.value,
    sig = ifelse(test$p.value < 0.05, "sig", "ns")
  )
})

forest_df$timepoint <- factor(forest_df$timepoint, levels = c("24T", "24R", "144R"))

forest_plot <- ggplot(forest_df, aes(x = odds_ratio, y = forcats::fct_rev(timepoint),
                                     xmin = conf_low, xmax = conf_high,
                                     color = sig)) +
  geom_pointrange(size = 1) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
  scale_x_log10() +
  scale_color_manual(values = c("sig" = "red", "ns" = "grey")) +
  labs(
    x = "Odds Ratio (log scale)",
    y = "Timepoint",
    title = "DDR Gene Enrichment in DEGs per Timepoint"
  ) +
  theme_minimal(base_size = 14)

print(forest_plot)


```



#Forest Plot of Odds Ratios DDR
```{r Forest Plot of DDR Odds Ratios}

# Calculate proportions, odds ratios, and Fisher's test results per timepoint
proportion_data_ddr <- purrr::map_dfr(names(timepoint_DEGs_ddr), function(tp_ddr) {
  degs_ddr <- unique(timepoint_DEGs_ddr[[tp_ddr]])
  nondegs_ddr <- setdiff(all_genes, degs_ddr)
  
  in_deg_ddr <- sum(degs_ddr %in% ddr_set)
  in_deg_nonddr <- length(degs_ddr) - in_deg_ddr
  
  in_nondeg_ddr <- sum(nondegs_ddr %in% ddr_set)
  in_nondeg_nonddr <- length(nondegs_ddr) - in_nondeg_ddr
  
  contingency_degs_ddr <- matrix(c(in_deg_ddr, in_deg_nonddr,
                                   in_nondeg_ddr, in_nondeg_nonddr),
                                 nrow = 2, byrow = TRUE)
  
  fisher_res_ddr <- fisher.test(contingency_degs_ddr)
  
  p_val_ddr <- fisher_res_ddr$p.value
  odds_ratio_ddr <- unname(fisher_res_ddr$estimate)
  ci_low_ddr <- fisher_res_ddr$conf.int[1]
  ci_high_ddr <- fisher_res_ddr$conf.int[2]
  
  tibble(
    Timepoint = tp_ddr,
    Odds_Ratio = odds_ratio_ddr,
    CI_low = ci_low_ddr,
    CI_high = ci_high_ddr,
    P_Value = p_val_ddr,
    Significant = p_val_ddr < 0.05
  )
})

#adjust p value for multiple testing correction BH
proportion_data_ddr <- proportion_data_ddr %>%
  mutate(
    Adj_P_Value = p.adjust(P_Value, method = "BH"),
    Significant = Adj_P_Value < 0.05,
    Sig_Label = ifelse(Significant, "Significant", "Not Significant"),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"))
  )

# Plot horizontal forest plot with color by significance
ggplot(proportion_data_ddr, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.2) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "#e41a1c", "Not Significant" = "gray40")) +
  labs(
    title = "Odds Ratios of ddr Gene Enrichment in DEGs vs nonDEGs by Timepoint",
    y = "Timepoint",
    x = "Odds Ratio (95% CI)",
    color = "Adj. P. Value") +
  scale_y_discrete(limits = rev(levels(proportion_data_ddr$Timepoint))) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "top"
  )


```

```{r Forest Plot DDR genes Backwards}
#try this the opposite direction:
#are DDR genes more likely to be DEGs at different timepoints?

# background: all genes tested = all_genes
# DDR gene set: ddr_set
# DEGs per timepoint: DEGs_24T_R, DEGs_24R_R, DEGs_144R_R

# For each timepoint:
# Count how many ddr genes are DEGs and how many are non-DEGs
# Count how many Non-ddr genes are DEGs and how many are non-DEGs

proportion_data_ddr_backward <- purrr::map_dfr(names(timepoint_DEGs_ddr), function(tp) {
  degs_ddr <- unique(timepoint_DEGs_ddr[[tp]])
  nondegs_ddr <- setdiff(all_genes, degs_ddr)
  
  # DDR genes that are DEGs/non-DEGs
  ddr_deg <- sum(ddr_set %in% degs_ddr)
  ddr_non_deg <- sum(ddr_set %in% nondegs_ddr)
  
  # Non-DDR genes that are DEGs/non-DEGs
  non_ddr_set <- setdiff(all_genes, ddr_set)
  non_ddr_deg <- sum(non_ddr_set %in% degs_ddr)
  non_ddr_non_deg <- sum(non_ddr_set %in% nondegs_ddr)
  
  # Contingency table for Fisher's test
  contingency_ddr <- matrix(c(ddr_deg, ddr_non_deg,
                          non_ddr_deg, non_ddr_non_deg),
                        nrow = 2, byrow = TRUE)
  
  fisher_res_ddr <- fisher.test(contingency_ddr)
  
  tibble(
    Timepoint = tp,
    ddr_DEGs = ddr_deg,
    ddr_nonDEGs = ddr_non_deg,
    Nonddr_DEGs = non_ddr_deg,
    Nonddr_nonDEGs = non_ddr_non_deg,
    Odds_Ratio = unname(fisher_res_ddr$estimate),
    CI_low = fisher_res_ddr$conf.int[1],
    CI_high = fisher_res_ddr$conf.int[2],
    P_Value = fisher_res_ddr$p.value
  )
})

# Adjust p-values for multiple testing
proportion_data_ddr_backward <- proportion_data_ddr_backward %>%
  mutate(
    Adj_P_Value = p.adjust(P_Value, method = "BH"),
    Significant = Adj_P_Value < 0.05,
    Sig_Label = ifelse(Significant, "Significant", "Not Significant"),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"))
  )

# Plotting forest plot (like before)
ggplot(proportion_data_ddr_backward, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.2) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "#e41a1c", "Not Significant" = "gray40")) +
  scale_y_discrete(limits = rev(c("24T", "24R", "144R"))) +  #make sure in order
  labs(
    title = "Odds Ratios for DEGs Proportion Within ddr Gene Set",
    y = "Timepoint",
    x = "Odds Ratio (95% CI)",
    color = "Adj. P. Value"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "top"
  )

```

```{r Forest Plot DDR Other}
# library(broom)

# Calculate odds ratio and fisher test per timepoint for DDR gene set
ddr_results <- purrr::map_dfr(names(timepoint_DEGs_ddr), function(tp) {
  degs <- unique(timepoint_DEGs_ddr[[tp]])
  
  # Construct 2x2 contingency: DDR genes (DEGs vs non-DEGs)
  ddr_deg_count <- sum(ddr_set %in% degs)
  ddr_non_deg_count <- length(ddr_set) - ddr_deg_count
  
  # For background: non-DDR genes (DEGs vs non-DEGs)
  non_ddr_genes <- setdiff(all_genes, ddr_set)
  non_ddr_deg_count <- sum(non_ddr_genes %in% degs)
  non_ddr_non_deg_count <- length(non_ddr_genes) - non_ddr_deg_count
  
  contingency_table <- matrix(c(ddr_deg_count, ddr_non_deg_count,
                                non_ddr_deg_count, non_ddr_non_deg_count),
                              nrow = 2, byrow = TRUE)
  
  fisher_res <- fisher.test(contingency_table)
  tidy_res <- broom::tidy(fisher_res)
  
  tibble(
    Timepoint = tp,
    DDR_DEGs = ddr_deg_count,
    DDR_nonDEGs = ddr_non_deg_count,
    NonDDR_DEGs = non_ddr_deg_count,
    NonDDR_nonDEGs = non_ddr_non_deg_count,
    Odds_Ratio = tidy_res$estimate,
    CI_low = tidy_res$conf.low,
    CI_high = tidy_res$conf.high,
    P_Value = tidy_res$p.value
  )
}) %>%
  mutate(
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R")),
    Adj_P_Value = p.adjust(P_Value, method = "BH"),
    Sig_Label = ifelse(Adj_P_Value < 0.05, "Significant", "Not Significant")
  )

# Forest plot of odds ratios with significance coloring
forest_plot <- ggplot(ddr_results, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.25, size = 1) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "#e41a1c", "Not Significant" = "gray50")) +
  scale_y_discrete(limits = rev(levels(ddr_results$Timepoint))) +
  labs(
    title = "Odds Ratio of DEGs Enrichment Within DDR Genes by Timepoint",
    y = "Timepoint",
    x = "Odds Ratio (95% Confidence Interval)",
    color = "Significance (BH adj p-value)"
  ) +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(hjust = 0.5), legend.position = "top")

print(forest_plot)

# --- Optional pairwise test for difference in proportions of DDR genes as DEGs across timepoints ---
# Uncomment to run this block
# {
#   prop_test_df <- ddr_results %>%
#     select(Timepoint, DDR_DEGs, DDR_nonDEGs) %>%
#     mutate(Total = DDR_DEGs + DDR_nonDEGs)
# 
#   pairwise_results <- pairwise.prop.test(
#     x = prop_test_df$DDR_DEGs,
#     n = prop_test_df$Total,
#     p.adjust.method = "BH"
#   )
#   print(pairwise_results)
# }

```


```{r Proportion Barplot DEGs vs nonDEGs, fig.height=6, fig.width=10}
# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - ddr_set: vector of DNA damage response gene Entrez IDs

#read in my DDR gene set
DNA_damage <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/DDR_genes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
ddr_set <- unique(na.omit(DNA_damage))
#pull out the entrez ids
entrezids_DDR_R <- unname(DNA_damage)
#calculate the total length of my gene set for proportion analysis
total_ddr_genes <- length(ddr_set)
cat("Total DNA damage genes:", total_ddr_genes, "\n")
#should be 65 total genes

#DEGs list
timepoint_DEGs_ddr <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)


#collect results into a data frame
proportion_data_ddr <- purrr::map_dfr(names(timepoint_DEGs_ddr), function(tp_ddr) {
  degs_ddr <- unique(timepoint_DEGs_ddr[[tp_ddr]])
  nondegs_ddr <- setdiff(all_genes, degs_ddr)
  
  in_deg_ddr <- sum(degs_ddr %in% ddr_set)
  in_deg_nonddr <- length(degs_ddr) - in_deg_ddr
  in_deg_total <- length(degs_ddr)
  
  in_nondeg_ddr <- sum(nondegs_ddr %in% ddr_set)
  in_nondeg_nonddr <- length(nondegs_ddr) - in_nondeg_ddr
  in_nondeg_total <- length(nondegs_ddr)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_ddr <- matrix(c(in_deg_ddr, in_deg_nonddr,
                          in_nondeg_ddr, in_nondeg_nonddr),
                        nrow = 2, byrow = TRUE)

  fisher_res_ddr <- fisher.test(contingency_degs_ddr)
  odds_ddr <- as.numeric(fisher_res_ddr$estimate)
  p_val_ddr <- fisher_res_ddr$p.value
  sig_ddr <- ifelse(p_val_ddr < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_ddr)
  
    # Print odds ratio + p-value
  cat("Timepoint:", tp_ddr,
      "\n  Odds Ratio:", round(odds_ddr, 3),
      "\n  P-value:", signif(p_val_ddr, 4), "\n")
  
tibble(
  Timepoint = rep(tp_ddr, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_ddr, in_deg_nonddr, in_nondeg_ddr, in_nondeg_nonddr),
  Total = c(length(degs_ddr), length(degs_ddr), length(nondegs_ddr), length(nondegs_ddr)),
  Odds_Ratio = rep(odds_ddr, 4),
  P_Value = rep(p_val_ddr, 4),
  Significant = ifelse(c("Yes", "No", "Yes", "No") == "Yes", sig_ddr, "")
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels only on sig
label_positions_ddr <- proportion_data_ddr %>%
  filter(Category == "Yes" & Significant != "") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_ddr$Category <- factor(proportion_data_ddr$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_ddr, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_ddr,
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DDR Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

```

##Proportion Barplot DIC Genes
```{r DIC Proportion Barplot DEGs vs nonDEGs, fig.height=6, fig.width=10}

# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - ddr_set: vector of DNA damage response gene Entrez IDs

#read in my DIC gene set
DIC_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
dic_set <- unique(na.omit(DIC_genes))
#pull out the entrez ids
entrezids_dic <- unname(DIC_genes)
#calculate the total length of my gene set for proportion analysis
total_dic_genes <- length(dic_set)
cat("Total DIC genes:", total_dic_genes, "\n")
#should be 27 total genes

#DEGs list
timepoint_DEGs_dic <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)


#collect results into a data frame
proportion_data_dic <- purrr::map_dfr(names(timepoint_DEGs_dic), function(tp_dic) {
  degs_dic <- unique(timepoint_DEGs_dic[[tp_dic]])
  nondegs_dic <- setdiff(all_genes, degs_dic)
  
  in_deg_dic <- sum(degs_dic %in% dic_set)
  in_deg_nondic <- length(degs_dic) - in_deg_dic
  in_deg_total <- length(degs_dic)
  
  in_nondeg_dic <- sum(nondegs_dic %in% dic_set)
  in_nondeg_nondic <- length(nondegs_dic) - in_nondeg_dic
  in_nondeg_total <- length(nondegs_dic)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_dic <- matrix(c(in_deg_dic, in_deg_nondic,
                          in_nondeg_dic, in_nondeg_nondic),
                        nrow = 2, byrow = TRUE)

  fisher_res_dic <- fisher.test(contingency_degs_dic)
  p_val_dic <- fisher_res_dic$p.value
  sig_dic <- ifelse(p_val_dic < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_dic)
  
tibble(
  Timepoint = rep(tp_dic, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_dic, in_deg_nondic, in_nondeg_dic, in_nondeg_nondic),
  Total = c(length(degs_dic), length(degs_dic), length(nondegs_dic), length(nondegs_dic)),
  P_Value = rep(p_val_dic, 4),
  Significant = rep(sig_dic, 4)
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels
label_positions_dic <- proportion_data_dic %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_dic$Category <- factor(proportion_data_dic$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_dic, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic %>% filter(Significant != ""),
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DIC Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

```
#Forest Plot of Odds Ratios DIC
```{r Forest Plot of DIC Odds Ratios}

# Calculate proportions, odds ratios, and Fisher's test results per timepoint
proportion_data_dic <- purrr::map_dfr(names(timepoint_DEGs_dic), function(tp_dic) {
  degs_dic <- unique(timepoint_DEGs_dic[[tp_dic]])
  nondegs_dic <- setdiff(all_genes, degs_dic)
  
  in_deg_dic <- sum(degs_dic %in% dic_set)
  in_deg_nondic <- length(degs_dic) - in_deg_dic
  
  in_nondeg_dic <- sum(nondegs_dic %in% dic_set)
  in_nondeg_nondic <- length(nondegs_dic) - in_nondeg_dic
  
  contingency_degs_dic <- matrix(c(in_deg_dic, in_deg_nondic,
                                   in_nondeg_dic, in_nondeg_nondic),
                                 nrow = 2, byrow = TRUE)
  
  fisher_res_dic <- fisher.test(contingency_degs_dic)
  
  p_val_dic <- fisher_res_dic$p.value
  odds_ratio_dic <- unname(fisher_res_dic$estimate)
  ci_low_dic <- fisher_res_dic$conf.int[1]
  ci_high_dic <- fisher_res_dic$conf.int[2]
  
  tibble(
    Timepoint = tp_dic,
    Odds_Ratio = odds_ratio_dic,
    CI_low = ci_low_dic,
    CI_high = ci_high_dic,
    P_Value = p_val_dic,
    Significant = p_val_dic < 0.05
  )
})

#adjust p value for multiple testing correction BH
proportion_data_dic <- proportion_data_dic %>%
  mutate(
    Adj_P_Value = p.adjust(P_Value, method = "BH"),
    Significant = Adj_P_Value < 0.05,
    Sig_Label = ifelse(Significant, "Significant", "Not Significant"),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"))
  )

# Plot horizontal forest plot with color by significance
ggplot(proportion_data_dic, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.2) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "#e41a1c", "Not Significant" = "gray40")) +
  labs(
    title = "Odds Ratios of DIC Gene Enrichment in DEGs vs nonDEGs by Timepoint",
    y = "Timepoint",
    x = "Odds Ratio (95% CI)",
    color = "Adj. P. Value") +
  scale_y_discrete(limits = rev(levels(proportion_data_dic$Timepoint))) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "top"
  )


```

```{r Forest Plot DIC genes Backwards}
#try this the opposite direction:
#are DDR genes more likely to be DEGs at different timepoints?

# background: all genes tested = all_genes
# DDR gene set: ddr_set
# DEGs per timepoint: DEGs_24T_R, DEGs_24R_R, DEGs_144R_R

# For each timepoint:
# Count how many DIC genes are DEGs and how many are non-DEGs
# Count how many Non-DIC genes are DEGs and how many are non-DEGs

proportion_data_dic_backward <- purrr::map_dfr(names(timepoint_DEGs_dic), function(tp) {
  degs_dic <- unique(timepoint_DEGs_dic[[tp]])
  nondegs_dic <- setdiff(all_genes, degs_dic)
  
  # DDR genes that are DEGs/non-DEGs
  dic_deg <- sum(dic_set %in% degs_dic)
  dic_non_deg <- sum(dic_set %in% nondegs_dic)
  
  # Non-DDR genes that are DEGs/non-DEGs
  non_dic_set <- setdiff(all_genes, dic_set)
  non_dic_deg <- sum(non_dic_set %in% degs_dic)
  non_dic_non_deg <- sum(non_dic_set %in% nondegs_dic)
  
  # Contingency table for Fisher's test
  contingency_dic <- matrix(c(dic_deg, dic_non_deg,
                          non_dic_deg, non_dic_non_deg),
                        nrow = 2, byrow = TRUE)
  
  fisher_res_dic <- fisher.test(contingency_dic)
  
  tibble(
    Timepoint = tp,
    DIC_DEGs = dic_deg,
    DIC_nonDEGs = dic_non_deg,
    NonDIC_DEGs = non_dic_deg,
    NonDIC_nonDEGs = non_dic_non_deg,
    Odds_Ratio = unname(fisher_res_dic$estimate),
    CI_low = fisher_res_dic$conf.int[1],
    CI_high = fisher_res_dic$conf.int[2],
    P_Value = fisher_res_dic$p.value
  )
})

# Adjust p-values for multiple testing
proportion_data_dic_backward <- proportion_data_dic_backward %>%
  mutate(
    Adj_P_Value = p.adjust(P_Value, method = "BH"),
    Significant = Adj_P_Value < 0.05,
    Sig_Label = ifelse(Significant, "Significant", "Not Significant"),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"))
  )

# Plotting forest plot (like before)
ggplot(proportion_data_dic_backward, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.2) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "#e41a1c", "Not Significant" = "gray40")) +
  scale_y_discrete(limits = rev(c("24T", "24R", "144R"))) +  #make sure in order
  labs(
    title = "Odds Ratios for DEGs Proportion Within DIC Gene Set",
    y = "Timepoint",
    x = "Odds Ratio (95% CI)",
    color = "Adj. P. Value"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "top"
  )

```

```{r DIC logFC Line Plot}
#I want to plot all of the DIC genes on this line plot

#read in my DIC gene set
DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

dic_set <- unique(na.omit(DOX_cardiotox_genes))

#create a toptable with all of the genes for DIC
filt_toptable_dic_RUV <- combined_toptables_dxr_RUV %>% 
  mutate(DIC = case_when(
    Entrez_ID %in% dic_set ~ "DIC",
    TRUE ~ NA_character_
  )) %>% 
  dplyr::filter(!is.na(SYMBOL)) %>% 
  dplyr::filter(!is.na(DIC)) %>% 
  mutate(time = factor(Time, 
                       levels = c("24T", "24R", "144R"))) %>% 
  mutate(absFC = abs(logFC))

#calculate medians for ALL DIC genes across timepoints
medians_dic_RUV <- filt_toptable_dic_RUV %>%
  group_by(time) %>%
  summarise(
    median_logFC = median(logFC),
    median_abslogFC = median(absFC),
    .groups = "drop"
  )

#label with median values
labs_logFC_dic <- paste0(
  "DIC\nmedian logFC =\n",
  paste0(medians_dic_RUV$time, "=", round(medians_dic_RUV$median_logFC, 2), collapse = "\n")
)

#sdd a column that labels positive/negative direction
filt_toptable_dic_RUV <- filt_toptable_dic_RUV %>%
  mutate(direction = ifelse(logFC >= 0, "up", "down"))

#label direction
medians_dic_RUV <- medians_dic_RUV %>%
  mutate(direction = "median")

plot_dic_logFC <- ggplot() +
  geom_line(data = filt_toptable_dic_RUV,
            aes(x = time, 
                y = logFC, 
                group = Entrez_ID, 
                color = direction),
            alpha = 0.4, 
            linewidth = 0.9) +
  geom_line(data = medians_dic_RUV,
            aes(x = time, 
                y = median_logFC, 
                group = 1, 
                color = direction),
            linewidth = 2, 
            linetype = 1) +
  scale_color_manual(
    breaks = c("up", "down", "median"), 
    values = c("up" = "#5A8CA9", 
               "down" = "#E07B91", 
               "median" = "#3D6680"),
    labels = c(
      up = "Generally up-regulated",
      down = "Generally down-regulated",
      median = labs_logFC_dic
    ),
    name = NULL
  ) +
  labs(title = "logFC  DIC Genes (n = 27)",
       y = "logFC", x = "Time") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right")

plot_dic_logFC


#####AIC Version#####
#read in my DIC gene set


aic_set

#create a toptable with all of the genes for DIC
filt_toptable_aic_RUV <- combined_toptables_dxr_RUV %>% 
  mutate(AIC = case_when(
    Entrez_ID %in% aic_set ~ "AIC",
    TRUE ~ NA_character_
  )) %>% 
  dplyr::filter(!is.na(SYMBOL)) %>% 
  dplyr::filter(!is.na(AIC)) %>% 
  mutate(time = factor(Time, 
                       levels = c("24T", "24R", "144R"))) %>% 
  mutate(absFC = abs(logFC))

#calculate medians for ALL DIC genes across timepoints
medians_aic_RUV <- filt_toptable_aic_RUV %>%
  group_by(time) %>%
  summarise(
    median_logFC = median(logFC),
    median_abslogFC = median(absFC),
    .groups = "drop"
  )

#label with median values
labs_logFC_aic <- paste0(
  "AIC\nmedian logFC =\n",
  paste0(medians_aic_RUV$time, "=", round(medians_aic_RUV$median_logFC, 2), collapse = "\n")
)

#sdd a column that labels positive/negative direction
filt_toptable_aic_RUV <- filt_toptable_aic_RUV %>%
  mutate(direction = ifelse(logFC >= 0, "up", "down"))

#label direction
medians_aic_RUV <- medians_aic_RUV %>%
  mutate(direction = "median")

plot_aic_logFC <- ggplot() +
  geom_line(data = filt_toptable_aic_RUV,
            aes(x = time, 
                y = logFC, 
                group = Entrez_ID, 
                color = direction),
            alpha = 0.4, 
            linewidth = 0.9) +
  geom_line(data = medians_aic_RUV,
            aes(x = time, 
                y = median_logFC, 
                group = 1, 
                color = direction),
            linewidth = 2, 
            linetype = 1) +
  scale_color_manual(
    breaks = c("up", "down", "median"), 
    values = c("up" = "#5A8CA9", 
               "down" = "#E07B91", 
               "median" = "#3D6680"),
    labels = c(
      up = "Generally up-regulated",
      down = "Generally down-regulated",
      median = labs_logFC_aic
    ),
    name = NULL
  ) +
  labs(title = "logFC  AIC Genes (n = 38)",
       y = "logFC", x = "Time") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right")

plot_aic_logFC

```


##AIC DEGs Proportion Barplots
```{r AIC Proportion Barplots, fig.height=6, fig.width=10}
# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - aic_set: vector of AIC gene Entrez IDs

# AIC_entrez <- AIC_genelist_symbolentrez_RUV$Entrez_ID
# saveRDS(AIC_entrez, "data/new/RUV/AIC_genes_entrezid.RDS")

#read in my AIC gene set
AIC_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
AIC_set <- unique(na.omit(AIC_genes))
#pull out the entrez ids
entrezids_AIC <- unname(AIC_set)
#calculate the total length of my gene set for proportion analysis
total_AIC_genes <- length(AIC_set)
cat("Total AIC Target genes:", total_AIC_genes, "\n")
#should be 38 total genes

#DEGs list
timepoint_DEGs_AIC <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)


#collect results into a data frame
proportion_data_AIC <- purrr::map_dfr(names(timepoint_DEGs_AIC), function(tp_AIC) {
  degs_AIC <- unique(timepoint_DEGs_AIC[[tp_AIC]])
  nondegs_AIC <- setdiff(all_genes, degs_AIC)
  
  in_deg_AIC <- sum(degs_AIC %in% AIC_set)
  in_deg_nonAIC <- length(degs_AIC) - in_deg_AIC
  in_deg_total <- length(degs_AIC)
  
  in_nondeg_AIC <- sum(nondegs_AIC %in% AIC_set)
  in_nondeg_nonAIC <- length(nondegs_AIC) - in_nondeg_AIC
  in_nondeg_total <- length(nondegs_AIC)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_AIC <- matrix(c(in_deg_AIC, in_deg_nonAIC,
                          in_nondeg_AIC, in_nondeg_nonAIC),
                        nrow = 2, byrow = TRUE)

  fisher_res_AIC <- fisher.test(contingency_degs_AIC)
  p_val_AIC <- fisher_res_AIC$p.value
  sig_AIC <- ifelse(p_val_AIC < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_AIC)
  
tibble(
  Timepoint = rep(tp_AIC, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_AIC, in_deg_nonAIC, in_nondeg_AIC, in_nondeg_nonAIC),
  Total = c(length(degs_AIC), length(degs_AIC), length(nondegs_AIC), length(nondegs_AIC)),
  P_Value = rep(p_val_AIC, 4),
  Significant = rep(sig_AIC, 4)
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels
label_positions_AIC <- proportion_data_AIC %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_AIC$Category <- factor(proportion_data_AIC$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_AIC, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_AIC %>% filter(Significant != ""),
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of AIC Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "AIC Gene"
  ) +
   theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )
```


```{r AIC Line Plot}
#I want to plot all of the AIC genes on this line plot

#read in my AIC gene set
AIC_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS")

aic_set <- unique(na.omit(AIC_genes))

#create a toptable with all of the genes for AIC
filt_toptable_aic_RUV <- combined_toptables_dxr_RUV %>% 
  mutate(AIC = case_when(
    Entrez_ID %in% aic_set ~ "AIC",
    TRUE ~ NA_character_
  )) %>% 
  dplyr::filter(!is.na(SYMBOL)) %>% 
  dplyr::filter(!is.na(AIC)) %>% 
  mutate(time = factor(Time, 
                       levels = c("24T", "24R", "144R"))) %>% 
  mutate(absFC = abs(logFC))

#calculate medians for ALL AIC genes across timepoints
medians_aic_RUV <- filt_toptable_aic_RUV %>%
  group_by(time) %>%
  summarise(
    median_logFC = median(logFC),
    median_abslogFC = median(absFC),
    .groups = "drop"
  )

#label with median values
labs_logFC_aic <- paste0(
  "AIC\nmedian logFC =\n",
  paste0(medians_aic_RUV$time, "=", round(medians_aic_RUV$median_logFC, 2), collapse = "\n")
)

# #sdd a column that labels positive/negative direction
# filt_toptable_aic_RUV <- filt_toptable_aic_RUV %>%
#   mutate(direction = ifelse(logFC >= 0, "up", "down"))

#label direction
medians_aic_RUV <- medians_aic_RUV %>%
  mutate(direction = "median")



plot_aic_logFC <- ggplot() +
  geom_line(data = filt_toptable_aic_RUV,
            aes(x = time, 
                y = logFC, 
                group = Entrez_ID,
            alpha = 0.4, 
            linewidth = 0.9)) +
  geom_line(data = medians_aic_RUV,
            aes(x = time, 
                y = median_logFC, 
                group = 1,
            linewidth = 2, 
            linetype = "solid")) +
  scale_color_manual(
    breaks = c("median"), 
    values = c("median" = "#3D6680"),
    labels = c(
      median = labs_logFC_aic
    )) +
  labs(title = "logFC  AIC Genes (n = 38)",
       y = "logFC", x = "Time") +
  theme_bw(base_size = 14) +
  theme(legend.position = "right")

plot_aic_logFC

#find how many genes are up and how many are down
aic_directionality <- filt_toptable_dic_RUV %>%
  group_by(time, direction) %>%
  summarise(n = n(), .groups = "drop")

```


##Proportion Barplots p53 DEGs
```{r p53 Proportion Barplots DEGs vs nonDEGs, fig.height=6, fig.width=10}

# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - p53_set: vector of DNA damage response gene Entrez IDs

#read in my gene set
p53_target_genes <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/p53_targetgenes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
p53_set <- unique(na.omit(p53_target_genes))
#pull out the entrez ids
entrezids_p53 <- unname(p53_set)
#calculate the total length of my gene set for proportion analysis
total_p53_genes <- length(p53_set)
cat("Total p53 Target genes:", total_p53_genes, "\n")
#should be 300 total genes

#DEGs list
timepoint_DEGs_p53 <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)
# saveRDS(all_genes, "data/new/RUV/all_genes_background.RDS")

#collect results into a data frame
proportion_data_p53 <- purrr::map_dfr(names(timepoint_DEGs_p53), function(tp_p53) {
  degs_p53 <- unique(timepoint_DEGs_p53[[tp_p53]])
  nondegs_p53 <- setdiff(all_genes, degs_p53)
  
  in_deg_p53 <- sum(degs_p53 %in% p53_set)
  in_deg_nonp53 <- length(degs_p53) - in_deg_p53
  in_deg_total <- length(degs_p53)
  
  in_nondeg_p53 <- sum(nondegs_p53 %in% p53_set)
  in_nondeg_nonp53 <- length(nondegs_p53) - in_nondeg_p53
  in_nondeg_total <- length(nondegs_p53)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_p53 <- matrix(c(in_deg_p53, in_deg_nonp53,
                          in_nondeg_p53, in_nondeg_nonp53),
                        nrow = 2, byrow = TRUE)

  fisher_res_p53 <- fisher.test(contingency_degs_p53)
  p_val_p53 <- fisher_res_p53$p.value
  sig_p53 <- ifelse(p_val_p53 < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_p53)
  
tibble(
  Timepoint = rep(tp_p53, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_p53, in_deg_nonp53, in_nondeg_p53, in_nondeg_nonp53),
  Total = c(length(degs_p53), length(degs_p53), length(nondegs_p53), length(nondegs_p53)),
  P_Value = rep(p_val_p53, 4),
  Significant = rep(sig_p53, 4)
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels
label_positions_p53 <- proportion_data_p53 %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_p53$Category <- factor(proportion_data_p53$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_p53, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53 %>% filter(Significant != ""),
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of p53 Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

proportion_data_p53 <- proportion_data_p53 %>%
  mutate(
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R")),
    Sig_Label = ifelse(Significant, "Significant", "Not Significant")
  )


supp8_forest_p53_B <- ggplot(proportion_data_p53, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.3) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "black", "Not Significant" = "pink")) +
  scale_x_log10() +
  labs(
    title = "Odds Ratios of DDR Gene Enrichment by Timepoint",
    y = "Timepoint",
    x = "Odds Ratio (log scale)",
    color = "Significance"
  ) +
  scale_y_discrete(limits = rev(levels(proportion_data_p53$Timepoint)))+
  theme_custom()

# save_plot( 
#   plot = supp8_forest_ddr_A,
#   filename = "Supp8_ForestDDR_EMP",
#   folder = output_folder,
#   height = 4,
#   width = 6)


```

```{r Forest Plot p53 redo Supp8B}

proportion_data_p53 <- purrr::map_dfr(names(timepoint_DEGs_p53), function(tp_p53) {
  degs_p53 <- unique(timepoint_DEGs_p53[[tp_p53]])
  nondegs_p53 <- setdiff(all_genes, degs_p53)
  
  in_deg_p53 <- sum(degs_p53 %in% p53_set)
  in_deg_nonp53 <- length(degs_p53) - in_deg_p53
  
  in_nondeg_p53 <- sum(nondegs_p53 %in% p53_set)
  in_nondeg_nonp53 <- length(nondegs_p53) - in_nondeg_p53
  
  contingency_degs_p53 <- matrix(c(in_deg_p53, in_deg_nonp53,
                                   in_nondeg_p53, in_nondeg_nonp53),
                                 nrow = 2, byrow = TRUE)
  
  fisher_res_p53 <- fisher.test(contingency_degs_p53)
  
  p_val_p53 <- fisher_res_p53$p.value
  odds_ratio_p53 <- unname(fisher_res_p53$estimate)
  ci_low_p53 <- fisher_res_p53$conf.int[1]
  ci_high_p53 <- fisher_res_p53$conf.int[2]
  
  tibble(
    Timepoint = tp_p53,
    Odds_Ratio = odds_ratio_p53,
    CI_low = ci_low_p53,
    CI_high = ci_high_p53,
    P_Value = p_val_p53,
    Significant = p_val_p53 < 0.01
  )
})

# Format Timepoint factor and add significance label/color
proportion_data_p53 <- proportion_data_p53 %>%
  mutate(
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R")),
    Sig_Label = ifelse(Significant, "Significant", "Not Significant")
  )

# Plot horizontal forest plot with color by significance
supp8_forest_p53_B <- ggplot(proportion_data_p53, aes(y = Timepoint, x = Odds_Ratio, color = Sig_Label)) +
  geom_point(size = 5) +
  geom_errorbarh(aes(xmin = CI_low, xmax = CI_high), height = 0.3) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "gray50") +
  scale_color_manual(values = c("Significant" = "black", "Not Significant" = "pink")) +
  scale_x_log10() +
  labs(
    title = "Odds Ratios of p53 Gene Enrichment by Timepoint",
    y = "Timepoint",
    x = "Odds Ratio (log scale)",
    color = "Significance"
  ) +
  scale_y_discrete(limits = rev(levels(proportion_data_p53$Timepoint)))+
  theme_custom()

# save_plot(
#   plot = supp8_forest_p53_B,
#   filename = "Supp8B_Forestp53_EMP",
#   folder = output_folder,
#   height = 4,
#   width = 6)


```



#Forest Plots and Proportion Barplots All Gene Sets
```{r Forest and Barplot All Gene Sets}


# =====================
# Function to process a gene set
# =====================
analyze_gene_set <- function(entrez_ids, gene_set_name, deg_list, total_background_genes) {
  total_genes <- length(entrez_ids)
  cat(paste0("Total ", gene_set_name, " genes: ", total_genes, "\n"))
  
  # Build dataframe for proportions
  gene_df <- map_dfr(names(deg_list), function(tp) {
    degs <- deg_list[[tp]]
    data.frame(
      Entrez_ID = entrez_ids,
      DEG_status = ifelse(entrez_ids %in% degs, "DEG", "non-DEG"),
      timepoint = tp
    )
  }) %>%
    mutate(timepoint = factor(timepoint, levels = c("24T", "24R", "144R")))
  
  # Count and compute proportions
  prop_df <- gene_df %>%
    dplyr::count(timepoint, DEG_status) %>%
    tidyr::complete(timepoint = factor(levels = c("24T", "24R", "144R")),
                    DEG_status = c("DEG", "non-DEG"),
                    fill = list(n = 0)) %>%
    dplyr::mutate(prop = n / total_genes * 100)
  
  # Stacked bar plot
  # bar_plot <- ggplot(prop_df, aes(x = timepoint, y = prop, fill = DEG_status)) +
  #   geom_bar(stat = "identity", position = "stack", color = "black") +
  #   geom_text(aes(label = paste0(round(prop,1), "%")),
  #             position = position_stack(vjust = 0.5), size = 5, color = "white") +
  #   scale_y_continuous(limits = c(0, 102), expand = c(0, 0)) +
  #   scale_fill_manual(
  #     values = c("DEG" = "#377EB8", "non-DEG" = "#E41A1C"),
  #     labels = c("DEG", paste0("non-DEG (n=", total_genes, ")"))
  #   ) +
  #   labs(
  #     x = "Timepoint",
  #     y = paste0("Proportion of ", gene_set_name, " Genes (%)"),
  #     title = paste0("Proportion of ", gene_set_name, " Genes that are DEGs vs non-DEGs"),
  #     fill = "Status"
  #   ) +
  #   theme_minimal(base_size = 14)
  # 
  # print(bar_plot)
  
  # Forest plot
  forest_df <- map_dfr(names(deg_list), function(tp) {
    degs <- deg_list[[tp]]
    
    # contingency table
    DEG_in_set <- sum(entrez_ids %in% degs)
    DEG_not_set <- length(degs) - DEG_in_set
    nonDEG_in_set <- total_genes - DEG_in_set
    nonDEG_not_set <- total_background_genes - total_genes - DEG_not_set
    
    mat <- matrix(c(DEG_in_set, DEG_not_set, nonDEG_in_set, nonDEG_not_set),
                  nrow = 2, byrow = TRUE)
    rownames(mat) <- c(gene_set_name, paste0("non-", gene_set_name))
    colnames(mat) <- c("DEG", "non-DEG")
    
    test <- fisher.test(mat)
    
    tibble(
      timepoint = tp,
      odds_ratio = as.numeric(test$estimate),
      conf_low = test$conf.int[1],
      conf_high = test$conf.int[2],
      p_value = test$p.value,
      sig = ifelse(test$p.value < 0.05, "sig", "ns")
    )
  })
  
  forest_df$timepoint <- factor(forest_df$timepoint, levels = c("24T", "24R", "144R"))
  
  forest_plot <- ggplot(forest_df, aes(x = odds_ratio, 
                                       y = forcats::fct_rev(timepoint),
                                       xmin = conf_low, xmax = 15,
                                       color = sig)) +
    geom_point(size = 5) +
    geom_errorbarh(aes(xmin = conf_low, xmax = conf_high), height = 0.3) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    scale_x_log10() +
    scale_color_manual(values = c("sig" = "black", "ns" = "black")) +
    labs(
      x = "Odds Ratio (log scale)",
      y = "Timepoint",
      title = paste0("Proportion of ", gene_set_name, " Genes that are DEGs vs non-DEGs")
    ) +
    theme_custom() +
    theme(legend.position = "none")
  
  print(forest_plot)
  
return(list(
  prop_df = prop_df,
  forest_df = forest_df,
  forest_plot = forest_plot
))
  }


# =====================
# Load DEGs for all timepoints
# =====================
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% dplyr::select(-X)
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% dplyr::select(-X)
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% dplyr::select(-X)

deg_list <- list(
  "24T" = DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05],
  "24R" = DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05],
  "144R" = DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]
)

# Background genes (all genes tested)
all_genes <- rownames(filcpm_matrix)
total_background_genes <- length(all_genes)
cat("Total background genes:", total_background_genes, "\n")

# =====================
# Run for DDR, P53, DIC sets
# =====================
DDR_results <- analyze_gene_set(ddr_set, "DDR", deg_list, total_background_genes)
P53_results <- analyze_gene_set(p53_set, "P53", deg_list, total_background_genes)
# DIC_results <- analyze_gene_set(dic_set, "DIC", deg_list, total_background_genes)


#save plots for forest plots
forest_plots <- list(
  "DDR_Forest_EMP.pdf" = DDR_results$forest_plot,
  "P53_Forest_EMP.pdf" = P53_results$forest_plot
)

#save into objects
ddr_forest_supp <- DDR_results$forest_plot

save_plot(
  filename = "Supp_DDR_Forest_EMP",
  plot = ddr_forest_supp,
  height = 3,
  width = 5,
  folder = output_folder
)

p53_forest_supp <- P53_results$forest_plot

# Save P53 forest plot
save_plot(
  filename = "Supp_P53_Forest_EMP",
  plot = p53_forest_supp,
  height = 3,
  width = 5,
  folder = output_folder
)


```


#Forest Plots all Gene Sets
```{r Forest Plots All Gene Sets out of DEGsvsnonDEGs set}

# Gene sets
gene_sets <- list(
  DDR = ddr_set,
  P53 = p53_set,
  DIC = dic_set
)

# DEGs per timepoint (already defined)
# deg_list <- list("24T" = DEGs_24T_R, "24R" = DEGs_24R_R, "144R" = DEGs_144R_R)

# Universe
all_genes <- rownames(filcpm_matrix)
total_background_genes <- length(all_genes)

# Function to generate forest data for a gene set
generate_forest_inverse <- function(gene_set, gene_set_name) {
  map_dfr(names(deg_list), function(tp) {
    degs <- deg_list[[tp]]
    non_degs <- setdiff(all_genes, degs)
    
    # Genes in DEGs and non-DEGs
    gene_in_DEGs <- sum(degs %in% gene_set)
    gene_not_in_DEGs <- sum(non_degs %in% gene_set)
    
    # Genes outside gene set
    not_gene_in_DEGs <- length(degs) - gene_in_DEGs
    not_gene_not_in_DEGs <- length(non_degs) - gene_not_in_DEGs
    
    # Contingency table
    mat <- matrix(c(gene_in_DEGs, not_gene_in_DEGs,
                    gene_not_in_DEGs, not_gene_not_in_DEGs),
                  nrow = 2, byrow = TRUE)
    rownames(mat) <- c("DEG", "non-DEG")
    colnames(mat) <- c("in_set", "not_in_set")
    
    test <- fisher.test(mat)
    
    tibble(
      gene_set = gene_set_name,
      timepoint = tp,
      odds_ratio = as.numeric(test$estimate),
      conf_low = test$conf.int[1],
      conf_high = test$conf.int[2],
      p_value = test$p.value,
      sig = ifelse(test$p.value < 0.05, "sig", "ns")
    )
  })
}

# ----------------------------
# Generate and plot each gene set separately
# ----------------------------
for(gs_name in names(gene_sets)) {
  forest_df <- generate_forest_inverse(gene_sets[[gs_name]], gs_name)
  forest_df$timepoint <- factor(forest_df$timepoint, levels = c("24T", "24R", "144R"))
  
  p <- ggplot(forest_df, 
              aes(x = odds_ratio, y = forcats::fct_rev(timepoint),
                  xmin = conf_low, xmax = conf_high,
                  color = sig)) +
    geom_pointrange(size = 1) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    scale_x_log10() +
    scale_color_manual(values = c("sig" = "red", "ns" = "grey")) +
    labs(
      x = "Odds Ratio (log scale)",
      y = "Timepoint",
      title = paste0(gs_name, " Gene Set Enrichment in DEGs/Non-DEGs per Timepoint")
    ) +
    theme_minimal(base_size = 14)
  
  print(p)
}

```


#Read in my DEGs Data
```{r Read and Process DEGs Data}
#read in boxplot1 for my log2cpm data
boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()
#this dataframe is unchanged

# Load Toptables
deg_files_ruv <- list.files("data/new/DEGs", pattern = "Toptable_RUV.*\\.csv", full.names = TRUE)
deg_list_ruv <- lapply(deg_files_ruv, read.csv)
names(deg_list_ruv) <- gsub("data/DEGs/Toptable_|\\.csv", "", deg_files_ruv)  

# Function to check significance based on **Entrez_ID in the correct sample**
is_significant <- function(gene, drug, conc, timepoint) {
  condition <- paste(drug, conc, timepoint, sep = "_")
  if (!condition %in% names(deg_list_ruv)) return(FALSE)
  
  toptable <- deg_list[[condition]]
  gene_entrez <- boxplot1$ENTREZID[boxplot1$SYMBOL == gene]
  
  if (length(gene_entrez) == 0) return(FALSE)
  
  return(any(gene_entrez %in% toptable$Entrez_ID[toptable$adj.P.Val < 0.05]))
}

```


##Process Data for Plotting RUVs logFC Boxplots
```{r Process Data for Plotting RUVs logFC Boxplots}

process_gene_data_DDR_RUVs_boxplots <- function(gene) {
  gene_data_boxplots_RUVs <- boxplot1 %>% filter(SYMBOL == gene)
  # Reshape data
  long_data_RUV_DDR <- gene_data_boxplots_RUVs %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, Indv, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
    # Identify significant conditions **per Drug, Conc, and Timepoint**
  significance_labels <- long_data_RUV_DDR %>%
    distinct(Drug, Timepoint, Indv) %>%
    rowwise() %>%
    mutate(
      max_log2CPM = max(long_data_RUV_DDR$log2CPM[long_data_RUV_DDR$Condition == Condition], na.rm = TRUE),
      Significance = ifelse(is_significant(gene, Drug, Timepoint, Indv), "*", "")
    ) %>%
    filter(Significance != "") %>% ungroup()
  
  list(long_data_RUV_DDR = long_data_RUV_DDR, significance_labels = significance_labels)
}

#####now I can go ahead and generate boxplots as requested
#want one for DDR, one for DIC, and one for p53

#genelists:
DDR_genes_ruv <- all_data_DDR_RUV$Gene
DIC_genes_ruv <- all_data_DIC_RUV$Gene
p53_genes_ruv <- all_data_p53_RUV$Gene

# #Generate Boxplots from the above function using our gene lists above
# for (gene in boxplot1) {
#   gene_data_boxplots_RUVs <- process_top5_D24R_1(gene)
#   p <- ggplot(gene_data_boxplots_RUVs, aes(x = Condition, y = log2cpm, fill = Drug)) +
#     geom_boxplot(outlier.shape = NA) +
#     geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
#     scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
#     ggtitle(paste("Log2cpm", gene, "top5DEGs D24R RUVs")) +
#     labs(x = "Treatment", y = "log2cpm") +
#     theme_bw() +
#     theme(
#       plot.title = element_text(size = rel(2), hjust = 0.5),
#       axis.title = element_text(size = 15, color = "black"),
#       axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
#     )
#   print(p)
# }

```

#Cormotif Function
```{r Cormotif Function}
## Fit limma model using code as it is found in the original cormotif code. It has
## only been modified to add names to the matrix of t values, as well as the
## limma fits

limmafit.default <- function(exprs,groupid,compid) {
  limmafits  <- list()
  compnum    <- nrow(compid)
  genenum    <- nrow(exprs)
  limmat     <- matrix(0,genenum,compnum)
  limmas2    <- rep(0,compnum)
  limmadf    <- rep(0,compnum)
  limmav0    <- rep(0,compnum)
  limmag1num <- rep(0,compnum)
  limmag2num <- rep(0,compnum)

  rownames(limmat)  <- rownames(exprs)
  colnames(limmat)  <- rownames(compid)
  names(limmas2)    <- rownames(compid)
  names(limmadf)    <- rownames(compid)
  names(limmav0)    <- rownames(compid)
  names(limmag1num) <- rownames(compid)
  names(limmag2num) <- rownames(compid)

  for(i in 1:compnum) {
    selid1 <- which(groupid == compid[i,1])
    selid2 <- which(groupid == compid[i,2])
    eset   <- new("ExpressionSet", exprs=cbind(exprs[,selid1],exprs[,selid2]))
    g1num  <- length(selid1)
    g2num  <- length(selid2)
    designmat <- cbind(base=rep(1,(g1num+g2num)), delta=c(rep(0,g1num),rep(1,g2num)))
    fit <- lmFit(eset,designmat)
    fit <- eBayes(fit)
    limmat[,i] <- fit$t[,2]
    limmas2[i] <- fit$s2.prior
    limmadf[i] <- fit$df.prior
    limmav0[i] <- fit$var.prior[2]
    limmag1num[i] <- g1num
    limmag2num[i] <- g2num
    limmafits[[i]] <- fit

    # log odds
    # w<-sqrt(1+fit$var.prior[2]/(1/g1num+1/g2num))
    # log(0.99)+dt(fit$t[1,2],g1num+g2num-2+fit$df.prior,log=TRUE)-log(0.01)-dt(fit$t[1,2]/w, g1num+g2num-2+fit$df.prior, log=TRUE)+log(w)
  }
  names(limmafits) <- rownames(compid)
  limmacompnum<-nrow(compid)
  result<-list(t       = limmat,
               v0      = limmav0,
               df0     = limmadf,
               s20     = limmas2,
               g1num   = limmag1num,
               g2num   = limmag2num,
               compnum = limmacompnum,
               fits    = limmafits)
}

limmafit.counts <-
  function (exprs, groupid, compid, norm.factor.method = "TMM", voom.normalize.method = "none")
  {
    limmafits  <- list()
    compnum    <- nrow(compid)
    genenum    <- nrow(exprs)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- rownames(exprs)
    colnames(limmat)  <- rownames(compid)
    names(limmas2)    <- rownames(compid)
    names(limmadf)    <- rownames(compid)
    names(limmav0)    <- rownames(compid)
    names(limmag1num) <- rownames(compid)
    names(limmag2num) <- rownames(compid)

    for (i in 1:compnum) {
      message(paste("Running limma for comparision",i,"/",compnum))
      selid1 <- which(groupid == compid[i, 1])
      selid2 <- which(groupid == compid[i, 2])
      # make a new count data frame
      counts <- cbind(exprs[, selid1], exprs[, selid2])

      # remove NAs
      not.nas <- which(apply(counts, 1, function(x) !any(is.na(x))) == TRUE)

      # runn voom/limma
      d <- DGEList(counts[not.nas,])
      d <- calcNormFactors(d, method = norm.factor.method)
      g1num <- length(selid1)
      g2num <- length(selid2)
      designmat <- cbind(base = rep(1, (g1num + g2num)), delta = c(rep(0,
                                                                       g1num), rep(1, g2num)))

      y <- voom(d, designmat, normalize.method = voom.normalize.method)
      fit <- lmFit(y, designmat)
      fit <- eBayes(fit)

      limmafits[[i]] <- fit
      limmat[not.nas, i] <- fit$t[, 2]
      limmas2[i] <- fit$s2.prior
      limmadf[i] <- fit$df.prior
      limmav0[i] <- fit$var.prior[2]
      limmag1num[i] <- g1num
      limmag2num[i] <- g2num
    }
    limmacompnum <- nrow(compid)
    names(limmafits) <- rownames(compid)
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)
  }

limmafit.list <-
  function (fitlist, cmp.idx=2)
  {
    compnum    <- length(fitlist)

    genes <- c()
    for (i in 1:compnum) genes <- unique(c(genes, rownames(fitlist[[i]])))

    genenum    <- length(genes)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- genes
    colnames(limmat)  <- names(fitlist)
    names(limmas2)    <- names(fitlist)
    names(limmadf)    <- names(fitlist)
    names(limmav0)    <- names(fitlist)
    names(limmag1num) <- names(fitlist)
    names(limmag2num) <- names(fitlist)

    for (i in 1:compnum) {
      this.t <- fitlist[[i]]$t[,cmp.idx]
      limmat[names(this.t),i] <- this.t

      limmas2[i]    <- fitlist[[i]]$s2.prior
      limmadf[i]    <- fitlist[[i]]$df.prior
      limmav0[i]    <- fitlist[[i]]$var.prior[cmp.idx]
      limmag1num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==0)
      limmag2num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==1)
    }

    limmacompnum <- compnum
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)

  }

## Rank genes based on statistics
generank<-function(x) {
  xcol<-ncol(x)
  xrow<-nrow(x)
  result<-matrix(0,xrow,xcol)
  z<-(1:1:xrow)
  for(i in 1:xcol) {
    y<-sort(x[,i],decreasing=TRUE,na.last=TRUE)
    result[,i]<-match(x[,i],y)
    result[,i]<-order(result[,i])
  }
  result
}

## Log-likelihood for moderated t under H0
modt.f0.loglike<-function(x,df) {
  a<-dt(x, df, log=TRUE)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Log-likelihood for moderated t under H1
## param=c(df,g1num,g2num,v0)
modt.f1.loglike<-function(x,param) {
  df<-param[1]
  g1num<-param[2]
  g2num<-param[3]
  v0<-param[4]
  w<-sqrt(1+v0/(1/g1num+1/g2num))
  dt(x/w, df, log=TRUE)-log(w)
  a<-dt(x/w, df, log=TRUE)-log(w)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Correlation Motif Fit
cmfit.X<-function(x, type, K=1, tol=1e-3, max.iter=100) {
  ## initialize
  xrow <- nrow(x)
  xcol <- ncol(x)
  loglike0 <- list()
  loglike1 <- list()
  p <- rep(1, K)/K
  q <- matrix(runif(K * xcol), K, xcol)
  q[1, ] <- rep(0.01, xcol)
  for (i in 1:xcol) {
    f0 <- type[[i]][[1]]
    f0param <- type[[i]][[2]]
    f1 <- type[[i]][[3]]
    f1param <- type[[i]][[4]]
    loglike0[[i]] <- f0(x[, i], f0param)
    loglike1[[i]] <- f1(x[, i], f1param)
  }
  condlike <- list()
  for (i in 1:xcol) {
    condlike[[i]] <- matrix(0, xrow, K)
  }
  loglike.old <- -1e+10
  for (i.iter in 1:max.iter) {
    if ((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations for K=",
                  K, sep = ""))
    }
    err <- tol + 1
    clustlike <- matrix(0, xrow, K)
    #templike <- matrix(0, xrow, 2)
    templike1 <- rep(0, xrow)
    templike2 <- rep(0, xrow)
    for (j in 1:K) {
      for (i in 1:xcol) {
        templike1 <- log(q[j, i]) + loglike1[[i]]
        templike2 <- log(1 - q[j, i]) + loglike0[[i]]
        tempmax <- Rfast::Pmax(templike1, templike2)

        templike1 <- exp(templike1 - tempmax)
        templike2 <- exp(templike2 - tempmax)

        tempsum <- templike1 + templike2
        clustlike[, j] <- clustlike[, j] + tempmax +
          log(tempsum)
        condlike[[i]][, j] <- templike1/tempsum
      }
      clustlike[, j] <- clustlike[, j] + log(p[j])
    }
    #tempmax <- apply(clustlike, 1, max)
    tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
    for (j in 1:K) {
      clustlike[, j] <- exp(clustlike[, j] - tempmax)
    }
    #tempsum <- apply(clustlike, 1, sum)
    tempsum <- Rfast::rowsums(clustlike)
    for (j in 1:K) {
      clustlike[, j] <- clustlike[, j]/tempsum
    }
    #p.new <- (apply(clustlike, 2, sum) + 1)/(xrow + K)
    p.new <- (Rfast::colsums(clustlike) + 1)/(xrow + K)
    q.new <- matrix(0, K, xcol)
    for (j in 1:K) {
      clustpsum <- sum(clustlike[, j])
      for (i in 1:xcol) {
        q.new[j, i] <- (sum(clustlike[, j] * condlike[[i]][,
                                                           j]) + 1)/(clustpsum + 2)
      }
    }
    err.p <- max(abs(p.new - p)/p)
    err.q <- max(abs(q.new - q)/q)
    err <- max(err.p, err.q)
    loglike.new <- (sum(tempmax + log(tempsum)) + sum(log(p.new)) +
                      sum(log(q.new) + log(1 - q.new)))/xrow
    p <- p.new
    q <- q.new
    loglike.old <- loglike.new
    if (err < tol) {
      break
    }
  }
  clustlike <- matrix(0, xrow, K)
  for (j in 1:K) {
    for (i in 1:xcol) {
      templike1 <- log(q[j, i]) + loglike1[[i]]
      templike2 <- log(1 - q[j, i]) + loglike0[[i]]
      tempmax <- Rfast::Pmax(templike1, templike2)

      templike1 <- exp(templike1 - tempmax)
      templike2 <- exp(templike2 - tempmax)

      tempsum <- templike1 + templike2
      clustlike[, j] <- clustlike[, j] + tempmax + log(tempsum)
      condlike[[i]][, j] <- templike1/tempsum
    }
    clustlike[, j] <- clustlike[, j] + log(p[j])
  }
  #tempmax <- apply(clustlike, 1, max)
  tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
  for (j in 1:K) {
    clustlike[, j] <- exp(clustlike[, j] - tempmax)
  }
  #tempsum <- apply(clustlike, 1, sum)
  tempsum <- Rfast::rowsums(clustlike)
  for (j in 1:K) {
    clustlike[, j] <- clustlike[, j]/tempsum
  }
  p.post <- matrix(0, xrow, xcol)
  for (j in 1:K) {
    for (i in 1:xcol) {
      p.post[, i] <- p.post[, i] + clustlike[, j] * condlike[[i]][,
                                                                  j]
    }
  }
  loglike.old <- loglike.old - (sum(log(p)) + sum(log(q) +
                                                    log(1 - q)))/xrow
  loglike.old <- loglike.old * xrow
  result <- list(p.post = p.post, motif.prior = p, motif.q = q,
                 loglike = loglike.old, clustlike=clustlike, condlike=condlike)
}

## Fit using (0,0,...,0) and (1,1,...,1)
cmfitall<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01

  ## compute loglikelihood
  L0<-matrix(0,xrow,1)
  L1<-matrix(0,xrow,1)
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
    L0<-L0+loglike0[[i]]
    L1<-L1+loglike1[[i]]
  }


  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p)+L0
    clustlike[,2]<-log(p)+L1

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(sum(clustlike[,2])+1)/(xrow+2)

    ## evaluate convergence
    err<-abs(p.new-p)/p

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+log(p.new)+log(1-p.new))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,2)
  clustlike[,1]<-log(1-p)+L0
  clustlike[,2]<-log(p)+L1

  tempmax<-apply(clustlike,1,max)
  for(j in 1:2) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:2) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(i in 1:xcol) {
    p.post[,i]<-clustlike[,2]
  }

  ## return

  #calculate back loglikelihood
  loglike.old<-loglike.old-(log(p)+log(1-p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

## Fit each dataset separately
cmfitsep<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01*rep(1,xcol)
  loglike.final<-rep(0,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }

  p.post<-matrix(0,xrow,xcol)

  ## EM algorithm to get MLE of p
  for(coli in 1:xcol) {
    loglike.old <- -1e10
    for(i.iter in 1:max.iter) {
      if((i.iter%%50) == 0) {
        print(paste("We have run the first ", i.iter, " iterations",sep=""))
      }
      err<-tol+1

      ## compute posterior cluster membership
      clustlike<-matrix(0,xrow,2)
      clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
      clustlike[,2]<-log(p[coli])+loglike1[[coli]]

      tempmax<-apply(clustlike,1,max)
      for(j in 1:2) {
        clustlike[,j]<-exp(clustlike[,j]-tempmax)
      }
      tempsum<-apply(clustlike,1,sum)

      ## evaluate whether the log.likelihood increases
      loglike.new<-sum(tempmax+log(tempsum))/xrow

      ## update motif occurrence rate
      for(j in 1:2) {
        clustlike[,j]<-clustlike[,j]/tempsum
      }

      p.new<-(sum(clustlike[,2]))/(xrow)

      ## evaluate convergence
      err<-abs(p.new-p[coli])/p[coli]
      loglike.old<-loglike.new
      p[coli]<-p.new

      if(err<tol) {
        break;
      }
    }

    ## compute posterior p
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
    clustlike[,2]<-log(p[coli])+loglike1[[coli]]

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.post[,coli]<-clustlike[,2]
    loglike.final[coli]<-loglike.old
  }


  ## return
  loglike.final<-loglike.final*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.final)
}

## Fit the full model
cmfitfull<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  K<-2^xcol
  p<-rep(1,K)/K
  pattern<-rep(0,xcol)
  patid<-matrix(0,K,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }
  L<-matrix(0,xrow,K)
  for(i in 1:K)
  {
    patid[i,]<-pattern
    for(j in 1:xcol) {
      if(pattern[j] < 0.5) {
        L[,i]<-L[,i]+loglike0[[j]]
      } else {
        L[,i]<-L[,i]+loglike1[[j]]
      }
    }

    if(i < K) {
      pattern[xcol]<-pattern[xcol]+1
      j<-xcol
      while(pattern[j] > 1) {
        pattern[j]<-0
        j<-j-1
        pattern[j]<-pattern[j]+1
      }
    }
  }

  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,K)
    for(j in 1:K) {
      clustlike[,j]<-log(p[j])+L[,j]
    }

    tempmax<-apply(clustlike,1,max)
    for(j in 1:K) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:K) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(apply(clustlike,2,sum)+1)/(xrow+K)

    ## evaluate convergence
    err<-max(abs(p.new-p)/p)

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+sum(log(p.new)))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,K)
  for(j in 1:K) {
    clustlike[,j]<-log(p[j])+L[,j]
  }

  tempmax<-apply(clustlike,1,max)
  for(j in 1:K) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:K) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(j in 1:K) {
    for(i in 1:xcol) {
      if(patid[j,i] > 0.5) {
        p.post[,i]<-p.post[,i]+clustlike[,j]
      }
    }
  }

  ## return
  #calculate back loglikelihood
  loglike.old<-loglike.old-sum(log(p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

generatetype<-function(limfitted)
{
  jtype<-list()
  df<-limfitted$g1num+limfitted$g2num-2+limfitted$df0
  for(j in 1:limfitted$compnum)
  {
    jtype[[j]]<-list(f0=modt.f0.loglike, f0.param=df[j], f1=modt.f1.loglike, f1.param=c(df[j],limfitted$g1num[j],limfitted$g2num[j],limfitted$v0[j]))
  }
  jtype
}

cormotiffit <- function(exprs, groupid=NULL, compid=NULL, K=1, tol=1e-3,
                        max.iter=100, BIC=TRUE, norm.factor.method="TMM",
                        voom.normalize.method = "none", runtype=c("logCPM","counts","limmafits"), each=3)
{
  # first I want to do some typechecking. Input can be either a normalized
  # matrix, a count matrix, or a list of limma fits. Dispatch the correct
  # limmafit accordingly.
  # todo: add some typechecking here
  limfitted <- list()
  if (runtype=="counts") {DOX_24T_shared_DEGs
    limfitted <- limmafit.counts(exprs,groupid,compid, norm.factor.method, voom.normalize.method)
  } else if (runtype=="logCPM") {
    limfitted <- limmafit.default(exprs,groupid,compid)
  } else if (runtype=="limmafits") {
    limfitted <- limmafit.list(exprs)
  } else {
    stop("runtype must be one of 'logCPM', 'counts', or 'limmafits'")
  }


  jtype<-generatetype(limfitted)
  fitresult<-list()
  ks <- rep(K, each = each)
  fitresult <- bplapply(1:length(ks), function(i, x, type, ks, tol, max.iter) {
    cmfit.X(x, type, K = ks[i], tol = tol, max.iter = max.iter)
  }, x=limfitted$t, type=jtype, ks=ks, tol=tol, max.iter=max.iter)

  best.fitresults <- list()
  for (i in 1:length(K)) {
    w.k <- which(ks==K[i])
    this.bic <- c()
    for (j in w.k) this.bic[j] <- -2 * fitresult[[j]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
    w.min <- which(this.bic == min(this.bic, na.rm = TRUE))[1]
    best.fitresults[[i]] <- fitresult[[w.min]]
  }
  fitresult <- best.fitresults

  bic <- rep(0, length(K))
  aic <- rep(0, length(K))
  loglike <- rep(0, length(K))
  for (i in 1:length(K)) loglike[i] <- fitresult[[i]]$loglike
  for (i in 1:length(K)) bic[i] <- -2 * fitresult[[i]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
  for (i in 1:length(K)) aic[i] <- -2 * fitresult[[i]]$loglike + 2 * (K[i] - 1 + K[i] * limfitted$compnum)
  if(BIC==TRUE) {
    bestflag=which(bic==min(bic))
  }
  else {
    bestflag=which(aic==min(aic))
  }
  result<-list(bestmotif=fitresult[[bestflag]],bic=cbind(K,bic),
               aic=cbind(K,aic),loglike=cbind(K,loglike), allmotifs=fitresult)

}

cormotiffitall<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitall(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitsep<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitsep(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitfull<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitfull(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

plotIC<-function(fitted_cormotif)
{
  oldpar<-par(mfrow=c(1,2))
  plot(fitted_cormotif$bic[,1], fitted_cormotif$bic[,2], type="b",xlab="Motif Number", ylab="BIC", main="BIC")
  plot(fitted_cormotif$aic[,1], fitted_cormotif$aic[,2], type="b",xlab="Motif Number", ylab="AIC", main="AIC")
}

plotMotif<-function(fitted_cormotif,title="")
{
  layout(matrix(1:2,ncol=2))
  u<-1:dim(fitted_cormotif$bestmotif$motif.q)[2]
  v<-1:dim(fitted_cormotif$bestmotif$motif.q)[1]
  image(u,v,t(fitted_cormotif$bestmotif$motif.q),
        col=gray(seq(from=1,to=0,by=-0.1)),xlab="Study",yaxt = "n",
        ylab="Corr. Motifs",main=paste(title,"pattern",sep=" "))
  axis(2,at=1:length(v))
  for(i in 1:(length(u)+1))
  {
    abline(v=(i-0.5))
  }
  for(i in 1:(length(v)+1))
  {
    abline(h=(i-0.5))
  }
  Ng=10000
  if(is.null(fitted_cormotif$bestmotif$p.post)!=TRUE)
    Ng=nrow(fitted_cormotif$bestmotif$p.post)
  genecount=floor(fitted_cormotif$bestmotif$motif.p*Ng)
  NK=nrow(fitted_cormotif$bestmotif$motif.q)
  plot(0,0.7,pch=".",xlim=c(0,1.2),ylim=c(0.75,NK+0.25),
       frame.plot=FALSE,axes=FALSE,xlab="No. of genes",ylab="", main=paste(title,"frequency",sep=" "))
  segments(0,0.7,fitted_cormotif$bestmotif$motif.p[1],0.7)
  rect(0,1:NK-0.3,fitted_cormotif$bestmotif$motif.p,1:NK+0.3,
       col="dark grey")
  mtext(1:NK,at=1:NK,side=2,cex=0.8)
  text(fitted_cormotif$bestmotif$motif.p+0.15,1:NK,
       labels=floor(fitted_cormotif$bestmotif$motif.p*Ng))
}

```


```{r Cormotif Library}
#Don't load me in if you're using the above function, as it has been modified above
#library(Cormotif)
```

##Input Data for Cormotif Original Matrix
```{r Cormotif Data}

#input the cormotif matrix you're going to use
##this should be tmm normalized log2cpm

#the matrix that I used previously for limma was TMM counts - cpm this
#dge was the name of the DGE list object

cormotif_test <- cpm(dge, log = TRUE)
colnames(cormotif_test) <- (Metadata_2$Final_sample_name)

cormotif_counts <- dge

cormotif_test_df <- cormotif_test %>% 
  as.data.frame() %>% 
  rownames_to_column(., var = "Entrez_ID")

#write.csv(cormotif_test, "data/new/Cormotif_test_matrix.csv")

#reorder my test matrix to match the new groupid I've made
#I want my columns to be in this order:
#DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
Cormotif <- read.csv("data/new/Cormotif_matrix_final.csv")
dim(Cormotif)
#14319 genes across 37 cols (1 is Entrez_ID)
Cormotif_df <- data.frame(Cormotif)

rownames(Cormotif_df) <- Cormotif_df$Entrez_ID
exprs.cormotif <- as.matrix(Cormotif_df[,2:37])
dim(exprs.cormotif)

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_csv <- read.csv("data/new/GroupID.csv")
#now I have to make this into a vector (named vector)
groupid <- c(
  DOX_24T_1 = 1, 
  DOX_24T_2 = 1, 
  DOX_24T_3 = 1, 
  DOX_24T_4 = 1, 
  DOX_24T_5 = 1, 
  DOX_24T_6 = 1,
  DOX_24R_1 = 2, 
  DOX_24R_2 = 2, 
  DOX_24R_3 = 2, 
  DOX_24R_4 = 2, 
  DOX_24R_5 = 2, 
  DOX_24R_6 = 2,
  DOX_144R_1 = 3, 
  DOX_144R_2 = 3, 
  DOX_144R_3 = 3, 
  DOX_144R_4 = 3, 
  DOX_144R_5 = 3, 
  DOX_144R_6 = 3,
  DMSO_24T_1 = 4, 
  DMSO_24T_2 = 4, 
  DMSO_24T_3 = 4, 
  DMSO_24T_4 = 4, 
  DMSO_24T_5 = 4, 
  DMSO_24T_6 = 4,
  DMSO_24R_1 = 5, 
  DMSO_24R_2 = 5, 
  DMSO_24R_3 = 5, 
  DMSO_24R_4 = 5, 
  DMSO_24R_5 = 5, 
  DMSO_24R_6 = 5,
  DMSO_144R_1 = 6, 
  DMSO_144R_2 = 6, 
  DMSO_144R_3 = 6, 
  DMSO_144R_4 = 6, 
  DMSO_144R_5 = 6, 
  DMSO_144R_6 = 6
)
#saveRDS(groupid, "data/new/groupidCormotif.RDS")

compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
#saveRDS(compid, "data/new/compidCormotif.RDS")
```

###Run Cormotif Original Data
```{r Run Cormotif}
#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fitted_new <- cormotiffit(
#   exprs = exprs.cormotif,
#   groupid = groupid,
#   compid = compid,
#   K = 1:8,
#   max.iter = 1000,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fitted, "data/new/motif.fitted_new_250604.RDS")
motif.fitted <- readRDS("data/new/motif.fitted_final_3motif.RDS")
```

###Plotting Cormotif Original Data
```{r Plot Cormotif}

#plot BIC and AIC to see which number of motifs was best for both models
plotIC(motif.fitted)

motif.fitted$bic

#now plot the motifs themselves
plotMotif(motif.fitted, title = "Fitted Motifs for DXR")

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```


###Extract the Gene Probabilities
```{r Extract gene probabilities}
#extract the posterior probability that these DEGs belong to motifs
gene_prob_all <- motif.fitted$bestmotif$p.post
rownames(gene_prob_all) <- rownames(Cormotif_df)

#assign each gene to a motif with max post prob
assigned_motifs <- apply(gene_prob_all, 1, which.max)
max_probs <- apply(gene_prob_all, 1, max)

#combine these into a dataframe - motif assigned genes (p.post)
motif_assignment_df <- gene_prob_all %>%
  as.data.frame() %>%
  rownames_to_column("Gene") %>%
  mutate(
    Assigned_Motif = assigned_motifs[Gene],
    Max_Probability = max_probs[Gene]
  )

#make some histograms of the unfiltered data from Cormotif p.post

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M1")

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M2")

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V3))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M3")

#now change the probability cutoffs to get the ideal gene set with no overlaps

# Define gene probability groups
prob_all_1  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.05 & gene_prob_all[,1] <0.3 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])

length(prob_all_1)
#5675

prob_all_2  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.5 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])

length(prob_all_2)
#6353

prob_all_3  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.3 & gene_prob_all[,1] <0.9 & gene_prob_all[,2] >0.5 & gene_prob_all[,3] >0.5),])

length(prob_all_3)
#231 genes with >0.3 <0.9 1

#compare between motif 1 and 2
mf1_genes <- prob_all_1
mf2_genes <- prob_all_2
mf3_genes <- prob_all_3

vennCor <- list(mf1_genes, mf2_genes, mf3_genes)
ggVennDiagram(
  vennCor,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs p.post")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )


#extract the cluster likelihood - which DEGs are most likely to be in this cluster
motif_prob <- motif.fitted$bestmotif$clustlike
rownames(motif_prob) <- rownames(gene_prob_all)
#write.csv(motif_prob,"data/new/cormotif_probability_genelist_all.csv")

#make some histograms to look at the distribution of clustlike genes without filtering
motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M1")

motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M2")

motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V3))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M3")

####try this Renee's way####
clust1_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V1>0.5 & V2<0.5 & V3<0.5) %>% 
  rownames
clust2_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5 & V3<0.5) %>% 
  rownames
clust3_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V3>0.5 & V1 <0.5 & V2 <0.5) %>% 
  rownames

length(clust1_p)
#6827 (too many)
length(clust2_p)
#6474
length(clust3_p)
#607

mf1_genes_p <- clust1_p
mf2_genes_p <- clust2_p
mf3_genes_p <- clust3_p

vennCor <- list(mf1_genes_p, mf2_genes_p, mf3_genes_p)
ggVennDiagram(
  vennCor,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs clustlike")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

```

###Use Clustlike and P.post together for Cormotif
```{r Extract Gene Probability clust then p.post}
#begin with the clustlike cutoffs and then overlay the p.post to check if the genes are present in both

#these filters are the combination of the above analysis to get a gene set that fits in both p.post and clustlike

####motif 1####
#filter 1: clustlike
clust1_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V1>0.5 & V2<0.5 & V3<0.5) %>% 
  rownames
### Filter 2: Gene-level posterior pattern
prob_filtered_genes_1 <- rownames(gene_prob_all[(gene_prob_all[,1] >0.05 & gene_prob_all[,1] <0.3 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])
### Final intersection of both filters
final_genes_1 <- intersect(clust1_genes, prob_filtered_genes_1)
cat("Number of genes passing both filters:", length(final_genes_1), "\n")

#5638 genes pass both filters here

####motif 2####
#filter 1: clustlike
clust2_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5 & V3<0.5) %>% 
  rownames
### Filter 2: Gene-level posterior pattern
prob_filtered_genes_2 <- rownames(gene_prob_all[(gene_prob_all[,1] >0.5 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])
### Final intersection of both filters
final_genes_2 <- intersect(clust2_genes, prob_filtered_genes_2)
cat("Number of genes passing both filters:", length(final_genes_2), "\n")

#6218 genes pass both filters here


####motif3####
#filter 1: clustlike
clust3_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V3 > 0.5 & V1 < 0.5 & V2 < 0.5) %>%
  rownames()
### Filter 2: Gene-level posterior pattern (Motif 2 & 3 high, Motif 1 intermediate)
prob_filtered_genes <- rownames(gene_prob_all[
  gene_prob_all[,1] > 0.3 & gene_prob_all[,1] < 0.9 &
  gene_prob_all[,2] > 0.5 &
  gene_prob_all[,3] > 0.5, ])
### Final intersection of both filters
final_genes_3 <- intersect(clust3_genes, prob_filtered_genes)
cat("Number of genes passing both filters:", length(final_genes_3), "\n")

#231 genes pass both filters here

#what is the proportion of my genes that are included?
5638+6218+231
#12087
(12087/14319)*100
#84.4% of my genes are represented here out of the 14319 original

#want to find out which genes are not assigned to motifs

final_genes_list <- union(final_genes_1, union(final_genes_2, final_genes_3))
length(final_genes_list)
#12087 genes as found above
initial_genes_list <- rownames(filcpm_matrix)
length(initial_genes_list)
#14319 genes as usual
unassigned_genes_list <- setdiff(initial_genes_list, final_genes_list)
length(unassigned_genes_list)
#2232 genes not assigned - correct number

#saveRDS(unassigned_genes_list, "data/new/Cormotif/unassigned_genes_Cormotif.RDS")

#now, ensure that none of these genes are shared amongst categories
vennCor_final <- list(final_genes_1, final_genes_2, final_genes_3)
ggVennDiagram(
  vennCor_final,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs clustlike + p.post")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#no overlapping genes found in these gene sets

clusterdata_dxr_fin <- data.frame(
  Category = c("Motif 1", "Motif 2", "Motif 3"), 
  Value = c(length(final_genes_1), length(final_genes_2), length(final_genes_3))
)

piecolors_dxr_fin <- c("Motif 1" = "#007896", 
                       "Motif 2" = "#58508D",
                       "Motif 3" = "#BC5090")

#make a piechart of these distributions
clusterdata_dxr_fin %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distribution of Gene Clusters Identified By Cormotif", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors_dxr_fin)

#now, continue by plotting the logFC of all of these gene sets per motif, as well as look at some random genes for log2cpm to see if the patterns are reflected in the example genes


```

###Plot logFC of Clustlike vs P.post Cormotif
```{r logFC of Clustlike vs P.post Cormotif}
####clustlike logFC of initial set####
##motif 1
length(mf1_genes_p)
##motif 2 
length(mf2_genes_p)
##motif 3
length(mf3_genes_p)

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% mf1_genes_p) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 1 (n=6827)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 3
filt_toptable_3_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_dxr_fin
filt_toptable_2_dxr_fin 
filt_toptable_3_dxr_fin


#now plot the abs logFC for each of these too
filt_toptable_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_3_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_abs_fin
filt_toptable_2_abs_fin
filt_toptable_3_abs_fin



```

###Plot logFC of All Motifs
```{r logFC of Cormotif Motifs}
##motif 1
motif1_genes_fin <- final_genes_1
length(motif1_genes_fin)

##motif 2 
motif2_genes_fin <- final_genes_2
length(motif2_genes_fin)

##motif 3
motif3_genes_fin <- final_genes_3
length(motif3_genes_fin)

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 3
filt_toptable_3_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_dxr_fin
filt_toptable_2_dxr_fin 
filt_toptable_3_dxr_fin


#now plot the abs logFC for each of these too
filt_toptable_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_3_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_abs_fin
filt_toptable_2_abs_fin
filt_toptable_3_abs_fin

```

###Put together log2cpm Genes for Each Motif
```{r log2cpm Cormotif Genes}
#use the final genes from cross-verifying with clustlike + p.post

#Load in my count matrices
# final_genes_1
# final_genes_2
# final_genes_3

#these are all the genes that are present in each category, make them into dataframes by filtering out the rest of the genes in my main boxplot df
boxplots_cormotif <- boxplot1

motif1_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_1,]
dim(motif1_genes_fin)
#5638 genes in 44 cols
motif2_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_2,]
dim(motif2_genes_fin)
#6218 genes in 44 cols
motif3_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_3,]
dim(motif3_genes_fin)
#231 genes in 44 cols

#pull out some random genes for each using sample

m1_genes_fin <- motif1_genes_fin[sample(nrow(motif1_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes1_fin <- c(m1_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data_1_fin <- function(gene) {
  gene_data <- motif1_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes1_fin) {
  gene_data <- process_gene_data_1_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 1")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 2#####

m2_genes_fin <- motif2_genes_fin[sample(nrow(motif2_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes2_fin <- c(m2_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam2_fin <- function(gene) {
  gene_data <- motif2_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes2_fin) {
  gene_data <- process_gene_datam2_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 2")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 3#####

m3_genes_fin <- motif3_genes_fin[sample(nrow(motif3_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m3_genes
initial_test_genes3_fin <- c(m3_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam3_fin <- function(gene) {
  gene_data <- motif3_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes3_fin) {
  gene_data <- process_gene_datam3_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 3")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```

###GO/KEGG Final Genes Cormotif
```{r Cormotif GO KEGG Final Genes}
#now take these final gene sets for each motif - clustlike + p.post consensus genes

#define my background gene set
all_genes

# final_genes_1
# final_genes_2
# final_genes_3

# library(gprofiler2)
#####Motif 1 Gene Set#####
# motif1_genes_matrix <- as.matrix(final_genes_1) 
# colnames(motif1_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif1_genes_matrix, "data/new/motif1_genes_matrix.RDS")

motif1_genes_matrix <- readRDS("data/new/motif1_genes_matrix.RDS")
length(motif1_genes_matrix)
#5638 genes in this set for motif 1

motif1_mat_GOKEGG <- gost(query = motif1_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif1_GOKEGG_genes <- gostplot(motif1_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif1_GOKEGG_genes

table_motif1_GOKEGG_genes <- motif1_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif1_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif1_GOKEGG_genes, "data/new/table_motif1_GOKEGG_genes.csv")

#GO:BP
table_motif1_genes_GOBP <- table_motif1_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif1_genes_GOBP, "data/table_motif1_genes_GOBP.RDS")

table_motif1_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 1 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif1_genes_KEGG <- table_motif1_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif1_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 1 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####Motif 2 Genes#####
# motif2_genes_matrix <- as.matrix(final_genes_2) 
# colnames(motif2_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif2_genes_matrix, "data/new/motif2_genes_matrix.RDS")
motif2_genes_matrix <- readRDS("data/new/motif2_genes_matrix.RDS")
length(motif2_genes_matrix)
#6218 genes in this set for motif 2

motif2_mat_GOKEGG <- gost(query = motif2_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif2_GOKEGG_genes <- gostplot(motif2_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif2_GOKEGG_genes

table_motif2_GOKEGG_genes <- motif2_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif2_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif2_GOKEGG_genes, "data/new/table_motif2_GOKEGG_genes.csv")

#GO:BP
table_motif2_genes_GOBP <- table_motif2_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif2_genes_GOBP, "data/table_motif2_genes_GOBP.RDS")

table_motif2_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 2 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif2_genes_KEGG <- table_motif2_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif2_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 2 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####Motif 3 DEGs GO KEGG#####
# motif3_genes_matrix <- as.matrix(final_genes_3) 
# colnames(motif3_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif3_genes_matrix, "data/new/motif3_genes_matrix.RDS")

motif3_genes_matrix <- readRDS("data/new/motif3_genes_matrix.RDS")
length(motif3_genes_matrix)
#231 genes in this set for motif 3

motif3_mat_GOKEGG <- gost(query = motif3_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif3_GOKEGG_genes <- gostplot(motif3_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif3_GOKEGG_genes

table_motif3_GOKEGG_genes <- motif3_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif3_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif3_GOKEGG_genes, "data/new/table_motif3_GOKEGG_genes.csv")

#GO:BP
table_motif3_genes_GOBP <- table_motif3_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif3_genes_GOBP, "data/table_motif3_genes_GOBP.RDS")

table_motif3_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 3 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif3_genes_KEGG <- table_motif3_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif3_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 3 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```
###Look at Unassigned Gene Set Cormotif
```{r Cormotif Unassigned Gene Set}
#now let's pull out the genes that were not assigned to a motif from above

#this one is giving me an issue with wflow_build so I'll fix it later

unassigned_genes_list <- readRDS("data/new/Cormotif/unassigned_genes_Cormotif.RDS")

#with these unassigned genes, I want to plot logFC and GO/KEGG of unassigned genes
#####logFC#####

##no motif genes
unassign_genes_fin <- unassigned_genes_list
length(unassign_genes_fin)
#2232 genes 

#Combine the toptables I have from pairwise analysis into a single dataframe
combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
# filt_toptable_dxr_fin_unassign <- as.data.frame(combined_toptables_dxr) %>% 
#   dplyr::filter(Entrez_ID  %in% unassign_genes_fin) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = logFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("logFC")+
#   theme_bw()+
#   ggtitle("LogFC of Unassigned Genes (n=2232)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# filt_toptable_dxr_fin_unassign


# filt_toptable_abs_fin_unassign <- as.data.frame(combined_toptables_dxr) %>% 
#   dplyr::filter(Entrez_ID  %in% unassign_genes_fin) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = absFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("|logFC|")+
#   theme_bw()+
#   ggtitle("Abs LogFC of Unassigned Genes (n=2232)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# filt_toptable_abs_fin_unassign

####GO KEGG####
unassigned_genes_matrix <- as.matrix(unassigned_genes_list)
length(unassigned_genes_matrix)
#2232 genes in this set

unassign_mat_GOKEGG <- gost(query = unassigned_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

unassign_GOKEGG_genes <- gostplot(unassign_mat_GOKEGG, capped = FALSE, interactive = TRUE)
unassign_GOKEGG_genes

table_unassign_GOKEGG_genes <- unassign_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_unassign_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_unassign_genes_GOBP <- table_unassign_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_unassign_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Unassigned Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_unassign_genes_KEGG <- table_unassign_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_unassign_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Unassigned DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))



```
##Cormotif RUVs Corrected Norm Counts TMM and log2cpm
```{r  RUVs Cormotif with Norm Counts}
# #read in the norm counts df (normalized counts from RUV)
set1 <- readRDS("data/new/RUV/set1_RUVsk1_normcounts.RDS")
NormCounts_RUV_rep <- as.data.frame(set1$normalizedCounts)
# 
# #read in my metadata sheet that I'll use as the standard for labelling
# #this one already has the replicate individual removed
Metadata_2 <- readRDS("data/new/Metadata_2_norep.RDS")
# 
# #I'll have to remove the replicate at this stage so I can properly run Cormotif
NormCounts_RUV <- NormCounts_RUV_rep %>%
  dplyr::select(-(contains("6R")))
# 
# #now ensure the column names match the original dge$counts with Sample_name
colnames(NormCounts_RUV) <- Metadata_2$Sample_name
# 
# #now, make this into a dge object as I did for DE + Cormotif
dge_RUV <- DGEList(counts = NormCounts_RUV)
# 
# #put the Condition names as a factor onto the dge object for further sorting
dge_RUV$samples$group <- factor(Metadata_2[colnames(NormCounts_RUV), "Condition"])
# 
# #TMM normalize the normalized counts input with the dge object
dge_RUV_calc <- calcNormFactors(dge_RUV, method = "TMM")
# #this is producing a lot of NaNs warnings, perhaps because TMM should occur before norm counts?
# 
# #try by performing TMM normalization before norm counts in set1
# 
counts <- readRDS("data/new/RUV/filt_counts_matrix.RDS")
# #use this counts file to feed into set1 - but instead TMM normalize it first
# 
counts_tmm <- calcNormFactors(counts, method = "TMM")
# 
# set1_tmm <- RUVSeq::RUVs(x = counts_tmm, k =1, scIdx = scIdx, isLog = FALSE)
# error with tmm normalized counts going into RUVseq
# 
# summary(colSums(NormCounts_RUV))
# dge_RUV$samples
# # 
ncol(NormCounts_RUV) == nrow(Metadata_2)           # Should be TRUE
all(colnames(NormCounts_RUV) == rownames(Metadata_2))
# 
# 
# #save this file so I can read it in later!
# #saveRDS(dge_RUV_calc, "data/new/Cormotif/dge_matrix_forCormotif.RDS")
# 
# #check normalization factors from TMM normalization of LIBRARIES
# dge_RUV_calc$samples
# #it was normalized properly but generated NaNs warnings?
# #still has the same number of columns, properly labelled and in order according to metadata
#  #should be okay - let's try running it and see if it works properly
# 
# Metadata_2_ordered <- Metadata_2[match(colnames(NormCounts_RUV), Metadata_2$Sample_name), ]
# 
# #now cpm these TMM normalized norm counts
# cmf_RUV_cpm <- cpm(dge_RUV_calc, log = TRUE)
# 
# #change the column names to match the Metadata sheet I have
# colnames(cmf_RUV_cpm) <- (Metadata_2$Final_sample_name)
# 
# cmf_RUV_counts <- dge_RUV_calc
# 
# #now make your TMM normalized cpm of norm counts into a dataframe + add Entrez_ID as a col
# cmf_RUV_df <- cmf_RUV_cpm %>%
  # as.data.frame() %>%
  # rownames_to_column(., var = "Entrez_ID")
# 
# #save this to a csv file so I can reorder this matrix easily
# #write.csv(cmf_RUV_cpm, "data/new/Cormotif/RUV/Cormotif_RUVk1_cpm_matrix.csv")
# 
# #reorder my test matrix to match the new groupid I've made
# #I want my columns to be in this order:
# #DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
# Cormotif_RUV <- read.csv("data/new/cmf_RUV_final.csv")
# dim(Cormotif_RUV)
# # #14319 genes across 37 cols (1 is Entrez_ID)
# Cormotif_RUV_df <- data.frame(Cormotif_RUV)
# # 
# rownames(Cormotif_RUV_df) <- Cormotif_RUV_df$Entrez_ID
# exprs.cmf_RUV <- as.matrix(Cormotif_RUV_df[,2:37])
# dim(exprs.cmf_RUV)
# # 
# 
# #put together my group id and comparison id to make the correct comparisons between experimental conditions
# 
# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control
# 
# groupid <- c(
#   DOX_24T_1 = 1,
#   DOX_24T_2 = 1,
#   DOX_24T_3 = 1,
#   DOX_24T_4 = 1,
#   DOX_24T_5 = 1,
#   DOX_24T_6 = 1,
#   DOX_24R_1 = 2,
#   DOX_24R_2 = 2,
#   DOX_24R_3 = 2,
#   DOX_24R_4 = 2,
#   DOX_24R_5 = 2,
#   DOX_24R_6 = 2,
#   DOX_144R_1 = 3,
#   DOX_144R_2 = 3,
#   DOX_144R_3 = 3,
#   DOX_144R_4 = 3,
#   DOX_144R_5 = 3,
#   DOX_144R_6 = 3,
#   DMSO_24T_1 = 4,
#   DMSO_24T_2 = 4,
#   DMSO_24T_3 = 4,
#   DMSO_24T_4 = 4,
#   DMSO_24T_5 = 4,
#   DMSO_24T_6 = 4,
#   DMSO_24R_1 = 5,
#   DMSO_24R_2 = 5,
#   DMSO_24R_3 = 5,
#   DMSO_24R_4 = 5,
#   DMSO_24R_5 = 5,
#   DMSO_24R_6 = 5,
#   DMSO_144R_1 = 6,
#   DMSO_144R_2 = 6,
#   DMSO_144R_3 = 6,
#   DMSO_144R_4 = 6,
#   DMSO_144R_5 = 6,
#   DMSO_144R_6 = 6
# )
# #saveRDS(groupid, "data/new/groupidCormotif.RDS")
# 
# compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
# #saveRDS(compid, "data/new/compidCormotif.RDS")
```
##RUVs Cormotif TMM norm counts 
```{r RUVs Cormotif Test}

#raw counts file
counts <- readRDS("data/new/RUV/filt_counts_matrix.RDS")

#create a dgelist object from these counts
dge_test <- DGEList(counts = counts)
dim(dge_test$counts)
#14319 genes as normal, still contains replicate needed for RUVs

#apply TMM normalization to this DGElist object
dge_test_tmm <- calcNormFactors(object = dge_test, method = "TMM")
#this ran through just fine, must be something to do with applying TMM to normalized counts
dim(dge_test_tmm$counts)
#14319 genes as normal, still have the replicate so 42 cols
#this still has the entrez_id so I should probably make sure that this is carried down

#pass this TMM normalized DGElist into RUVs correction
colnames(dge_test_tmm) <- Metadata$Final_sample_name
dim(dge_test_tmm)
#14319 genes as normal


RUV_filt_counts_tmm <- dge_test_tmm$counts %>% 
  as.data.frame() 

Entrez_ID_tmm_RUV <- RUV_filt_counts_tmm$Entrez_ID
# saveRDS(Entrez_ID_tmm_RUV, "data/new/RUV/entrezID_tmm_RUV_list.RDS")

dim(RUV_filt_counts_tmm)
#14319 genes as normal, no need to add the filtering step as the counts are already filtered

#add in the annotation files
ind_num <- readRDS("data/new/ind_num.RDS")
annot <- read.csv("data/new/Metadata.csv")

#counts need to be integer values and in a numeric matrix
#note: the log transformation needs to be accounted for in the isLog argument in RUVs function.
counts_test_tmm <- as.matrix(RUV_filt_counts_tmm)
#saveRDS(counts_test_tmm, "data/new/RUV/counts_tmm_filtered.RDS")

# Create a DataFrame for the phenoData
phenoData <- DataFrame(annot)

# Now create the RangedSummarizedExperiment necessary for RUVs input
# looks like it did need both the phenodata and the counts.
set_tmm <- SummarizedExperiment(assays = counts_test_tmm, metadata = phenoData)
dim(set_tmm)
#14319 genes as before

# Generate a background matrix
# The column "Cond" holds the comparisons that you actually want to make. DOX_24, DMSO_24,5FU_24, DOX_3,etc.
scIdx <-RUVSeq::makeGroups(phenoData$Condition)
scIdx

#now run through RUV correction with my tmm normalized data to generate normalized counts
set1_tmm <- RUVSeq::RUVs(x = counts_test_tmm, k =1, scIdx = scIdx, isLog = FALSE)
dim(set1_tmm$normalizedCounts)
#14319 genes as before, still containing the replicate individual

#saveRDS(set1_tmm, "data/new/RUV/set1_TMMnorm_RUVsk1_normcounts.RDS")

#make a df of the data for Cormotif?
RUV_df1_tmm <- set1_tmm$W %>% as.data.frame()
RUV_df1_tmm$Names <- rownames(RUV_df1_tmm)

#ensure that the names match across samples
RUV_df_rm1_tmm <- RUV_df1_tmm[RUV_df1_tmm$Names %in% annot$Final_sample_name, ] 
RUV_1_tmm <-  RUV_df_rm1_tmm$W_1

#now that I've passed my TMM normalized counts into the set_tmm, proceed to Cormotif

#####Cormotif Data Setup#####
set1_tmm <- readRDS("data/new/RUV/set1_TMMnorm_RUVsk1_normcounts.RDS")
NormCounts_RUV_rep <- as.data.frame(set1_tmm$normalizedCounts)

#read in my metadata sheet that I'll use as the standard for labelling
#this one already has the replicate individual removed
Metadata_2 <- readRDS("data/new/Metadata_2_norep.RDS")

#I'll have to remove the replicate at this stage so I can properly run Cormotif
NormCounts_RUV <- NormCounts_RUV_rep %>% 
  dplyr::select(-(contains("6R")))
#14319 genes and 36 columns, the right size matrix for Cormotif

#now ensure the column names match the original dge$counts with Sample_name
colnames(NormCounts_RUV) <- Metadata_2$Sample_name
rownames(NormCounts_RUV) <- Entrez_ID_tmm_RUV

#now cpm the cormotif matrix you're going to use
##this should be tmm normalized log2cpm at the end for going into Cormotif
cmf_test <- cpm(NormCounts_RUV, log = TRUE)
colnames(cmf_test) <- (Metadata_2$Final_sample_name)

cmf_counts <- dge_test_tmm$counts %>% 
  as.data.frame() %>% 
  dplyr::select(-(contains("6R")))

cmf_test_df <- cmf_test %>% 
  as.data.frame() %>% 
  rownames_to_column(., var = "Entrez_ID")

#write.csv(x = cmf_test, file = "data/new/RUV/cormotif_test_matrix_TMMnorm.csv")

#reorder my test matrix to match the new groupid I've made
#I want my columns to be in this order:
#DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
Cormotif_ruv <- read.csv("data/new/RUV/Cormotif_RUV_final.csv")
dim(Cormotif_ruv)
#14319 genes across 37 cols (1 is Entrez_ID)
Cormotif_ruv_df <- data.frame(Cormotif_ruv)

rownames(Cormotif_ruv_df) <- Cormotif_ruv_df$Entrez_ID
exprs.cmf_ruv <- as.matrix(Cormotif_ruv_df[,2:37])
dim(exprs.cormotif)
#14319 genes in 36 columns, set up for plugging into Cormotif

#now I need to set up my groupid and compid accordingly

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_csv <- read.csv("data/new/GroupID.csv")
#now I have to make this into a vector (named vector)?
groupid <- c(
  DOX_24T_1 = 1, 
  DOX_24T_2 = 1, 
  DOX_24T_3 = 1, 
  DOX_24T_4 = 1, 
  DOX_24T_5 = 1, 
  DOX_24T_6 = 1,
  DOX_24R_1 = 2, 
  DOX_24R_2 = 2, 
  DOX_24R_3 = 2, 
  DOX_24R_4 = 2, 
  DOX_24R_5 = 2, 
  DOX_24R_6 = 2,
  DOX_144R_1 = 3, 
  DOX_144R_2 = 3, 
  DOX_144R_3 = 3, 
  DOX_144R_4 = 3, 
  DOX_144R_5 = 3, 
  DOX_144R_6 = 3,
  DMSO_24T_1 = 4, 
  DMSO_24T_2 = 4, 
  DMSO_24T_3 = 4, 
  DMSO_24T_4 = 4, 
  DMSO_24T_5 = 4, 
  DMSO_24T_6 = 4,
  DMSO_24R_1 = 5, 
  DMSO_24R_2 = 5, 
  DMSO_24R_3 = 5, 
  DMSO_24R_4 = 5, 
  DMSO_24R_5 = 5, 
  DMSO_24R_6 = 5,
  DMSO_144R_1 = 6, 
  DMSO_144R_2 = 6, 
  DMSO_144R_3 = 6, 
  DMSO_144R_4 = 6, 
  DMSO_144R_5 = 6, 
  DMSO_144R_6 = 6
)
#saveRDS(groupid, "data/new/groupidCormotif.RDS")

compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
#saveRDS(compid, "data/new/compidCormotif.RDS")
compid_cmf <- readRDS("data/new/compidCormotif.RDS")
```
###Run Cormotif RUVs TMM Norm Counts
```{r RUVs Cormotif Run}
#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE
# 
# motif.fitted_ruv <- cormotiffit(
#   exprs = exprs.cmf_ruv,
#   groupid = groupid_csv,
#   compid = compid_cmf,
#   K = 1:10,
#   max.iter = 1000,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fitted_RUV, "data/new/RUV/motif.fitted_ruv_250624.RDS")
motif.fitted_RUV <- readRDS("data/new/RUV/motif.fitted_ruv_250624.RDS")

```
###Plot TMM Norm Counts RUVs Cormotif
```{r RUVs Cormotif Plots}

#plot BIC and AIC to see which number of motifs was best for both models
plotIC(motif.fitted_RUV)

motif.fitted_RUV$bic

#now plot the motifs themselves
plotMotif(motif.fitted_RUV, title = "Fitted Motifs for DXR RUVs")

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

##Cormotif RUVs no TMM
```{r RUVs Plot Cormotif no TMM}
#plot the AIC and BIC (we're interested in the Bayesian most of all)
# plotIC(motif.fit_RUV)
# 
# #visual check of the lowest BIC
# motif.fit_RUV$bic
# 
# #plot the motifs
# plotMotif(motif.fit_RUV)
# 
# #plot the probability legend
# myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))
# 
# plot.new()
# legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

##RUVs Cormotif log2 of Norm Counts
```{r RUVs Cormotif log2 Norm Counts}

# lognormcounts_CMF_rep <- as.matrix(set1$normalizedCounts)
# lognormcounts_CMF <- log2(lognormcounts_CMF_rep + 1)
# #add a pseudocount to ensure any values are not negative or zero
# 
# #first want to cut out the replicate samples as not needed for Cormotif
# lognormcounts_CMF <- as.data.frame(lognormcounts_CMF) %>% 
#   dplyr::select(-(contains("6R"))) %>% 
#   as.matrix()
# 
# #14319 genes in 36 columns, set up for plugging into Cormotif
# 
# #now I need to set up my groupid and compid accordingly
# 
# #put together my group id and comparison id to make the correct comparisons between experimental conditions
# 
# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control
# 
# groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")
# 
# #now put together your compid
# compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))

```

###Run Cormotif log2 normalized counts RUVs
```{r RUVs Cormotif log2 normalized counts Run}
#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fit_RUV_log2 <- cormotiffit(
#   exprs = lognormcounts_CMF,
#   groupid = groupid_other,
#   compid = compid1,
#   K = 1:8,
#   max.iter = 500,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

#Warning: Zero sample variances detected, have been offset away from zero#

# saveRDS(motif.fit_RUV_log2, "data/new/RUV/motif.fit_RUVnormcounts_log2NC_250629.RDS")
# motif.fit_RUV_log2 <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2NC_250629.RDS")

```

###Plot RUVs Cormotif log2norm counts
```{r RUVs Plot Cormotif log2 of normcounts}
# #plot the AIC and BIC (we're interested in the Bayesian most of all)
# plotIC(motif.fit_RUV_log2)
# 
# #visual check of the lowest BIC
# motif.fit_RUV_log2$bic
# 
# #plot the motifs
# plotMotif(motif.fit_RUV_log2, title = "Log2 RUVs Norm Counts")
# 
#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```
##Cormotif Log2cpm of Normalized Counts RUVs
```{r RUVs Cormotif log2cpm norm counts}
#since both the TMM normalized norm counts and the cpm norm counts are giving me issues:
#I am going to try this with just the log2 of the normalized counts from RUVs

lognormcounts_CMF_rep <- as.matrix(set1$normalizedCounts)
lognormcounts_CMF_cpm <- cpm(lognormcounts_CMF_rep + 1, log = TRUE)
#add a pseudocount to ensure any values are not negative or zero

#first want to cut out the replicate samples as not needed for Cormotif
lognormcounts_CMF_cpm <- as.data.frame(lognormcounts_CMF_cpm) %>% 
  dplyr::select(-(contains("6R"))) %>% 
  as.matrix()
#14319 genes in 36 cols

#write.csv(x = logNC_CMF_RUV, file = "data/new/RUV/Cormotif_log2normcounts_RUV_matrix.csv")

#14319 genes in 36 columns, set up for plugging into Cormotif

#now I need to set up my groupid and compid accordingly

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")

#now I have to make this into a vector (named vector)?

compid <- data.frame(Cond1 = c(1, 3, 5), Cond2 = c(2, 4, 6))
compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))


```


###Run Cormotif log2cpm Norm Counts RUVs
```{r RUVs Run Cormotif log2cpm normcounts}

#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fit_RUV_logNC <- cormotiffit(
#   exprs = lognormcounts_CMF_cpm,
#   groupid = groupid_other,
#   compid = compid1,
#   K = 1:8,
#   max.iter = 500,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fit_RUV_logNC, "data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")
motif.fit_RUV_logNC_cpm <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")

```

###Plot Cormotif log2cpm Norm Counts RUVs
```{r RUVs Plot Cormotif log2cpm normcounts}
#plot the AIC and BIC (we're interested in the Bayesian most of all)
plotIC(motif.fit_RUV_logNC_cpm)

# bic_aic_file <- file.path(output_folder, "CMF_BIC_AIC_EMP_251022.pdf")
# cairo_pdf(bic_aic_file, width = 6, height = 4)
# plotIC(motif.fit_RUV_logNC_cpm)
# dev.off()

#visual check of the lowest BIC
motif.fit_RUV_logNC_cpm$bic

#plot the motifs
plotMotif(motif.fit_RUV_logNC_cpm)

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

#Log2cpm Norm Counts Cormotif Downstream Analysis
```{r Cormotif log2cpm Norm Counts clustlike + p.post}

#extract the posterior probability that these genes belong to motifs
gene_prob_all_RUV <- motif.fit_RUV_logNC_cpm$bestmotif$p.post
rownames(gene_prob_all_RUV) <- rownames(lognormcounts_CMF_cpm)

#assign each gene to a motif with max post prob
assigned_motifs_RUV <- apply(gene_prob_all_RUV, 1, which.max)
max_probs_RUV <- apply(gene_prob_all_RUV, 1, max)

#combine these into a dataframe - motif assigned genes (p.post)
motif_assignment_df_RUV <- gene_prob_all_RUV %>%
  as.data.frame() %>%
  rownames_to_column("Gene") %>%
  mutate(
    Assigned_Motif = assigned_motifs_RUV[Gene],
    Max_Probability = max_probs_RUV[Gene]
  )

#make some histograms of the unfiltered data from Cormotif p.post

gene_prob_all_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post RUV M1")

gene_prob_all_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post RUV M2")


#extract the cluster likelihood - which DEGs are most likely to be in this cluster
motif_prob_RUV <- motif.fit_RUV_logNC_cpm$bestmotif$clustlike
rownames(motif_prob_RUV) <- rownames(gene_prob_all_RUV)
# write.csv(motif_prob_RUV,"data/new/cormotif_probability_genelist_all_RUV_log2cpm_NormCounts.csv")

#make some histograms to look at the distribution of clustlike genes without filtering
motif_prob_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M1")

motif_prob_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M2")


```

##P.post and Clustlike Together log2cpm norm counts Cormotif RUV
```{r Use p.post and clustlike together}
#begin with the clustlike cutoffs and then overlay the p.post to check if the genes are present in both

#these filters are the combination of the above analysis to get a gene set that fits in both p.post and clustlike

####motif 1####
#filter 1: clustlike
clust1_genes_RUV <- 
  motif_prob_RUV %>%
  as.data.frame() %>%
  filter(V1>0.8 & V2<0.5) %>% 
  rownames
length(clust1_genes_RUV)
#13600 genes

### Filter 2: Gene-level posterior pattern
prob_filtered_genes_1_RUV <- rownames(gene_prob_all_RUV[(gene_prob_all_RUV[,1] >0.05 & gene_prob_all_RUV[,1] <0.5 & gene_prob_all_RUV[,2] <0.5 & gene_prob_all_RUV[,3] <0.5),])
### Final intersection of both filters
final_genes_1_RUV <- intersect(clust1_genes_RUV, prob_filtered_genes_1_RUV)
cat("Number of genes passing both filters:", length(final_genes_1_RUV), "\n")
#7602 genes pass both filters here

####motif 2####
#filter 1: clustlike
clust2_genes_RUV <- motif_prob_RUV %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5) %>% 
  rownames

length(clust2_genes_RUV)
#517 genes

### Filter 2: Gene-level posterior pattern
prob_filtered_genes_2_RUV <- rownames(gene_prob_all_RUV[(gene_prob_all_RUV[,1] >0.3 & gene_prob_all_RUV[,2] >0.5 & gene_prob_all_RUV[,3] >0.5),])
### Final intersection of both filters
final_genes_2_RUV <- intersect(clust2_genes_RUV, prob_filtered_genes_2_RUV)
cat("Number of genes passing both filters:", length(final_genes_2_RUV), "\n")

#501 genes pass both filters here

#what is the proportion of my genes that are included?
#p.post and clustlike together
7602+501
#8103
(8103/14319)*100
#56.59% of my genes are represented here out of the 14319 original

#what is the proportion of my genes that are included?
#clustlike only
13600+517
#14117
(14117/14319)*100
#98.6% of my genes are included with clustlike only
#want to find out which genes are not assigned to motifs

final_genes_list_RUV <- union(final_genes_1_RUV, final_genes_2_RUV)
length(final_genes_list_RUV)
#8103 genes as found above
initial_genes_list_RUV <- rownames(lognormcounts_CMF_cpm)
length(initial_genes_list_RUV)
#14319 genes as usual

unassigned_genes_list_RUV <- setdiff(initial_genes_list_RUV, final_genes_list_RUV)
length(unassigned_genes_list_RUV)
#6216 genes not assigned

final_genes_list_clustlike_RUV <- union(clust1_genes_RUV, clust2_genes_RUV)
length(final_genes_list_clustlike_RUV)
#14117 genes as above with clustlike only

unassigned_genes_list_RUV_clustlike <- setdiff(initial_genes_list_RUV, final_genes_list_clustlike_RUV)
length(unassigned_genes_list_RUV_clustlike)
#202 genes not assigned

# saveRDS(unassigned_genes_list_RUV, "data/new/RUV/CMF/unassigned_genes_RUVlog2cpm_NormCounts_Cormotif.RDS")

# saveRDS(unassigned_genes_list_RUV_clustlike, "data/new/RUV/CMF/unassigned_genes_clustlike_RUVslog2cpm_NormCounts_Cormotif.RDS")

#now, ensure that none of these genes are shared amongst categories
vennCor_final_RUV <- list(final_genes_1_RUV, final_genes_2_RUV)
ggVennDiagram(
  vennCor_final_RUV,
  category.names = c("M1", "M2")
) + ggtitle("Cormotif DEGs clustlike + p.post RUVs log2cpm NC")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

vennCor_final_RUV_clust <- list(clust1_genes_RUV, clust2_genes_RUV)
ggVennDiagram(
  vennCor_final_RUV_clust,
  category.names = c("M1", "M2")
) + ggtitle("Cormotif DEGs clustlike RUVs log2cpm NC")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#no overlapping genes found in these gene sets

clusterdata_dxr_fin_RUV <- data.frame(
  Category = c("Motif 1", "Motif 2"), 
  Value = c(length(final_genes_1_RUV), length(final_genes_2_RUV)
))

clusterdata_dxr_fin_RUV_clust <- data.frame(
  Category = c("Motif 1", "Motif 2"), 
  Value = c(length(clust1_genes_RUV), length(clust2_genes_RUV)
))


piecolors_dxr_fin <- c("Motif 1" = "#089992", 
                       "Motif 2" = "#99599D")

#make this into a barplot
clusterdata_dxr_fin_RUV <- clusterdata_dxr_fin_RUV %>%
  mutate(Prop = Value / sum(Value) * 100)

clusterdata_dxr_fin_RUV <- clusterdata_dxr_fin_RUV %>%
  mutate(Category = factor(Category, levels = c("Motif 2", "Motif 1"))) %>%
  mutate(Prop = Value / sum(Value) * 100)

# stacked bar with no axes
ggplot(clusterdata_dxr_fin_RUV, aes(x = "", y = Value, fill = Category)) +
  geom_bar(stat = "identity", width = 0.6) +
  geom_text(aes(label = paste0(Value, " (", round(Prop, 1), "%)")),
            position = position_stack(vjust = 0.5),
            size = 4, color = "white") +
  labs(title = "Distr of Gene Clusters Cormotif RUVs clustlike + p.post") +
  scale_fill_manual(values = piecolors_dxr_fin) +
  theme_void() +
  theme(legend.title = element_blank(),
        plot.title = element_text(hjust = 0.5))

#make a piechart of these distributions
clusterdata_dxr_fin_RUV %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distr of Gene Clusters Cormotif RUVs clustlike + p.post", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors_dxr_fin)

clusterdata_dxr_fin_RUV_clust %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distr of Gene Clusters Cormotif RUVs clustlike", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors_dxr_fin)

#now, continue by plotting the logFC of all of these gene sets per motif, as well as look at some random genes for log2cpm to see if the patterns are reflected in the example genes

# saveRDS(final_genes_1_RUV, "data/new/RUV/CMF/final_genes_1_RUV.RDS")
# saveRDS(final_genes_2_RUV, "data/new/RUV/CMF/final_genes_2_RUV.RDS")

final_genes_1_RUV <- readRDS("data/new/RUV/CMF/final_genes_1_RUV.RDS")
final_genes_2_RUV <- readRDS("data/new/RUV/CMF/final_genes_2_RUV.RDS")

# write.csv(final_genes_1_RUV, "data/new/RUV/CMF/Recovered_genes_RUV.csv")
# write.csv(final_genes_2_RUV, "data/new/RUV/CMF/Sustained_genes_RUV.csv")

```


```{r Gene Symbols CMF RUV final set}

#I want to add in the gene symbol names for my Motif 1 and Motif 2 gene sets
#final sets are saved in data/new/RUV/CMF in csv format (keep this code for posterity)

#Recovered Motif 1 Genes vector
# rec_m1_genes <- final_genes_1_RUV

#map my Entrez_ID to SYMBOL
# mapped_genes_rec <- AnnotationDbi::select(org.Hs.eg.db,
#                                       keys = rec_m1_genes,
#                                       columns = c("SYMBOL"),
#                                       keytype = "ENTREZID")

#remove duplicates if necessary
# mapped_genes_rec <- unique(mapped_genes_rec)

#check the number of genes (should be 7602)
# dim(mapped_genes_rec)
#7602 genes

#save to CSV
# write.csv(mapped_genes_rec, "data/new/RUV/CMF/Recovered_M1_genes_clustlike_ppost_RUV_EMP_250828.csv", row.names = FALSE)


#Sustained Motif 2 Genes vector
# sus_m2_genes <- final_genes_2_RUV

#map my Entrez_ID to SYMBOL
# mapped_genes_sus <- AnnotationDbi::select(org.Hs.eg.db,
#                                       keys = sus_m2_genes,
#                                       columns = c("SYMBOL"),
#                                       keytype = "ENTREZID")

#remove duplicates if necessary (unlikely to have any)
# mapped_genes_sus <- unique(mapped_genes_sus)

#check the number of genes (should be 501)
# dim(mapped_genes_sus)
#501 genes

#save to CSV
# write.csv(mapped_genes_sus, "data/new/RUV/CMF/Sustained_M2_genes_clustlike_ppost_RUV_EMP_250828.csv", row.names = FALSE)

mapped_genes_sus <- read.csv("data/new/RUV/CMF/Sustained_M2_genes_clustlike_ppost_RUV_EMP_250828.csv")


```


###clustlike RUVs log2cpm Norm Counts RUVs logFC
```{r logFC Cormotif log2cpm Norm Counts RUVs Plot}
####clustlike + p.post logFC of initial set####

##motif 1
length(final_genes_1_RUV)
##motif 2 
length(final_genes_2_RUV)

#read in my toptables from pairwise analysis
Toptable_RUV_24T <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv")
Toptable_RUV_24R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv")
Toptable_RUV_144R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv")

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr_RUV <- Toptable_RUV_24T %>% 
  dplyr::select(-(X)) %>% 
  mutate(Time = "24T")

d24r_toptable_dxr_RUV <- Toptable_RUV_24R %>% 
  dplyr::select(-(X)) %>% 
  mutate(Time = "24R")

d144r_toptable_dxr_RUV <- Toptable_RUV_144R %>% 
  dplyr::select(-(X)) %>% 
  mutate(Time = "144R")

#combine your toptables together and then select the columns I want
combined_toptables_dxr_RUV <- bind_rows(
  d24_toptable_dxr_RUV,
  d24r_toptable_dxr_RUV,
  d144r_toptable_dxr_RUV)

# saveRDS(combined_toptables_dxr_RUV, "data/new/RUV/combined_toptables_RUVs.RDS")

#Filter the data based on each motif
filt_toptable_dxr_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_1_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC Motif 1 RUVs clustlike + p.post (n=7602)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_2_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC Motif 2 RUVs clustlike + p.post (n=501)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))


#plots
filt_toptable_dxr_fin_RUV
filt_toptable_2_dxr_fin_RUV 


#now plot the abs logFC for each of these too
filt_toptable_abs_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_1_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC Motif 1 RUVs clustlike + p.post (n=7602)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_2_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC Motif 2 RUVs clustlike + p.post (n=501)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))


#plots
filt_toptable_abs_fin_RUV
filt_toptable_2_abs_fin_RUV


# ####Now do this but have it for the clustlike only genes
# ##motif 1
# length(clust1_genes_RUV)
# #13600
# ##motif 2 
# length(clust2_genes_RUV)
# #517 genes
# 
# #Filter the data based on each motif
# filt_toptable_dxr_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust1_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = logFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("logFC")+
#   theme_bw()+
#   ggtitle("LogFC Motif 1 RUVs clustlike (n=13600)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# #motif 2
# filt_toptable_2_dxr_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust2_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = logFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("logFC")+
#   ggtitle("LogFC Motif 2 RUVs clustlike (n=517)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# 
# #plots
# filt_toptable_dxr_fin_RUV_clust
# filt_toptable_2_dxr_fin_RUV_clust
# 
# 
# #now plot the abs logFC for each of these too
# filt_toptable_abs_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust1_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = absFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("|logFC|")+
#   theme_bw()+
#   ggtitle("Abs LogFC Motif 1 RUVs clustlike (n=13600)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# #motif 2
# filt_toptable_2_abs_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust2_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = absFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("|logFC|")+
#   theme_bw()+
#   ggtitle("Abs LogFC Motif 2 RUVs clustlike (n=517)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# 
# #plots
# filt_toptable_abs_fin_RUV_clust
# filt_toptable_2_abs_fin_RUV_clust


```

##Line Plot logFC/abslogFC top 100 genes by motif RUVs log2cpm NC
```{r LogFC line plot top 100 genes per motif}
#I want to plot the top 100 genes per motif by adj p value and see their median logFC and abs logFC
#I then want to plot these across all timepoints to get the logFC over time

#load in my motif sets
##motif 1 - recovered
length(final_genes_1_RUV)
##motif 2 - sustained
length(final_genes_2_RUV)

#load in my combined toptables from limma
combined_toptables_dxr_RUV <- readRDS("data/new/RUV/combined_toptables_RUVs.RDS")

#create a toptable with all of the genes marked by motif 1 or motif 2
filt_toptable_motifgenes_RUV <- combined_toptables_dxr_RUV %>% 
  mutate(motif = case_when(
    Entrez_ID %in% final_genes_1_RUV ~ "M1",
    Entrez_ID %in% final_genes_2_RUV ~ "M2",
    TRUE ~ NA_character_
  )) %>% 
  dplyr::filter(!is.na(motif)) %>% 
  dplyr::filter(!is.na(SYMBOL)) %>% 
  mutate(time = factor(Time, 
                       levels = c("24T", "24R", "144R"))) %>% 
  mutate(absFC = abs(logFC))

#slice top 100 genes per motif by adj p value
top_100_motifgenes <- filt_toptable_motifgenes_RUV %>%
  filter(motif %in% c("M1", "M2")) %>%
  group_by(motif, Entrez_ID) %>%
  summarize(min_adjP = min(adj.P.Val), groups = "drop") %>% 
  arrange(motif, min_adjP) %>%
  group_by(motif) %>%
  slice_head(n = 100)

#now I have the top 100 genes in each motif based on adj. p value
#I want to be able to plot 200 lines that span all three timepoints

plot_top100_motifgenes <- filt_toptable_motifgenes_RUV %>% 
  semi_join(top_100_motifgenes, by = c("Entrez_ID", "motif"))


#now I've made a group of 600 genes, taking the top 100 genes for each motif and pulling them out at each timepoint
dim(plot_top100_motifgenes)

#calculate the median logFCs for each motif out of ALL genes
medians_allgenes_RUV <- filt_toptable_motifgenes_RUV %>% 
  group_by(motif, time) %>% 
  summarise(median_logFC = median(logFC), 
            median_abslogFC = median(absFC),
            .groups = "drop")

print(medians_allgenes_RUV)

#now that I've found the median for both logFC and abslogFC over time, plot the line graphs

#specify colors
motif_cols <- c("M1" = "#c998d9",
                "M2" = "#7dd67d")

med_cols <- c("M1" = "#c998d9",
              "M2" = "#7dd67d")

#plot logFC
labs_logFC_top100 <- medians_allgenes_RUV %>%
  group_by(motif) %>%
  mutate(label = paste0(
    motif, "\nmedian logFC =\n",
    paste0(time, "=", round(median_logFC, 2), collapse = "\n")
  ), .groups = "drop") %>%
  pull(label)

names(labs_logFC_top100) <- c("M1", "M1", "M1", "M2", "M2", "M2")

#retain the two correct motifs
labs_logFC_top100 <- labs_logFC_top100[c(1,4)]


plot_motifs100_logFC <- 
  ggplot() +
  geom_line(data = plot_top100_motifgenes,
            aes(x = time, y = logFC, group = Entrez_ID, color = motif),
            alpha = 0.4, size = 0.9) +
  geom_line(data = medians_allgenes_RUV %>% 
              dplyr::filter(motif == "M1"),
            aes(x = time, y = median_logFC, 
                group = motif),
            color = "#c998d9", size = 2) +
  geom_line(data = medians_allgenes_RUV %>% 
              dplyr::filter(motif == "M2"),
            aes(x = time, y = median_logFC, 
                group = motif),
            color = "#7dd67d", size =2) +
  scale_color_manual(values = c(motif_cols),
                     labels = labs_logFC_top100) +
  labs(title = "logFC Top 100 Genes by Motif",
       y = "logFC", x = "Time", color = "Motif") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right")

plot_motifs100_logFC

#plot abs logFC now
labs_abslogFC_top100 <- medians_allgenes_RUV %>%
  group_by(motif) %>%
  mutate(label = paste0(
    motif, "\nmedian |logFC| =\n",
    paste0(time, "=", round(median_abslogFC, 2), collapse = "\n")
  ), .groups = "drop") %>%
  pull(label)

names(labs_abslogFC_top100) <- c("M1", "M1", "M1", "M2", "M2", "M2")

#retain the two correct motifs
labs_abslogFC_top100 <- labs_abslogFC_top100[c(1,4)]


plot_motifs100_abslogFC <- 
  ggplot() +
  geom_line(data = plot_top100_motifgenes,
            aes(x = time, y = absFC, group = Entrez_ID, color = motif),
            alpha = 0.4, size = 0.9) +
  geom_line(data = medians_allgenes_RUV %>% 
              dplyr::filter(motif == "M1"),
            aes(x = time, y = median_abslogFC, group = motif),
            color = "#c998d9", size = 2) +
  geom_line(data = medians_allgenes_RUV %>%
              dplyr::filter(motif == "M2"),
            aes(x = time, y = median_abslogFC, group = motif),
            color = "#7dd67d", size =2) +
  scale_color_manual(values = c(motif_cols),
                     labels = labs_abslogFC_top100) +
  labs(title = "|logFC| Top 100 Genes by Motif",
       y = "|logFC|", x = "Time", color = "Motif") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right")

plot_motifs100_abslogFC


```
#line plot Motifs
```{r Top 100 genes by Motif}


```



Now do this but with only the sustained response genes (M2)
```{r logFC line plot sustained}
#I want to plot all of the sustained M2 genes in a line plot
#No need to slice, include all 501 genes and the median

plot_M2_allgenes <- filt_toptable_motifgenes_RUV %>% 
  dplyr::filter(motif == "M2")

# Calculate medians for ALL motif 2 genes across timepoints
medians_motif2_RUV <- plot_M2_allgenes %>%
  group_by(time) %>%
  summarise(
    median_logFC = median(logFC),
    median_abslogFC = median(absFC),
    .groups = "drop"
  )

# Label with median values
labs_logFC_motif2 <- paste0(
  "M2\nmedian logFC =\n",
  paste0(medians_motif2_RUV$time, "=", round(medians_motif2_RUV$median_logFC, 2), collapse = "\n")
)

# Plot all lines for motif 2 genes
plot_motif2_logFC <- ggplot() +
  geom_line(data = plot_M2_allgenes,
            aes(x = time, y = logFC, group = Entrez_ID),
            color = "#83C67C", alpha = 0.4, linewidth = 0.9) +
  geom_line(data = medians_motif2_RUV,
            aes(x = time, y = median_logFC, group = 1),
            color = "black", linewidth = 2) +
  scale_color_manual(values = c("M2" = "#83C67C"),
                     labels = labs_logFC_motif2) +
  labs(title = "log2FC Sustained Genes (n = 501)",
       y = "log2FC", x = "Time", color = "Motif") +
  theme_custom() +
  theme(legend.position = "right")

plot_motif2_logFC

save_plot(plot = plot_motif2_logFC,
          filename = "Motif2_logFC_Supp_EMP",
          folder = output_folder,
          height = 3,
          width = 3)

```

#Top 100 Motif Genes by Clustlike
```{r Recovered vs Sustained top100}
motif.fit_RUV_logNC_cpm <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")

clust_mat_100 <- motif.fit_RUV_logNC_cpm$bestmotif$clustlike

row.names(clust_mat_100) <- row.names(lognormcounts_CMF_cpm)
cmf_logNC_cpm <- clust_mat_100 %>% 
  as.data.frame() %>% 
  rownames_to_column("Entrez_ID") %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

cmf_sets <- list(
  Set1="V1",
  Set2="V2")

#read in my toptables combined in a list of lists
combined_toptables_dxr_RUV <- readRDS("data/new/RUV/combined_toptables_RUVs.RDS") %>% 
  as.data.frame(.,) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

#make a dataframe and classify genes by motif, remove unassigned genes
Sets_cmf_cpmNC <- combined_toptables_dxr_RUV %>% 
  mutate(
    motif = case_when(
      Entrez_ID %in% final_genes_1_RUV ~ "M1",
      Entrez_ID %in% final_genes_2_RUV ~ "M2",
      TRUE ~ "not_assigned")) %>% 
  left_join(., cmf_logNC_cpm, by=c("Entrez_ID")) %>% 
  dplyr::filter(motif!="not_assigned") %>% 
  mutate(Time = factor(Time, 
                       levels = c("24T", "24R", "144R"))) %>% 
  mutate(absFC = abs(logFC))

#compute the median across timepoints for all genes assigned to M1 or M2

#make a function to slice the top 100 genes by cluster likelihood per motif
# get_top100_cmf_cpmNC <- function(motif_name, clust_col) {
#   Sets_cmf_cpmNC %>% 
#     dplyr::filter(motif == motif_name) %>% 
#     slice_max(order_by = .data[[clust_col]], n = 100)
# }
# 
# #top 100 for each motif 
# top100_rec <- get_top100_cmf_cpmNC("M1", "V1")
# top100_sus <- get_top100_cmf_cpmNC("M2", "V2")

top100_rec <- Sets_cmf_cpmNC %>% 
  dplyr::filter(motif == "M1") %>% 
  slice_max(order_by = V1, n = 100)



#combine these together into one dataframe
top100_all <- bind_rows(top100_M1, top100_M2)

plot_df_cpmNC <- top_100_all %>% 
  pivot_longer(
    cols = c("24T", 
             "24R",
             "144R"),
    names_to = "Time",
    values_to = "logFC"
  ) %>% 
  mutate(
    Time = factor(Time, levels = c("24T", "24R", "144R")),
    absFC = abs(logFC)
  )


#calculate the median of all genes not just the top 100 per motif
median_allgenes_cpmNC <- Sets_cmf_cpmNC %>% 
  pivot_longer(
    cols = c("24T", "24R", "144R"),
    names_to = "Time",
    values_to = "logFC"
  ) %>% 
  mutate(
    Time = factor(Time, levels = c("24T", "24R", "144R")),
    absFC = abs(logFC)
  ) %>% 
  group_by(motif, Time) %>% 
  summarize(
    median_logFC = median(logFC, na.rm = TRUE),
    median_absFC = median(absFC, na.rm = TRUE),
    .groups = "drop"
  )

#now that I have the top 100 genes and the medians of all genes, let's plot them together

mtf_cols <- c("M1" = "#C998D9", 
              "M2" = "#7DD67D")

#logFC first
p_logFC <- ggplot(plot_df, aes(x = time, y = logFC, group = Entrez_ID, color = motif)) +
  geom_line(alpha = 0.3) +
  geom_line(
    data = medians_allgenes_RUV,
    aes(x = time, y = median_logFC, group = motif, color = motif),
    linewidth = 1.2
  ) +
  scale_color_manual(values = motif_cols) +
  facet_wrap(~motif, scales = "free_y") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Top 100 motif genes with median trajectory - logFC",
       x = "Timepoint", y = "logFC")

# absFC
p_absFC <- ggplot(plot_df, aes(x = time, y = absFC, group = Entrez_ID, color = motif)) +
  geom_line(alpha = 0.3) +
  geom_line(
    data = medians_allgenes_RUV,
    aes(x = time, y = median_absFC, group = motif, color = motif),
    linewidth = 1.2
  ) +
  scale_color_manual(values = motif_cols) +
  facet_wrap(~motif, scales = "free_y") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Top 100 motif genes with median trajectory - absFC",
       x = "Timepoint", y = "absFC")

p_logFC
p_absFC

saveRDS(p_logFC, "data/new/RUV/logFC_lineplot_motifs.RDS")
saveRDS(p_absFC, "data/new/RUV/abslogFC_lineplot_motifs.RDS")
```


#top100 motif genes clustlike
```{r M1 vs M2 cleaned up version of above}
#load in my clustlike matrix

# 1. Load clustlike matrix
motif.fit_RUV_logNC_cpm <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")
clust_mat_100 <- motif.fit_RUV_logNC_cpm$bestmotif$clustlike

# Ensure row names match gene IDs
row.names(clust_mat_100) <- row.names(lognormcounts_CMF_cpm)
cmf_logNC_cpm <- clust_mat_100 %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Entrez_ID") %>%
  dplyr::mutate(Entrez_ID = as.character(Entrez_ID))

#Load combined toptables and classify genes
# combined_toptables_dxr_RUV <- dplyr::bind_rows(combined_toptables_dxr_RUV) %>%
#   mutate(
#     Entrez_ID = as.character(Entrez_ID),
#     Time = case_when(
#       Time == "24T"  ~ "t0",
#       Time == "24R"  ~ "t24",
#       Time == "144R" ~ "t144",
#       TRUE ~ NA_character_
#     )
#   )

combined_toptables_dxr_RUV <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/Combined_toptables_timepoint_dataframe.RDS")

Sets_cmf_cpmNC <- combined_toptables_dxr_RUV %>%
  dplyr::mutate(
    motif = dplyr::case_when(
      Entrez_ID %in% final_genes_1_RUV ~ "M1",
      Entrez_ID %in% final_genes_2_RUV ~ "M2",
      TRUE ~ "not_assigned"
    )
  ) %>%
  dplyr::filter(motif != "not_assigned") %>%
  dplyr::left_join(., cmf_logNC_cpm, by = "Entrez_ID") %>%
  dplyr::mutate(
    Time = factor(Time, levels = c("24T", "24R", "144R")),
    absFC = abs(logFC)
  )

# 3. Compute top 100 unique genes per motif by clustlike
# Aggregate clustlike per gene first (one row per gene)
gene_scores <- Sets_cmf_cpmNC %>%
  dplyr::group_by(Entrez_ID, motif) %>%
  dplyr::summarize(
    score = ifelse(motif == "M1", max(V1, na.rm = TRUE), max(V2, na.rm = TRUE)),
    .groups = "drop"
  )

top100_M1 <- gene_scores %>%
  dplyr::filter(motif == "M1") %>%
  dplyr::slice_max(order_by = score, n = 100)

top100_M2 <- gene_scores %>%
  dplyr::filter(motif == "M2") %>%
  dplyr::slice_max(order_by = score, n = 100)

# Combine top 100 for plotting
top100_all <- dplyr::bind_rows(top100_M1, top100_M2)

# 4. Pull timepoint rows for top 100 genes
plot_df_cpmNC <- Sets_cmf_cpmNC %>%
  dplyr::semi_join(top100_all, by = c("Entrez_ID", "motif")) %>%
  dplyr::mutate(
    absFC = abs(logFC)
  )

# 5. Compute median of all genes (not just top 100)
median_allgenes_cpmNC <- Sets_cmf_cpmNC %>%
  dplyr::group_by(motif, Time) %>%
  dplyr::summarize(
    median_logFC = median(logFC, na.rm = TRUE),
    median_absFC = median(absFC, na.rm = TRUE),
    .groups = "drop"
  )

# 6. Plotting
motif_cols <- c("M1" = "#C998D9", "M2" = "#7DD67D")

# logFC
p_logFC <- ggplot(plot_df_cpmNC, aes(x = Time, y = logFC, group = Entrez_ID, color = motif)) +
  geom_line(alpha = 0.3) +
  geom_line(
    data = median_allgenes_cpmNC,
    aes(x = Time, y = median_logFC, group = motif, color = motif),
    linewidth = 1.2
  ) +
  scale_color_manual(values = motif_cols) +
  facet_wrap(~motif, scales = "free_y") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Top 100 motif genes with median trajectory - logFC", x = "Timepoint", y = "logFC")

# absFC
p_absFC <- ggplot(plot_df_cpmNC, aes(x = Time, y = absFC, group = Entrez_ID, color = motif)) +
  geom_line(alpha = 0.3) +
  geom_line(
    data = median_allgenes_cpmNC,
    aes(x = Time, y = median_absFC, group = motif, color = motif),
    linewidth = 1.2
  ) +
  scale_color_manual(values = motif_cols) +
  facet_wrap(~motif, scales = "free_y") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Top 100 motif genes with median trajectory - absFC", x = "Timepoint", y = "absFC")

p_logFC
p_absFC


#modify the plots to be on the same thing now that I know they look correct - so no faceting

# Combine top 100 genes and medians into one plot for logFC
plot_motifs100_logFC <- ggplot() +
  # Top 100 genes per motif
  geom_line(data = plot_df_cpmNC,
            aes(x = Time, y = logFC, group = Entrez_ID, color = motif),
            alpha = 0.6, size = 1) +
  # Median lines for M1
  geom_line(data = median_allgenes_cpmNC %>% dplyr::filter(motif == "M1"),
            aes(x = Time, y = median_logFC, group = motif),
            color = "#7B3F9E", size = 2) +
  # Median lines for M2
  geom_line(data = median_allgenes_cpmNC %>% dplyr::filter(motif == "M2"),
            aes(x = Time, y = median_logFC, group = motif),
            color = "#2E8B57", size = 2) +
  scale_color_manual(values = motif_cols) +
  labs(title = "log2FC Top 100 Genes by Motif",
       y = "log2FC", x = "Time", color = "Motif") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right")

plot_motifs100_logFC

# Combine top 100 genes and medians into one plot for absFC
plot_motifs100_abslogFC <- ggplot() +
  # Top 100 genes per motif
  geom_line(data = plot_df_cpmNC,
            aes(x = Time, y = absFC, group = Entrez_ID, color = motif),
            alpha = 0.4, size = 0.9) +
  # Median lines for M1
  geom_line(data = median_allgenes_cpmNC %>% dplyr::filter(motif == "M1"),
            aes(x = Time, y = median_absFC, group = motif),
            color = "#7B3F9E", size = 2) +
  # Median lines for M2
  geom_line(data = median_allgenes_cpmNC %>% dplyr::filter(motif == "M2"),
            aes(x = Time, y = median_absFC, group = motif),
            color = "#2E8B57", size = 2) +
  scale_color_manual(values = motif_cols) +
  labs(title = "|logFC| Top 100 Genes by Motif",
       y = "|logFC|", x = "Time", color = "Motif") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right")

plot_motifs100_abslogFC

#simple summary table at the end to show the median logFCs
median_summary_cpmNC <- median_allgenes_cpmNC %>%
  dplyr::select(motif, Time, median_logFC, median_absFC) %>%
  dplyr::arrange(motif, Time)

# View table
print(median_summary_cpmNC)

#save the absFC plot as a pdf and a png for later
cairo_pdf("data/new/RUV/CMF/abslogFC_lineplot_motifs_clustlike_EMP_250915.pdf", width = 8, height = 6)
print(plot_motifs100_abslogFC)
dev.off()

cairo_pdf("data/new/RUV/CMF/logFC_lineplot_motifs_clustlike_EMP_250915.pdf", width = 8, height = 6)
print(plot_motifs100_logFC)
dev.off()

#png file
ggsave("data/new/RUV/logFC_lineplot_motifs_clustlike_EMP_250915.png", p_logFC, width = 8, height = 6, dpi = 300)
ggsave("data/new/RUV/abslogFC_lineplot_motifs_clustlike_EMP_250915.png", p_absFC, width = 8, height = 6, dpi = 300)


```


###log2cpm Example Genes Cormotif RUVs log2cpm Norm Counts
```{r log2cpm Example Genes Cormotif log2cpm Norm Counts}
#use the final genes from cross-verifying with clustlike + p.post

#Load in my count matrices
#final_genes_1_RUV
#final_genes_2_RUV

#clust1_genes_RUV
#clust2_genes_RUV

#these are all the genes that are present in each category, make them into dataframes by filtering out the rest of the genes in my main boxplot df
boxplots_cormotif <- boxplot1

motif1_genes_fin_RUV <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_1_RUV,]
dim(motif1_genes_fin_RUV)
#7602 genes in 44 cols
motif2_genes_fin_RUV <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_2_RUV,]
dim(motif2_genes_fin_RUV)
#501 genes in 44 cols

#pull out some random genes for each using sample

m1_genes_fin_RUV <- motif1_genes_fin_RUV %>% dplyr::filter(SYMBOL == "ZMYND8")
  
  # motif1_genes_fin_RUV[sample(nrow(motif1_genes_fin_RUV), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes1_fin_RUV <- c(m1_genes_fin_RUV$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data_1_fin_RUV <- function(gene) {
  gene_data <- m1_genes_fin_RUV %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes1_fin_RUV) {
  gene_data <- process_gene_data_1_fin_RUV(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "Motif 1 RUVs")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 2#####

m2_genes_fin_RUV <- motif2_genes_fin_RUV %>% dplyr::filter(SYMBOL == "CCNB2")
  
  
  # motif2_genes_fin_RUV[sample(nrow(motif2_genes_fin_RUV), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes2_fin_RUV <- c(m2_genes_fin_RUV$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam2_fin_RUV <- function(gene) {
  gene_data <- motif2_genes_fin_RUV %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes2_fin_RUV) {
  gene_data <- process_gene_datam2_fin_RUV(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "Motif 2 RUVs")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```

##log2cpm Example Genes Cormotif clustlike

```{r log2cpm Example Genes Cormotif RUVs clustlike, include=FALSE}
#use the final genes from cross-verifying with clustlike + p.post

#Load in my count matrices

#clust1_genes_RUV
#clust2_genes_RUV

#these are all the genes that are present in each category, make them into dataframes by filtering out the rest of the genes in my main boxplot df
boxplots_cormotif <- boxplot1

motif1_genes_fin_RUV_clust <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% clust1_genes_RUV,]
dim(motif1_genes_fin_RUV_clust)
#13600 genes in 44 cols
motif2_genes_fin_RUV_clust <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% clust2_genes_RUV,]
dim(motif2_genes_fin_RUV_clust)
#517 genes in 44 cols

#pull out some random genes for each using sample

m1_genes_fin_RUV_clust <- motif1_genes_fin_RUV_clust[sample(nrow(motif1_genes_fin_RUV_clust), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes1_fin_RUV_clust <- c(m1_genes_fin_RUV_clust$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data_1_fin_RUV_clust <- function(gene) {
  gene_data <- m1_genes_fin_RUV_clust %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes1_fin_RUV_clust) {
  gene_data <- process_gene_data_1_fin_RUV_clust(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "M1 RUVs clustlike")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 2#####

m2_genes_fin_RUV_clust <- motif2_genes_fin_RUV_clust[sample(nrow(motif2_genes_fin_RUV_clust), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes2_fin_RUV_clust <- c(m2_genes_fin_RUV_clust$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam2_fin_RUV_clust <- function(gene) {
  gene_data <- motif2_genes_fin_RUV_clust %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes2_fin_RUV_clust) {
  gene_data <- process_gene_datam2_fin_RUV_clust(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "M2 RUVs clustlike")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```


###Cormotif RUVs log2cpm Norm Counts GO/KEGG
```{r GO/KEGG log2cpm Norm Counts Cormotif}
#now take these final gene sets for each motif - clustlike + p.post consensus genes

# final_genes_1_RUV
# final_genes_2_RUV

#clust1_genes_RUV
#clust2_genes_RUV


# library(gprofiler2)
#####Motif 1 Gene Set#####
# motif1_genes_matrix_RUV <- as.matrix(final_genes_1_RUV) 
# colnames(motif1_genes_matrix_RUV) <- c("entrezgene_ID")

# saveRDS(motif1_genes_matrix_RUV, "data/new/RUV/CMF/motif1_genes_matrix_RUV.RDS")

motif1_genes_matrix_RUV <- readRDS("data/new/RUV/CMF/motif1_genes_matrix_RUV.RDS")
length(motif1_genes_matrix_RUV)
#7602 genes in this set for motif 1

motif1_mat_GOKEGG_RUV <- gost(query = motif1_genes_matrix_RUV,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = TRUE,
                          user_threshold = 0.05,
                          significant = TRUE,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif1_GOKEGG_genes_RUV <- gostplot(motif1_mat_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
motif1_GOKEGG_genes_RUV

table_motif1_GOKEGG_genes_RUV <- motif1_mat_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif1_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif1_GOKEGG_genes, "data/new/table_motif1_GOKEGG_genes.csv")

#GO:BP
table_motif1_genes_GOBP_RUV <- table_motif1_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=20, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif1_genes_GOBP, "data/table_motif1_genes_GOBP.RDS")

table_motif1_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point() +
  ggtitle("M1 Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

#KEGG
table_motif1_genes_KEGG_RUV <- table_motif1_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=20, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif1_genes_KEGG_RUV %>%
  ggplot(aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Recovered Enriched Biological Pathways") +
  xlab(expression("-log"[10]~"p-value")) +
  ylab("KEGG Term") +
  scale_y_discrete(labels = scales::label_wrap(30)) +
  theme_custom()
  
#####Motif 2 Genes#####
# motif2_genes_matrix_RUV <- as.matrix(final_genes_2_RUV) 
# colnames(motif2_genes_matrix_RUV) <- c("entrezgene_ID")

# saveRDS(motif2_genes_matrix_RUV, "data/new/RUV/CMF/motif2_genes_matrix_RUV.RDS")

motif2_genes_matrix_RUV <- readRDS("data/new/RUV/CMF/motif2_genes_matrix_RUV.RDS")
length(motif2_genes_matrix_RUV)
#501 genes in this set for motif 2

motif2_mat_GOKEGG_RUV <- gost(query = motif2_genes_matrix_RUV,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = TRUE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif2_GOKEGG_genes_RUV <- gostplot(motif2_mat_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
motif2_GOKEGG_genes_RUV

table_motif2_GOKEGG_genes_RUV <- motif2_mat_GOKEGG_RUV$result %>%
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif2_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif2_GOKEGG_genes, "data/new/table_motif2_GOKEGG_genes.csv")

#GO:BP
table_motif2_genes_GOBP_RUV <- table_motif2_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=20, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif2_genes_GOBP, "data/table_motif2_genes_GOBP.RDS")

table_motif2_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M2 Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif2_genes_KEGG_RUV <- table_motif2_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=20, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif2_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M2 DEGs Enriched KEGG Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#shortened version with custom theme for M1 and M2
kegg_m1_plot <- table_motif1_genes_KEGG_RUV %>%
  ggplot(aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Recovered Enriched Biological Pathways") +
  xlab(expression("-log"[10]~"p-value")) +
  ylab("KEGG Term") +
  scale_y_discrete(labels = scales::label_wrap(30)) +
  theme_custom()+
  theme(axis.line = element_blank(),
        panel.border = element_rect(
          color = "black",
          fill = NA,
          linewidth = 1
        ),
        axis.ticks = element_line(linewidth = .5),
        legend.position = "bottom",
        )


kegg_m2_plot <- table_motif2_genes_KEGG_RUV %>%
  ggplot(aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Sustained Enriched Biological Pathways") +
  xlab(expression("-log"[10]~"p-value")) +
  ylab("KEGG Term") +
  scale_y_discrete(labels = scales::label_wrap(30)) +
  theme_custom()+
  theme(axis.line = element_blank(),
        panel.border = element_rect(
          color = "black",
          fill = NA,
          linewidth = 1
        ),
        axis.ticks = element_line(linewidth = .5),
        legend.position = "bottom",
        )



#now save them as pdfs so I can use them in figure 3
#motif 1
# cairo_pdf(
#   file.path(output_folder, "KEGG_Recovered_UpdateFig3_EMP.pdf"),
#   width = 6,
#   height = 8
# )
# print(kegg_m1_plot)
# dev.off()
# 
# #motif 2
# cairo_pdf(
#   file.path(output_folder, "KEGG_Sustained_UpdateFig3_EMP.pdf"),
#   width = 6,
#   height = 8
# )
# print(kegg_m2_plot)
# dev.off()

```


```{r GO/KEGG Cormotif log2cpm clustlike only, include=FALSE}

#now take these final gene sets for each motif - clustlike + p.post consensus genes

#clust1_genes_RUV
#clust2_genes_RUV


# library(gprofiler2)
#####Motif 1 Gene Set#####
# motif1_genes_matrix_RUV_clust <- as.matrix(clust1_genes_RUV)
# colnames(motif1_genes_matrix_RUV_clust) <- c("entrezgene_ID")

# saveRDS(motif1_genes_matrix_RUV_clust, "data/new/RUV/CMF/motif1_genes_matrix_RUV_clustlike.RDS")

# motif1_genes_matrix_RUV_clust <- readRDS("data/new/RUV/CMF/motif1_genes_matrix_RUV_clustlike.RDS")
# length(motif1_genes_matrix_RUV_clust)
# #13600 genes in this set for motif 1
# 
# motif1_mat_GOKEGG_RUV_clust <- gost(query = motif1_genes_matrix_RUV_clust,
#                           organism = "hsapiens",
#                           ordered_query = FALSE,
#                           measure_underrepresentation = FALSE,
#                           evcodes = FALSE,
#                           user_threshold = 0.05,
#                           custom_bg = all_genes,
#                           correction_method = c("fdr"),
#                           sources = c("GO:BP", "KEGG"))
# 
# motif1_GOKEGG_genes_RUV_clust <- gostplot(motif1_mat_GOKEGG_RUV_clust, capped = FALSE, interactive = TRUE)
# motif1_GOKEGG_genes_RUV_clust
# 
# table_motif1_GOKEGG_genes_RUV_clust <- motif1_mat_GOKEGG_RUV_clust$result %>% 
#   dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))
# 
# table_motif1_GOKEGG_genes_RUV_clust %>% 
#   mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
#   kableExtra::kable(.,) %>% 
#   kableExtra::kable_paper("striped", full_width = FALSE) %>% 
#   kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
#   kableExtra::scroll_box(width = "100%", height = "400px")
# 
# # write.csv(table_motif1_GOKEGG_genes, "data/new/table_motif1_GOKEGG_genes.csv")
# 
# #GO:BP
# table_motif1_genes_GOBP_RUV_clust <- table_motif1_GOKEGG_genes_RUV_clust %>% 
#   dplyr::filter(source=="GO:BP") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# # saveRDS(table_motif1_genes_GOBP, "data/table_motif1_genes_GOBP.RDS")
# 
# table_motif1_genes_GOBP_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("M1 Enriched GO:BP Terms RUVs clustlike")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("GO:BP term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
# 
# #KEGG
# table_motif1_genes_KEGG_RUV_clust <- table_motif1_GOKEGG_genes_RUV_clust %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_motif1_genes_KEGG_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("M1 DEGs Enriched KEGG Terms RUVs clustlike")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
# 
# #####Motif 2 Genes#####
# # motif2_genes_matrix_RUV_clust <- as.matrix(clust2_genes_RUV)
# # colnames(motif2_genes_matrix_RUV_clust) <- c("entrezgene_ID")
# 
# # saveRDS(motif2_genes_matrix_RUV_clust, "data/new/RUV/CMF/motif2_genes_matrix_RUV_clustlike.RDS")
# 
# motif2_genes_matrix_RUV_clust <- readRDS("data/new/RUV/CMF/motif2_genes_matrix_RUV_clustlike.RDS")
# length(motif2_genes_matrix_RUV_clust)
# #517 genes in this set for motif 2
# 
# motif2_mat_GOKEGG_RUV_clust <- gost(query = motif2_genes_matrix_RUV_clust,
#                           organism = "hsapiens",
#                           ordered_query = FALSE,
#                           measure_underrepresentation = FALSE,
#                           evcodes = FALSE,
#                           user_threshold = 0.05,
#                           custom_bg = all_genes,
#                           correction_method = c("fdr"),
#                           sources = c("GO:BP", "KEGG"))
# 
# motif2_GOKEGG_genes_RUV_clust <- gostplot(motif2_mat_GOKEGG_RUV_clust, capped = FALSE, interactive = TRUE)
# motif2_GOKEGG_genes_RUV_clust
# 
# table_motif2_GOKEGG_genes_RUV_clust <- motif2_mat_GOKEGG_RUV_clust$result %>% 
#   dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))
# 
# table_motif2_GOKEGG_genes_RUV_clust %>% 
#   mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
#   kableExtra::kable(.,) %>% 
#   kableExtra::kable_paper("striped", full_width = FALSE) %>% 
#   kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
#   kableExtra::scroll_box(width = "100%", height = "400px")
# 
# # write.csv(table_motif2_GOKEGG_genes, "data/new/table_motif2_GOKEGG_genes.csv")
# 
# #GO:BP
# table_motif2_genes_GOBP_RUV_clust <- table_motif2_GOKEGG_genes_RUV_clust %>% 
#   dplyr::filter(source=="GO:BP") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# # saveRDS(table_motif2_genes_GOBP, "data/table_motif2_genes_GOBP.RDS")
# 
# table_motif2_genes_GOBP_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("M2 Enriched GO:BP Terms RUVs clustlike")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("GO:BP term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
# 
# #KEGG
# table_motif2_genes_KEGG_RUV_clust <- table_motif2_GOKEGG_genes_RUV_clust %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_motif2_genes_KEGG_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("M2 DEGs Enriched KEGG Terms RUVs clustlike")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

```


##Attempt Cormotif with Norm Counts Only
```{r RUVs Cormotif Plain Norm Counts, include=FALSE}
# # #now since I'm having some strange outputs with the transformed data
# # #I want to try and just feed in the normalized counts only
# # 
# normcounts_CMF_rep <- as.data.frame(set1$normalizedCounts)
# # 
# #first want to cut out the replicate samples as not needed for Cormotif
# normcounts_CMF <- as.data.frame(normcounts_CMF_rep) %>%
#   dplyr::select(-(contains("6R")))
# 
# # #14319 genes in 36 columns, set up for plugging into Cormotif

# #now I need to set up my groupid and compid accordingly
# #put together my group id and comparison id to make the correct comparisons between experimental conditions

# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control

#groupid that doesn't require changing order of matrix:
# groupid_other <- c(
#   DOX_24T_1 = 1,
#   DMSO_24T_1 = 4,
#   DOX_24R_1 = 2,
#   DMSO_24R_1 = 5,
#   DOX_144R_1 = 3,
#   DMSO_144R_1 = 6,
# 
#   DOX_24T_2 = 1,
#   DMSO_24T_2 = 4,
#   DOX_24R_2 = 2,
#   DMSO_24R_2 = 5,
#   DOX_144R_2 = 3,
#   DMSO_144R_2 = 6,
# 
#   DOX_24T_3 = 1,
#   DMSO_24T_3 = 4,
#   DOX_24R_3 = 2,
#   DMSO_24R_3 = 5,
#   DOX_144R_3 = 3,
#   DMSO_144R_3 = 6,
# 
#   DOX_24T_4 = 1,
#   DMSO_24T_4 = 4,
#   DOX_24R_4 = 2,
#   DMSO_24R_4 = 5,
#   DOX_144R_4 = 3,
#   DMSO_144R_4 = 6,
# 
#   DOX_24T_5 = 1,
#   DMSO_24T_5 = 4,
#   DOX_24R_5 = 2,
#   DMSO_24R_5 = 5,
#   DOX_144R_5 = 3,
#   DMSO_144R_5 = 6,
# 
#   DOX_24T_6 = 1,
#   DMSO_24T_6 = 4,
#   DOX_24R_6 = 2,
#   DMSO_24R_6 = 5,
#   DOX_144R_6 = 3,
#   DMSO_144R_6 = 6
# )
# 
# groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")
# 
# compid <- data.frame(Cond1 = c(1, 3, 5), Cond2 = c(2, 4, 6))
# compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))

```

###Run Cormotif Norm Counts Only
```{r RUVs Run Cormotif NormCounts Only, include=FALSE}

# #set the seed the same as the previous one to ensure consistency
# 
# #fit Cormotif model
# # set.seed(19191)
# # #only set the seed ONCE
# # 
# # motif.fit_RUV_NC_test <- cormotiffit(
# #   exprs = exprs.NC_CMF_RUV,
# #   groupid = groupid_other,
# #   compid = compid,
# #   K = 1:10,
# #   max.iter = 1000,
# #   BIC = TRUE,
# #   runtype = "counts"
# # )
# 
# #saveRDS(motif.fit_RUV_NC_test, "data/new/RUV/motif.fit_RUVnormcounts_compid_250630.RDS")
# motif.fit_RUV_NC_test <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_250630.RDS")

```
###Plot Cormotif Norm Counts Only
```{r RUVs Plot Cormotif NormCounts Only, include=FALSE}
# #plot the AIC and BIC (we're interested in the Bayesian most of all)
# 
# plotIC(motif.fit_RUV_NC_test)
# # 
# # #visual check of the lowest BIC
# # motif.fit_RUV_NC_test$bic
# # 
# # #plot the motifs
# plotMotif(motif.fit_RUV_NC_test)
# # 
# #plot the probability legend
# myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))
# 
# plot.new()
# legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

Now that I've finished up with Cormotif, I want to make comparisons across DEGs and Cormotif analysis to identify DEGs within my motifs
I also want to find out if any of my DEGs within a certain category (DDR, DIC, p53 target genes) are enriched in a motif.
```{r Cormotif DDR Enrichment Proportion Barplots}
#testing for each motif whether DNA damage response genes are enriched in that motif compared to all other tested genes

DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

total_DNA_damage_genes <- length(DNA_damage_genes)  #Total number of DNA damage genes
#should be 65 genes

#define my Cormotif gene lists
CMF_genes <- list(
  "Motif1" = motif1_genes_matrix, "Motif2" = motif2_genes_matrix, "Motif3" = motif3_genes_matrix
)

all_tested_genes <- unique(unlist(CMF_genes))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
ddr_set <- unique(na.omit(DNA_damage_genes))

motif_enrichment <- purrr::map_dfr(names(CMF_genes), function(motif_name) {
  motif_genes <- unique(CMF_genes[[motif_name]])
  
  # #print results
  # print(motif_enrichment)
  
  # Count in motif 
  in_motif_ddr     <- sum(motif_genes %in% ddr_set)
  #number of genes inside the motif that are DDR
  in_motif_non_ddr <- length(motif_genes) - in_motif_ddr
  #number of genes inside motif that are NOT DDR
  
  # Count outside motif 
  other_genes <- setdiff(all_tested_genes, motif_genes)
  #checking the difference between all genes and motif genes
  out_motif_ddr     <- sum(other_genes %in% ddr_set)
  #all genes outside motif that are DDR
  out_motif_non_ddr <- length(other_genes) - out_motif_ddr
  #all genes outside the motif that are NOT DDR
  
  # Build contingency table
  contingency_ddr_cmf <- matrix(c(in_motif_ddr, in_motif_non_ddr,
                          out_motif_ddr, out_motif_non_ddr),
                        nrow = 2, byrow = TRUE)
  
  #print results to check size of contingency table
  print(contingency_ddr_cmf)
  
  # Perform fisher's exact test - sample size too small for chi-square
  fisher_test_ddr_cmf <- fisher.test(contingency_ddr_cmf)
  p_value <- fisher_test_ddr_cmf$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_DDR = in_motif_ddr,
    In_Motif_NonDDR = in_motif_non_ddr,
    Out_Motif_DDR = out_motif_ddr,
    Out_Motif_NonDDR = out_motif_non_ddr,
    Total_Genes = length(motif_genes),
    DNA_Damage_Proportion = in_motif_ddr / length(motif_genes) * 100,
    P_Value = fisher_test_ddr_cmf$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long <- motif_enrichment %>%
  select(Motif, In_Motif_DDR, In_Motif_NonDDR, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_DDR, In_Motif_NonDDR),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long$Category <- factor(motif_long$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions <- motif_long %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DNA Damage Genes per Cormotif Motif",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print the proportions so I know the exact percentages and p values
print(motif_long)


```

```{r DIC Genes Cormotif Proportion Barplots}

DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

total_DIC_genes <- length(DOX_cardiotox_genes)  #Total number of DNA damage genes
#should be 29

#define my Cormotif gene lists
CMF_genes <- list(
  "Motif1" = motif1_genes_matrix, "Motif2" = motif2_genes_matrix, "Motif3" = motif3_genes_matrix
)

all_tested_genes <- unique(unlist(CMF_genes))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
dic_set <- unique(na.omit(DOX_cardiotox_genes))

motif_enrichment_dic <- purrr::map_dfr(names(CMF_genes), function(motif_name) {
  motif_genes <- unique(CMF_genes[[motif_name]])
  
  # #print this result to compare
  # print(motif_enrichment_dic)
  
  # Count in motif 
  in_motif_dic     <- sum(motif_genes %in% dic_set)
  #number of genes inside the motif that are dic
  in_motif_non_dic <- length(motif_genes) - in_motif_dic
  #number of genes inside motif that are NOT dic
  
  # Count outside motif 
  other_genes <- setdiff(all_tested_genes, motif_genes)
  #checking the difference between all genes and motif genes
  out_motif_dic     <- sum(other_genes %in% dic_set)
  #all genes outside motif that are dic
  out_motif_non_dic <- length(other_genes) - out_motif_dic
  #all genes outside the motif that are NOT dic
  
  # Build contingency table
  contingency_dic_cmf <- matrix(c(in_motif_dic, in_motif_non_dic,
                          out_motif_dic, out_motif_non_dic),
                        nrow = 2, byrow = TRUE)
  #print my contingency table to check sample size 
  print(contingency_dic_cmf)
  
  # Perform fisher's exact test (sample size too small for chi-square)
  fisher_test_dic_cmf <- fisher.test(contingency_dic_cmf)
  p_value <- fisher_test_dic_cmf$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_dic = in_motif_dic,
    In_Motif_Nondic = in_motif_non_dic,
    Out_Motif_dic = out_motif_dic,
    Out_Motif_Nondic = out_motif_non_dic,
    Total_Genes = length(motif_genes),
    DNA_Damage_Proportion = in_motif_dic / length(motif_genes) * 100,
    P_Value = fisher_test_dic_cmf$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_dic <- motif_enrichment_dic %>%
  select(Motif, In_Motif_dic, In_Motif_Nondic, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_dic, In_Motif_Nondic),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_dic", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_dic$Category <- factor(motif_long_dic$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_dic <- motif_long_dic %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_dic, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DOX Cardiotox Genes per Cormotif Motif",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print this so I know the p-value and percentages
print(motif_long_dic)

```

```{r Cormotif p53 Target Gene Enrichment Proportion Barplots}

p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

total_p53_genes <- length(p53_target_genes)  #Total number of p53 target genes
#should be 300

#define my Cormotif gene lists
CMF_genes <- list(
  "Motif1" = motif1_genes_matrix, "Motif2" = motif2_genes_matrix, "Motif3" = motif3_genes_matrix
)

all_tested_genes <- unique(unlist(CMF_genes))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
p53_set <- unique(na.omit(p53_target_genes))

motif_enrichment_p53 <- purrr::map_dfr(names(CMF_genes), function(motif_name) {
  motif_genes <- unique(CMF_genes[[motif_name]])
  
  # #print this dataset
  # print(motif_enrichment_p53)
  
  # Count in motif 
  in_motif_p53     <- sum(motif_genes %in% p53_set)
  #number of genes inside the motif that are p53
  in_motif_non_p53 <- length(motif_genes) - in_motif_p53
  #number of genes inside motif that are NOT p53
  
  # Count outside motif 
  other_genes <- setdiff(all_tested_genes, motif_genes)
  #checking the difference between all genes and motif genes
  out_motif_p53     <- sum(other_genes %in% p53_set)
  #all genes outside motif that are p53
  out_motif_non_p53 <- length(other_genes) - out_motif_p53
  #all genes outside the motif that are NOT p53
  
  # Build contingency table
  contingency_p53_cmf <- matrix(c(in_motif_p53, in_motif_non_p53,
                          out_motif_p53, out_motif_non_p53),
                        nrow = 2, byrow = TRUE)
  #print the results so I can visualize the contingency tables for my motifs
  print(contingency_p53_cmf)
  
  # Perform fishers exact test (sample size too small for chi-square)
  fisher_test_p53_cmf <- fisher.test(contingency_p53_cmf)
  p_value <- fisher_test_p53_cmf$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_p53 = in_motif_p53,
    In_Motif_Nonp53 = in_motif_non_p53,
    Out_Motif_p53 = out_motif_p53,
    Out_Motif_Nonp53 = out_motif_non_p53,
    Total_Genes = length(motif_genes),
    DNA_Damage_Proportion = in_motif_p53 / length(motif_genes) * 100,
    P_Value = fisher_test_p53_cmf$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_p53 <- motif_enrichment_p53 %>%
  select(Motif, In_Motif_p53, In_Motif_Nonp53, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_p53, In_Motif_Nonp53),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_p53$Category <- factor(motif_long_p53$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_p53 <- motif_long_p53 %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_p53, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53 %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of p53 Target Genes per Cormotif Motif",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print these data to check percentages and p-value
print(motif_long_p53)

```

##Cormotif Proportion Barplots New Motifs RUVs Corrected
###DDR Genes Proportion Barplot RUVs Cormotif
```{r DDR Genes Proportion Barplot Cormotif RUVs clustlike only}
# DNA_damage_genes <- readRDS("data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

total_DNA_damage_genes <- length(DNA_damage_genes)  #Total number of DNA damage genes
#should be 65 genes

#define my Cormotif gene lists
CMF_genes_RUV <- list(
  "Motif1" = final_genes_1_RUV, 
  "Motif2" = final_genes_2_RUV
)

all_tested_genes_RUV <- unique(unlist(CMF_genes_RUV))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
ddr_set <- unique(na.omit(DNA_damage_genes))

motif_enrichment_RUV <- purrr::map_dfr(names(CMF_genes_RUV), function(motif_name) {
  motif_genes_RUV <- unique(CMF_genes_RUV[[motif_name]])
  
  #print these results
  # print(motif_enrichment_RUV)
  
  # Count in motif 
  in_motif_ddr_RUV     <- sum(motif_genes_RUV %in% ddr_set)
  #number of genes inside the motif that are DDR
  in_motif_non_ddr_RUV <- length(motif_genes_RUV) - in_motif_ddr_RUV
  #number of genes inside motif that are NOT DDR
  
  # Count outside motif 
  other_genes_RUV <- setdiff(all_tested_genes_RUV, motif_genes_RUV)
  #checking the difference between all genes and motif genes
  out_motif_ddr_RUV     <- sum(other_genes_RUV %in% ddr_set)
  #all genes outside motif that are DDR
  out_motif_non_ddr_RUV <- length(other_genes_RUV) - out_motif_ddr_RUV
  #all genes outside the motif that are NOT DDR
  
  # Build contingency table
  contingency_ddr_cmf_RUV <- matrix(c(in_motif_ddr_RUV, in_motif_non_ddr_RUV,
                          out_motif_ddr_RUV, out_motif_non_ddr_RUV),
                        nrow = 2, byrow = TRUE)
  
  #print the contingency table to check sample size
  print(contingency_ddr_cmf_RUV)
  
  # Perform fisher's exact test - sample size too small and unreliable for chi-square
  fisher_test_ddr_cmf_RUV <- fisher.test(contingency_ddr_cmf_RUV)
  p_value_RUV <- fisher_test_ddr_cmf_RUV$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_DDR = in_motif_ddr_RUV,
    In_Motif_NonDDR = in_motif_non_ddr_RUV,
    Out_Motif_DDR = out_motif_ddr_RUV,
    Out_Motif_NonDDR = out_motif_non_ddr_RUV,
    Total_Genes = length(motif_genes_RUV),
    DNA_Damage_Proportion = in_motif_ddr_RUV / length(motif_genes_RUV) * 100,
    P_Value = fisher_test_ddr_cmf_RUV$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_RUV <- motif_enrichment_RUV %>%
  dplyr::select(Motif, In_Motif_DDR, In_Motif_NonDDR, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_DDR, In_Motif_NonDDR),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_RUV$Category <- factor(motif_long_RUV$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_RUV <- motif_long_RUV %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_RUV, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_RUV %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion DDR Genes per Motif RUVs clustlike + p.post",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print this to see p-value and percentages
print(motif_long_RUV)

```

###DIC Genes Cormotif RUVs
```{r DIC Genes Proportion Barplot Cormotif RUVs clustlike only}
DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

total_DIC_genes <- length(DOX_cardiotox_genes)  #Total number of DNA damage genes
#should be 29

#define my Cormotif gene lists
CMF_genes_RUV_clust <- list(
  "Motif1" = clust1_genes_RUV, "Motif2" = clust2_genes_RUV
)

all_tested_genes <- unique(unlist(CMF_genes_RUV_clust))
#this has the 14117 genes used for clustlike only
#usual gene set is 14319

#compute my sets
dic_set <- unique(na.omit(DOX_cardiotox_genes))

motif_enrichment_dic_RUV_clust <- purrr::map_dfr(names(CMF_genes_RUV_clust), function(motif_name) {
  motif_genes_dic_RUV_clust <- unique(CMF_genes_RUV_clust[[motif_name]])
  
  #print this to get a summary of results
  # print(motif_enrichment_dic_RUV_clust)
  
  # Count in motif 
  in_motif_dic_RUV_clust <- sum(motif_genes_dic_RUV_clust %in% dic_set)
  #number of genes inside the motif that are dic
  in_motif_non_dic_RUV_clust <- length(motif_genes_dic_RUV_clust) - in_motif_dic_RUV_clust
  #number of genes inside motif that are NOT dic
  
  # Count outside motif 
  other_genes_dic_RUV_clust <- setdiff(all_tested_genes, motif_genes_dic_RUV_clust)
  #checking the difference between all genes and motif genes
  out_motif_dic_RUV_clust     <- sum(other_genes_dic_RUV_clust %in% dic_set)
  #all genes outside motif that are dic
  out_motif_non_dic_RUV_clust <- length(other_genes_dic_RUV_clust) - out_motif_dic_RUV_clust
  #all genes outside the motif that are NOT dic
  
  # Build contingency table
  contingency_dic_cmf_RUV_clust <- matrix(c(in_motif_dic_RUV_clust,
                                            in_motif_non_dic_RUV_clust,
                                            out_motif_dic_RUV_clust,
                                            out_motif_non_dic_RUV_clust),
                                          nrow = 2, byrow = TRUE)
  #print
  print(contingency_dic_cmf_RUV_clust)
  
  # Perform fisher's exact test (sample size too small for chi-square)
  fisher_test_dic_cmf_RUV_clust <- fisher.test(contingency_dic_cmf_RUV_clust)
  p_value <- fisher_test_dic_cmf_RUV_clust$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_dic = in_motif_dic_RUV_clust,
    In_Motif_Nondic = in_motif_non_dic_RUV_clust,
    Out_Motif_dic = out_motif_dic_RUV_clust,
    Out_Motif_Nondic = out_motif_non_dic_RUV_clust,
    Total_Genes = length(motif_genes_dic_RUV_clust),
    DNA_Damage_Proportion = in_motif_dic_RUV_clust / length(motif_genes_dic_RUV_clust) * 100,
    P_Value = fisher_test_dic_cmf_RUV_clust$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_dic_RUV_clust <- motif_enrichment_dic_RUV_clust %>%
  select(Motif, In_Motif_dic, In_Motif_Nondic, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_dic, In_Motif_Nondic),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_dic", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_dic_RUV_clust$Category <- factor(motif_long_dic_RUV_clust$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_dic_RUV_clust <- motif_long_dic_RUV_clust %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_dic_RUV_clust, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic_RUV_clust %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion DOX Cardiotox Genes per Motif RUVs clustlike",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print these data to check p-value and percentages
print(motif_long_dic_RUV_clust)

```

###DIC Genes RUVs Cormotif Proportion Barplot clustlike + p.post
```{r DIC Genes Proportion Barplot Cormotif RUVs clust+p.post}
DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

total_DIC_genes <- length(DOX_cardiotox_genes)  #Total number of DNA damage genes
#should be 29

#define my Cormotif gene lists
CMF_genes_RUV <- list(
  "Motif1" = final_genes_1_RUV, "Motif2" = final_genes_2_RUV
)

all_tested_genes <- unique(unlist(CMF_genes_RUV))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
dic_set <- unique(na.omit(DOX_cardiotox_genes))

motif_enrichment_dic_RUV <- purrr::map_dfr(names(CMF_genes_RUV), function(motif_name) {
  motif_genes_dic_RUV <- unique(CMF_genes_RUV[[motif_name]])
  
  # print(motif_enrichment_dic_RUV)
  
  # Count in motif 
  in_motif_dic_RUV <- sum(motif_genes_dic_RUV %in% dic_set)
  #number of genes inside the motif that are dic
  in_motif_non_dic_RUV <- length(motif_genes_dic_RUV) - in_motif_dic_RUV
  #number of genes inside motif that are NOT dic
  
  # Count outside motif 
  other_genes_dic_RUV <- setdiff(all_tested_genes, motif_genes_dic_RUV)
  #checking the difference between all genes and motif genes
  out_motif_dic_RUV     <- sum(other_genes_dic_RUV %in% dic_set)
  #all genes outside motif that are dic
  out_motif_non_dic_RUV <- length(other_genes_dic_RUV) - out_motif_dic_RUV
  #all genes outside the motif that are NOT dic
  
  # Build contingency table
  contingency_dic_cmf_RUV <- matrix(c(in_motif_dic_RUV, in_motif_non_dic_RUV,
                          out_motif_dic_RUV, out_motif_non_dic_RUV),
                        nrow = 2, byrow = TRUE)
  
  #print contingency table
  print(contingency_dic_cmf_RUV)
  
  # Perform fisher's exact test
  fisher_test_dic_cmf_RUV <- fisher.test(contingency_dic_cmf_RUV)
  p_value <- fisher_test_dic_cmf_RUV$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_dic = in_motif_dic_RUV,
    In_Motif_Nondic = in_motif_non_dic_RUV,
    Out_Motif_dic = out_motif_dic_RUV,
    Out_Motif_Nondic = out_motif_non_dic_RUV,
    Total_Genes = length(motif_genes_dic_RUV),
    DNA_Damage_Proportion = in_motif_dic_RUV / length(motif_genes_dic_RUV) * 100,
    P_Value = fisher_test_dic_cmf_RUV$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_dic_RUV <- motif_enrichment_dic_RUV %>%
  select(Motif, In_Motif_dic, In_Motif_Nondic, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_dic, In_Motif_Nondic),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_dic", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_dic_RUV$Category <- factor(motif_long_dic_RUV$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_dic_RUV <- motif_long_dic_RUV %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_dic_RUV, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic_RUV %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion DOX Cardiotox Genes per Motif RUVs clustlike",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )
```

###p53 Target Genes Cormotif RUVs
```{r p53 Target Genes Proportion Barplot Cormotif RUVs clustlike only}
p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

total_p53_genes <- length(p53_target_genes)  #Total number of p53 target genes
#should be 300

#define my Cormotif gene lists
CMF_genes_RUV_clust <- list(
  "Motif1" = clust1_genes_RUV, "Motif2" = clust2_genes_RUV
)

all_tested_genes_RUV_clust <- unique(unlist(CMF_genes_RUV_clust))
#this has the 14117 used for clustlike only
#usual gene set is 14319

#compute my sets
p53_set <- unique(na.omit(p53_target_genes))

motif_enrichment_p53_RUV_clust <- purrr::map_dfr(names(CMF_genes_RUV_clust), function(motif_name) {
  motif_genes_p53_RUV_clust <- unique(CMF_genes_RUV_clust[[motif_name]])
  
  # Count in motif 
  in_motif_p53_RUV_clust     <- sum(motif_genes_p53_RUV_clust %in% p53_set)
  #number of genes inside the motif that are p53
  in_motif_non_p53_RUV_clust <- length(motif_genes_p53_RUV_clust) - in_motif_p53_RUV_clust
  #number of genes inside motif that are NOT p53
  
  # Count outside motif 
  other_genes_p53_RUV_clust <- setdiff(all_tested_genes_RUV_clust, motif_genes_p53_RUV_clust)
  #checking the difference between all genes and motif genes
  out_motif_p53_RUV_clust <- sum(other_genes_p53_RUV_clust %in% p53_set)
  #all genes outside motif that are p53
  out_motif_non_p53_RUV_clust <- length(other_genes_p53_RUV_clust) - out_motif_p53_RUV_clust
  #all genes outside the motif that are NOT p53
  
  # Build contingency table
  contingency_p53_cmf_RUV_clust <- matrix(c(in_motif_p53_RUV_clust,
                                            in_motif_non_p53_RUV_clust,
                                            out_motif_p53_RUV_clust,
                                            out_motif_non_p53_RUV_clust),
                                          nrow = 2, byrow = TRUE)
  
  #print my contingency table
  print(contingency_p53_cmf_RUV_clust)
  
  # Perform fisher's exact test
  fisher_test_p53_cmf_RUV_clust <- fisher.test(contingency_p53_cmf_RUV_clust)
  p_value_RUV_clust <- fisher_test_p53_cmf_RUV_clust$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_p53 = in_motif_p53_RUV_clust,
    In_Motif_Nonp53 = in_motif_non_p53_RUV_clust,
    Out_Motif_p53 = out_motif_p53_RUV_clust,
    Out_Motif_Nonp53 = out_motif_non_p53_RUV_clust,
    Total_Genes = length(motif_genes_p53_RUV_clust),
    DNA_Damage_Proportion = in_motif_p53_RUV_clust / length(motif_genes_p53_RUV_clust) * 100,
    P_Value = fisher_test_p53_cmf_RUV_clust$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_p53_RUV_clust <- motif_enrichment_p53_RUV_clust %>%
  select(Motif, In_Motif_p53, In_Motif_Nonp53, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_p53, In_Motif_Nonp53),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_p53_RUV_clust$Category <- factor(motif_long_p53_RUV_clust$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_p53_RUV_clust <- motif_long_p53_RUV_clust %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_p53_RUV_clust, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53_RUV_clust %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion p53 Target Genes per Motif RUVs clustlike",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print this dataframe to look at p-value and percentage
print(motif_long_p53_RUV_clust)

```

###p53 Target Genes Cormotif RUVs p.post + clustlike
```{r p53 Target Genes Cormotif RUVs p.post + clustlike}

p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

total_p53_genes <- length(p53_target_genes)  #Total number of p53 target genes
#should be 300

#define my Cormotif gene lists
CMF_genes_RUV <- list(
  "Motif1" = final_genes_1_RUV, 
  "Motif2" = final_genes_2_RUV
)
#7602 genes motif 1 + 501 genes motif 2

all_tested_genes_RUV <- unique(unlist(CMF_genes_RUV))
#this has the 8103 genes used for clustlike + p.post
#usual gene set is 14319

#compute my sets
p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")

p53_set <- unique(na.omit(p53_target_genes))

motif_enrichment_p53_RUV <- purrr::map_dfr(names(CMF_genes_RUV), function(motif_name) {
  motif_genes_p53_RUV <- unique(CMF_genes_RUV[[motif_name]])
  
  #print results
  # print(motif_enrichment_p53_RUV)
  
  # Count in motif 
  in_motif_p53_RUV     <- sum(motif_genes_p53_RUV %in% p53_set)
  #number of genes inside the motif that are p53
  in_motif_non_p53_RUV <- length(motif_genes_p53_RUV) - in_motif_p53_RUV
  #number of genes inside motif that are NOT p53
  
  # Count outside motif 
  other_genes_p53_RUV <- setdiff(all_tested_genes_RUV, motif_genes_p53_RUV)
  #checking the difference between all genes and motif genes
  out_motif_p53_RUV <- sum(other_genes_p53_RUV %in% p53_set)
  #all genes outside motif that are p53
  out_motif_non_p53_RUV <- length(other_genes_p53_RUV) - out_motif_p53_RUV
  #all genes outside the motif that are NOT p53
  
  # Build contingency table
  contingency_p53_cmf_RUV <- matrix(c(in_motif_p53_RUV, in_motif_non_p53_RUV,
                          out_motif_p53_RUV, out_motif_non_p53_RUV),
                        nrow = 2, byrow = TRUE)
  #print my contingency tables
  print(contingency_p53_cmf_RUV)
  
  # Perform fisher's exact test
  fisher_test_p53_cmf_RUV <- fisher.test(contingency_p53_cmf_RUV)
  p_value_RUV <- fisher_test_p53_cmf_RUV$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_p53 = in_motif_p53_RUV,
    In_Motif_Nonp53 = in_motif_non_p53_RUV,
    Out_Motif_p53 = out_motif_p53_RUV,
    Out_Motif_Nonp53 = out_motif_non_p53_RUV,
    Total_Genes = length(motif_genes_p53_RUV),
    DNA_Damage_Proportion = in_motif_p53_RUV / length(motif_genes_p53_RUV) * 100,
    P_Value = fisher_test_p53_cmf_RUV$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_p53_RUV <- motif_enrichment_p53_RUV %>%
  select(Motif, In_Motif_p53, In_Motif_Nonp53, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_p53, In_Motif_Nonp53),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_p53_RUV$Category <- factor(motif_long_p53_RUV$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_p53_RUV <- motif_long_p53_RUV %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_p53_RUV, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53_RUV %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion p53 Target Genes per Motif RUVs clustlike + p.post",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

print(motif_long_p53_RUV)
```

#Final Cormotif RUVs Analysis
We will continue forward with the RUVs corrected data based on log2cpm of normalized counts
We will then use the Cormotif gene sets based on p.post and clustlike together
##DDR Proportion Bar plots Redo
```{r DDR Cormotif RUVs Proportion Barplots}

#I am going to alter my strategy to identify the proportion of genes within one motif that are or are not DDR, do the same for the second motif, and then test between the two for differences in their proportions

#read in my DDR gene set
DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

ddr_set <- unique(na.omit(DNA_damage_genes))

#DDR genes inside each motif
in_motif1_DDR <- sum(final_genes_1_RUV %in% ddr_set)
in_motif2_DDR <- sum(final_genes_2_RUV %in% ddr_set)

#non-DDR genes inside each motif
in_motif1_nonDDR <- length(final_genes_1_RUV) - in_motif1_DDR
in_motif2_nonDDR <- length(final_genes_2_RUV) - in_motif2_DDR

#make contingency tables for fishers exact tests
contingency_motifs_DDR <- matrix(c(
  in_motif1_DDR, in_motif1_nonDDR,
  in_motif2_DDR, in_motif2_nonDDR),
  nrow = 2, byrow = TRUE
)

#print the contingency tables
print(contingency_motifs_DDR)

#perform a fisher's exact test (small sample size)
fisher_test_motifs_DDR <- fisher.test(contingency_motifs_DDR)
#print fisher's exact test results
print(fisher_test_motifs_DDR)

#make a summary table of all of these data to plot
motif_summary_DDR <- tibble(
  Motif = c("Motif1", "Motif2"),
  DDR = c(in_motif1_DDR, in_motif2_DDR),
  non_DDR = c(in_motif1_nonDDR, in_motif2_nonDDR)
) %>%
  pivot_longer(cols = c(DDR, non_DDR), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_DDR$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_DDR <- motif_summary_DDR %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_DDR$Category <- factor(motif_summary_DDR$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_DDR, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_DDR %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DDR Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_DDR <- in_motif1_DDR / length(final_genes_1_RUV)
prop_motif2_DDR <- in_motif2_DDR / length(final_genes_2_RUV)
p_val_DDR <- fisher_test_motifs_DDR$p.value

cat(sprintf("Motif1: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif1_DDR, in_motif1_DDR, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif2_DDR, in_motif2_DDR, length(final_genes_2_RUV)))
cat(sprintf("DDR Fisher's Exact Test p-value: %.5f\n", p_val_DDR))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_DDR$estimate))



```

##DIC Proportion Bar plots Redo
```{r DIC Genes Proportion Barplots RUVs clustlike + p.post}

#read in my DIC gene set
DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

dic_set <- unique(na.omit(DOX_cardiotox_genes))

#DIC genes inside each motif
in_motif1_DIC <- sum(final_genes_1_RUV %in% dic_set)
in_motif2_DIC <- sum(final_genes_2_RUV %in% dic_set)

#non-DIC genes inside each motif
in_motif1_nonDIC <- length(final_genes_1_RUV) - in_motif1_DIC
in_motif2_nonDIC <- length(final_genes_2_RUV) - in_motif2_DIC

#make contingency tables for fishers exact tests
contingency_motifs_DIC <- matrix(c(
  in_motif1_DIC, in_motif1_nonDIC,
  in_motif2_DIC, in_motif2_nonDIC),
  nrow = 2, byrow = TRUE
)

#print the contingency tables
print(contingency_motifs_DIC)

#perform a fisher's exact test (small sample size)
fisher_test_motifs_DIC <- fisher.test(contingency_motifs_DIC)
#print fisher's exact test results
print(fisher_test_motifs_DIC)

#make a summary table of all of these data to plot
motif_summary_DIC <- tibble(
  Motif = c("Motif1", "Motif2"),
  DIC = c(in_motif1_DIC, in_motif2_DIC),
  non_DIC = c(in_motif1_nonDIC, in_motif2_nonDIC)
) %>%
  pivot_longer(cols = c(DIC, non_DIC), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "DIC", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_DIC$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_DIC <- motif_summary_DIC %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_DIC$Category <- factor(motif_summary_DIC$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_DIC, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_DIC %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DIC Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_DIC <- in_motif1_DIC / length(final_genes_1_RUV)
prop_motif2_DIC <- in_motif2_DIC / length(final_genes_2_RUV)
p_val_DIC <- fisher_test_motifs_DIC$p.value

cat(sprintf("Motif1: %.2f%% DIC genes (%d/%d)\n", 100*prop_motif1_DIC, in_motif1_DIC, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% DIC genes (%d/%d)\n", 100*prop_motif2_DIC, in_motif2_DIC, length(final_genes_2_RUV)))
cat(sprintf("DIC Fisher's Exact Test p-value: %.5f\n", p_val_DIC))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_DIC$estimate))


```




Now, I want to convert these into forest plots
#Forest Plots and Proportion Barplots
```{r Forest Plots}

# ----------------------------
# Define motifs and gene sets
# ----------------------------
motifs <- list(
  M1 = final_genes_1_RUV,
  M2 = final_genes_2_RUV
)

gene_sets <- list(
  DDR = ddr_set,
  P53 = p53_set,
  DIC = AIC_set
)

all_genes <- unique(unlist(motifs))  # universe of tested genes

# ----------------------------
# Function to calculate motif enrichment and Fisher test
# ----------------------------
compute_enrichment <- function(motifs_list, gene_set, gene_set_name) {
  map_dfr(names(motifs_list), function(motif_name) {
    motif_genes <- motifs_list[[motif_name]]
    non_motif_genes <- setdiff(all_genes, motif_genes)
    
    # Counts
    in_motif <- sum(motif_genes %in% gene_set)
    in_motif_non <- length(motif_genes) - in_motif
    out_motif <- sum(non_motif_genes %in% gene_set)
    out_motif_non <- length(non_motif_genes) - out_motif
    
    # Contingency table
    mat <- matrix(c(in_motif, in_motif_non, out_motif, out_motif_non),
                  nrow = 2, byrow = TRUE)
    rownames(mat) <- c("Motif", "Non-motif")
    colnames(mat) <- c("In_Set", "Not_In_Set")
    
    # Fisher test
    test <- fisher.test(mat)
    
    tibble(
      Gene_Set = gene_set_name,
      Motif = motif_name,
      In_Set = in_motif,
      Not_In_Set = in_motif_non,
      Odds_Ratio = as.numeric(test$estimate),
      CI_Low = test$conf.int[1],
      CI_High = test$conf.int[2],
      P_Value = test$p.value
    )
  })
}

# ----------------------------
# Compute enrichment for all gene sets
# ----------------------------
enrichment_results <- map_dfr(names(gene_sets), function(gs_name) {
  compute_enrichment(motifs, gene_sets[[gs_name]], gs_name)
})

# ----------------------------
# Generate barplots per gene set
# ----------------------------
for(gs_name in names(gene_sets)) {
  df <- enrichment_results %>% dplyr::filter(Gene_Set == gs_name)
  
  # Prepare long format for stacked bar
  motif_long <- df %>%
    dplyr::select(Motif, In_Set, Not_In_Set, P_Value) %>%
    pivot_longer(cols = c(In_Set, Not_In_Set),
                 names_to = "Category", values_to = "Count") %>%
    mutate(
      Category = ifelse(Category == "In_Set", "Yes", "No"),
      Fraction = Count / ave(Count, Motif, FUN = sum),
      Significant = ifelse(Category == "Yes" & P_Value < 0.05, "*", "")
    )
  
  motif_long$Category <- factor(motif_long$Category, levels = c("Yes", "No"))
  
  label_positions <- motif_long %>%
    dplyr::filter(Category == "Yes") %>%
    mutate(y_pos = Fraction + 0.02)
  
  # Barplot
  p_bar <- ggplot(motif_long, aes(x = Motif, y = Fraction, fill = Category)) +
    geom_bar(stat = "identity", position = "stack") +
    geom_text(data = label_positions %>% filter(Significant != ""),
              aes(x = Motif, y = y_pos, label = Significant),
              size = 6, fontface = "bold", color = "black") +
    scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
    scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
    labs(
      title = paste0("Proportion of ", gs_name, " Genes per Motif"),
      x = "Cormotif Motif",
      y = "Percentage",
      fill = paste0(gs_name, " Gene")
    ) +
    theme_minimal(base_size = 14)
  
  print(p_bar)
}

# ----------------------------
# Generate forest plots per gene set with CI & OR table
# ----------------------------
for(gs_name in names(gene_sets)) {
  df <- enrichment_results %>% dplyr::filter(Gene_Set == gs_name)
  
  # Forest plot
  p_forest <- ggplot(df, aes(x = Odds_Ratio, y = forcats::fct_rev(Motif),
                             xmin = CI_Low, xmax = CI_High)) +
    geom_pointrange(size = 1) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    scale_x_log10() +
    labs(
      x = "Odds Ratio (log scale)",
      y = "Motif",
      title = paste0(gs_name, " Gene Enrichment per Motif")
    ) +
    theme_minimal(base_size = 14)
  
  print(p_forest)
  
  # Print summary table
  table_df <- df %>%
    dplyr::select(Motif, Odds_Ratio, CI_Low, CI_High, P_Value) %>%
    mutate(
      Odds_Ratio = round(Odds_Ratio, 3),
      CI_Low = round(CI_Low, 3),
      CI_High = round(CI_High, 3),
      P_Value = signif(P_Value, 3)
    )
  
  cat("\n---", gs_name, "Enrichment Summary ---\n")
  print(table_df)
}

```

#USE THIS Forest Plot Update AIC DIC DDR p53
```{r Forest Plot Motif 2 vs Motif 1 DDR p53 AIC DIC DEGs}
# ----------------------------
# Define motifs and gene sets
# ----------------------------
motifs <- list(
  M1 = final_genes_1_RUV,
  M2 = final_genes_2_RUV
)

gene_sets <- list(
  DDR = ddr_set,
  P53 = p53_set,
  DIC = AIC_set,
  Fonoudi = fonoudi_ids
)

all_genes <- unique(unlist(motifs))  # universe of tested genes

# ----------------------------
# Direct Motif2 vs Motif1 comparison
# ----------------------------
compare_motifs <- function(motif1, motif2, gene_set, gene_set_name) {
  in_m2 <- sum(motif2 %in% gene_set)
  out_m2 <- length(motif2) - in_m2
  in_m1 <- sum(motif1 %in% gene_set)
  out_m1 <- length(motif1) - in_m1
  
  mat <- matrix(c(in_m2, out_m2, in_m1, out_m1), nrow = 2, byrow = TRUE)
  rownames(mat) <- c("Motif2", "Motif1")
  colnames(mat) <- c("In_Set", "Not_In_Set")
  
  test <- fisher.test(mat)
  
  tibble(
    Gene_Set = gene_set_name,
    Motif_Comparison = "Motif2_vs_Motif1",
    In_Set_M2 = in_m2,
    In_Set_M1 = in_m1,
    Odds_Ratio = as.numeric(test$estimate),
    CI_Low = test$conf.int[1],
    CI_High = test$conf.int[2],
    P_Value = test$p.value
  )
}

# ----------------------------
# Apply for each gene set
# ----------------------------
comparison_results <- map_dfr(names(gene_sets), function(gs_name) {
  compare_motifs(final_genes_1_RUV, final_genes_2_RUV, gene_sets[[gs_name]], gs_name)
})

print(comparison_results)


# ----------------------------
# Forest plot: Motif2 vs Motif1
# ----------------------------

# Forest plot across all gene sets
p_comparison <- ggplot(comparison_results,
                       aes(x = Odds_Ratio, 
                           y = forcats::fct_rev(Gene_Set),
                           xmin = CI_Low, xmax = CI_High)) +
  geom_pointrange(size = 1) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
  scale_x_log10() +
  labs(
    x = "Odds Ratio Sustained vs Recovered (log scale)",
    y = "Gene Set",
    title = "Enrichment of ",
  ) +
  theme_minimal(base_size = 14)

print(p_comparison)

# ----------------------------
# Add percent overlap and significance stars
# ----------------------------
comparison_results <- comparison_results %>%
  mutate(
    Perc_M2 = round((In_Set_M2 / length(final_genes_2_RUV)) * 100, 2),
    Perc_M1 = round((In_Set_M1 / length(final_genes_1_RUV)) * 100, 2),
    Significance = case_when(
      P_Value < 0.001 ~ "***",
      P_Value < 0.01  ~ "**",
      P_Value < 0.05  ~ "*",
      TRUE ~ ""
    ),
    Odds_Ratio = round(Odds_Ratio, 3),
    CI_Low = round(CI_Low, 3),
    CI_High = round(CI_High, 3),
    P_Value = signif(P_Value, 3)
  )

# ----------------------------
# Final summary table
# ----------------------------
summary_table <- comparison_results %>%
  dplyr::select(
    Gene_Set,
    In_Set_M2, Perc_M2,
    In_Set_M1, Perc_M1,
    Odds_Ratio, CI_Low, CI_High, P_Value, Significance
  )

cat("\n--- Sustained vs Recovered Direct Enrichment Summary ---\n")
print(summary_table)

# ----------------------------
# Separate forest plots for each gene set
# ----------------------------
for(gs_name in unique(comparison_results$Gene_Set)) {
  df <- comparison_results %>% filter(Gene_Set == gs_name)
  
  p <- ggplot(df, aes(x = Odds_Ratio, 
                      y = Gene_Set, 
                      xmin = CI_Low, xmax = CI_High)) +
    geom_pointrange(size = 1) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    geom_text(aes(label = Significance, 
                  x = CI_High * 1.2), 
              vjust = 0.5, hjust = 0, size = 6) +
    # scale_x_log10() +
    labs(
      x = "Odds Ratio (Sustained vs Recovered)",
      y = NULL,
      title = paste0("Enrichment of ", gs_name, " in Sustained vs Recovered")
    ) +
    theme_minimal(base_size = 14) +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank())
  
  print(p)
}

#now make a version where DDR and p53 are on the same plot, then save as a pdf and png

# Filter results for DDR and P53 only
comparison_subset <- comparison_results %>%
  filter(Gene_Set %in% c("DDR", "P53"))

# ----------------------------
# Forest plot for DDR + P53 together
# ----------------------------
p_subset <- ggplot(comparison_subset,
                   aes(x = Odds_Ratio, 
                       y = forcats::fct_rev(Gene_Set),
                       xmin = CI_Low, xmax = CI_High)) +
  geom_pointrange(size = 1) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
  geom_text(aes(label = Significance,
                x = CI_High * 1.2),
            vjust = 0.5, hjust = 0, size = 6) +
  # scale_x_log10(limits = c(0.1, 100)) +
  xlim(c(0,30)) +
  labs(
    x = "Odds Ratio Sustained vs Recovered (log scale)",
    y = "Gene Set",
    title = "Enrichment of DDR and P53"
  ) +
  theme_minimal(base_size = 14)

print(p_subset)

#alter appearance to match others
# DDR + P53 forest plot styled like forest_TOP2i
p_subset <- ggplot(comparison_subset,
                   aes(y = Gene_Set, x = Odds_Ratio,
                       xmin = CI_Low, xmax = CI_High)) +
  geom_point(size = 8, color = "#3592DE") +  # large points, single color
  geom_errorbarh(height = 0.5, size = 2, color = "black") +  # thick horizontal bars
  geom_text(aes(label = Significance),
            position = position_nudge(y = 0.2),
            color = "black", fontface = "bold", size = 5) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  # scale_x_log10(limits = c(0.1, 100),
  #               breaks = c(0.1, 1, 10, 100)) +
  xlim(c(0,30)) +
  labs(
    title = "Enrichment of DDR and P53",
    x = "Odds Ratio (log scale)",
    y = NULL
  ) +
  theme_bw(base_size = 14)

print(p_subset)


```

#Updated Forest Plots EMMA
```{r Forest Plots p53 DDR AIC DIC RUV Updates, fig.height=4, fig.width=6}

#motif gene lists
motif1_genes <- final_genes_1_RUV  # Recovered
motif2_genes <- final_genes_2_RUV  # Sustained

#put all gene sets into a list
gene_sets <- list(
  DDR = ddr_set,
  P53 = p53_set,
  DIC = AIC_set,
  Fonoudi = fonoudi_ids
)

#function to test enrichment between motifs
compare_motifs <- function(set_genes, motif1, motif2, set_name) {
  in_m1 <- sum(motif1 %in% set_genes)
  in_m2 <- sum(motif2 %in% set_genes)
  
  out_m1 <- length(motif1) - in_m1
  out_m2 <- length(motif2) - in_m2
  
  fisher_mat <- matrix(c(in_m2, out_m2, in_m1, out_m1), nrow = 2, byrow = TRUE)
  ft <- fisher.test(fisher_mat)
  
  data.frame(
    Gene_Set = set_name,
    Total_Motif1 = length(motif1),
    Total_Motif2 = length(motif2),
    In_Motif1 = in_m1,
    In_Motif2 = in_m2,
    Perc_M1 = round(100 * in_m1 / length(motif1), 1),
    Perc_M2 = round(100 * in_m2 / length(motif2), 1),
    Odds_Ratio = ft$estimate,
    CI_Low = ft$conf.int[1],
    CI_High = ft$conf.int[2],
    P_value = ft$p.value,
    Significance = case_when(
      ft$p.value < 0.001 ~ "***",
      ft$p.value < 0.01  ~ "**",
      ft$p.value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  )
}

#run comparisons for all gene sets
comparison_results <- do.call(rbind, lapply(names(gene_sets), function(gs) {
  compare_motifs(gene_sets[[gs]], motif1_genes, motif2_genes, gs)
}))

#prepare OR/CI for plotting (replace 0 or NA with small number so no error)
comparison_results_plot <- comparison_results %>%
  mutate(
    Odds_Ratio_plot = ifelse(!is.finite(Odds_Ratio) | Odds_Ratio <= 0, 0.01, Odds_Ratio),
    CI_Low_plot    = ifelse(!is.finite(CI_Low)    | CI_Low <= 0, 0.01, CI_Low),
    CI_High_plot   = ifelse(!is.finite(CI_High)   | CI_High <= 0, 0.01, CI_High)
  )


# Shared x-axis limits
# xlims <- c(0.01, 100)

# ----------------------------
# Output directory
# ----------------------------
outdir <- "plots"
if (!dir.exists(outdir)) dir.create(outdir)

# ----------------------------
# Forest plots with counts
# ----------------------------
for(gs_name in unique(comparison_results_plot$Gene_Set)) {
  df <- comparison_results_plot %>% filter(Gene_Set == gs_name)
  
  # Label as "overlap / total"
  df <- df %>% mutate(Label = paste0(In_Motif2, "/", Total_Motif2, " vs ", In_Motif1, "/", Total_Motif1))
  
  p <- ggplot(df, aes(x = Odds_Ratio_plot, y = Gene_Set, xmin = CI_Low_plot, xmax = CI_High_plot)) +
    geom_pointrange(size = 1) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    geom_text(aes(label = Label, x = Odds_Ratio_plot, y = Gene_Set),
              vjust = -1.2, size = 4, color = "black") +
    geom_text(aes(label = Significance, x = CI_High_plot * 1.2),
              vjust = 0.5, hjust = 0, size = 6) +
    # scale_x_log10(limits = xlims) +
    labs(
      x = "Odds Ratio (Sustained vs Recovered, log scale)",
      y = NULL,
      title = paste0("Enrichment of ", gs_name, " in Sustained vs Recovered")
    ) +
    theme_minimal(base_size = 14) +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank())
  
  print(p)
  
  # Save
  ggsave(filename = file.path(outdir, paste0(gs_name, "_forest_EMP_250828.pdf")),
         plot = p, width = 6, height = 4)
  ggsave(filename = file.path(outdir, paste0(gs_name, "_forest_EMP_250828.png")),
         plot = p, width = 6, height = 4, dpi = 300)
}

# ----------------------------
# Save summary table with counts and percentages
# ----------------------------
summary_table <- comparison_results %>%
  dplyr::select(
    Gene_Set,
    Total_Motif1, Total_Motif2,
    In_Motif1, In_Motif2,
    Perc_M1, Perc_M2,
    Odds_Ratio, CI_Low, CI_High, P_value, Significance
  )

# write.csv(summary_table, file.path(outdir, "Motif2_vs_Motif1_summary.csv"), row.names = FALSE)
cat("\n--- Motif2 vs Motif1 Summary ---\n")
print(summary_table)



```

```{r log2cpm 1 gene in Sustained from AIC}
#First, let's find out which gene from AIC is shared with Sustained motif
intersect(AIC_set, mapped_genes_sus)
#29899 gene - GPSM2

#plot a log2cpm boxplot of this gene as I have above

boxplots_cormotif <- boxplot1

#Define gene
GPSM2 <- dplyr::filter(boxplots_cormotif, Entrez_ID == "29899")  

#Now put in the function I want to use to generate boxplots of genes
process_gene_sus_aic <- function(gene) {
  gene_data <- boxplots_cormotif %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in GPSM2) {
  gene_data <- process_gene_sus_aic(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "AIC Sustained Gene")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```
```{r}
#plot Top2A

#plot a log2cpm boxplot of this gene as I have above

boxplots_cormotif <- boxplot1

#Define gene
GPSM2 <- dplyr::filter(boxplots_cormotif, Entrez_ID == "29899")  

#Now put in the function I want to use to generate boxplots of genes
process_gene_sus_aic <- function(gene) {
  gene_data <- boxplots_cormotif %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in GPSM2) {
  gene_data <- process_gene_sus_aic(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "AIC Sustained Gene")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```


#Forest Plots
```{r Motif Forest Plots DEGs vs nonDEGs}
# =====================
# Function to process a gene set
# =====================
analyze_gene_set <- function(entrez_ids, gene_set_name, deg_list, total_background_genes) {
  total_genes <- length(entrez_ids)
  cat(paste0("Total ", gene_set_name, " genes: ", total_genes, "\n"))
  
  # Build dataframe for proportions
  gene_df <- map_dfr(names(deg_list), function(tp) {
    degs <- deg_list[[tp]]
    data.frame(
      Entrez_ID = entrez_ids,
      DEG_status = ifelse(entrez_ids %in% degs, "DEG", "non-DEG"),
      timepoint = tp
    )
  }) %>%
    mutate(timepoint = factor(timepoint, levels = c("24T", "24R", "144R")))
  
  # Count and compute proportions
  prop_df <- gene_df %>%
    dplyr::count(timepoint, DEG_status) %>%
    tidyr::complete(timepoint = factor(levels = c("24T", "24R", "144R")),
                    DEG_status = c("DEG", "non-DEG"),
                    fill = list(n = 0)) %>%
    dplyr::mutate(prop = n / total_genes * 100)
  
  # Stacked bar plot
  bar_plot <- ggplot(prop_df, aes(x = timepoint, y = prop, fill = DEG_status)) +
    geom_bar(stat = "identity", position = "stack", color = "black") +
    geom_text(aes(label = paste0(round(prop,1), "%")),
              position = position_stack(vjust = 0.5), size = 5, color = "white") +
    scale_y_continuous(limits = c(0, 102), expand = c(0, 0)) +
    scale_fill_manual(
      values = c("DEG" = "#377EB8", "non-DEG" = "#E41A1C"),
      labels = c("DEG", paste0("non-DEG (n=", total_genes, ")"))
    ) +
    labs(
      x = "Timepoint",
      y = paste0("Proportion of ", gene_set_name, " Genes (%)"),
      title = paste0("Proportion of ", gene_set_name, " Genes that are DEGs vs non-DEGs"),
      fill = "Status"
    ) +
    theme_minimal(base_size = 14)
  
  print(bar_plot)
  
  # Forest plot
  forest_df <- map_dfr(names(deg_list), function(tp) {
    degs <- deg_list[[tp]]
    
    # contingency table
    DEG_in_set <- sum(entrez_ids %in% degs)
    DEG_not_set <- length(degs) - DEG_in_set
    nonDEG_in_set <- total_genes - DEG_in_set
    nonDEG_not_set <- total_background_genes - total_genes - DEG_not_set
    
    mat <- matrix(c(DEG_in_set, DEG_not_set, nonDEG_in_set, nonDEG_not_set),
                  nrow = 2, byrow = TRUE)
    rownames(mat) <- c(gene_set_name, paste0("non-", gene_set_name))
    colnames(mat) <- c("DEG", "non-DEG")
    
    test <- fisher.test(mat)
    
    tibble(
      timepoint = tp,
      odds_ratio = as.numeric(test$estimate),
      conf_low = test$conf.int[1],
      conf_high = test$conf.int[2],
      p_value = test$p.value,
      sig = ifelse(test$p.value < 0.05, "sig", "ns")
    )
  })
  
  forest_df$timepoint <- factor(forest_df$timepoint, levels = c("24T", "24R", "144R"))
  
  forest_plot <- ggplot(forest_df, aes(x = odds_ratio, y = forcats::fct_rev(timepoint),
                                       xmin = conf_low, xmax = conf_high,
                                       color = sig)) +
    geom_pointrange(size = 1) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    scale_x_log10() +
    scale_color_manual(values = c("sig" = "red", "ns" = "grey")) +
    labs(
      x = "Odds Ratio (log scale)",
      y = "Timepoint",
      title = paste0("Proportion of ", gene_set_name, " Genes that are DEGs vs non-DEGs")
    ) +
    theme_minimal(base_size = 14)
  
  print(forest_plot)
  
  return(list(prop_df = prop_df, forest_df = forest_df))
}

# =====================
# Load DEGs for all timepoints
# =====================
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% dplyr::select(-X)
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% dplyr::select(-X)
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% dplyr::select(-X)

deg_list <- list(
  "24T" = DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05],
  "24R" = DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05],
  "144R" = DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]
)

# Background genes (all genes tested)
all_genes <- rownames(filcpm_matrix)
total_background_genes <- length(all_genes)
cat("Total background genes:", total_background_genes, "\n")

# =====================
# Run for DDR, P53, DIC sets
# =====================
DDR_results <- analyze_gene_set(ddr_set, "DDR", deg_list, total_background_genes)
P53_results <- analyze_gene_set(p53_set, "P53", deg_list, total_background_genes)
DIC_results <- analyze_gene_set(dic_set, "DIC", deg_list, total_background_genes)


```


```{r Forest Plots of Motifs}

# ----------------------------
# Define motifs and gene sets
# ----------------------------
motifs <- list(
  "M1" = final_genes_1_RUV,
  "M2" = final_genes_2_RUV
)

gene_sets <- list(
  DDR = ddr_set,
  P53 = p53_set,
  DIC = dic_set
)

# Background: all genes tested
all_genes <- rownames(filcpm_matrix)
total_background_genes <- length(all_genes)

# ----------------------------
# Function to summarize motifs for a gene set
# ----------------------------
summarize_motif_genes <- function(gene_set, gene_set_name, motifs_list) {
  
  motif_summary <- map_dfr(names(motifs_list), function(motif_name) {
    motif_genes <- motifs_list[[motif_name]]
    non_motif_genes <- setdiff(all_genes, motif_genes)
    
    # Genes in motif that are in the gene set
    in_set <- sum(motif_genes %in% gene_set)
    not_in_set <- length(motif_genes) - in_set
    
    # Contingency table for Fisher's test
    gene_out_set_in_motif <- sum(non_motif_genes %in% gene_set)
    gene_out_set_not_in_motif <- length(non_motif_genes) - gene_out_set_in_motif
    
    mat <- matrix(c(in_set, not_in_set,
                    gene_out_set_in_motif, gene_out_set_not_in_motif),
                  nrow = 2, byrow = TRUE)
    rownames(mat) <- c(motif_name, paste0("Non-", motif_name))
    colnames(mat) <- c("in_set", "not_in_set")
    
    test <- fisher.test(mat)
    
    tibble(
      motif = motif_name,
      gene_set = gene_set_name,
      genes_in_set = in_set,
      total_genes_in_set = length(gene_set),
      odds_ratio = as.numeric(test$estimate),
      conf_low = test$conf.int[1],
      conf_high = test$conf.int[2],
      p_value = test$p.value
    )
  })
  
  # Barplot: proportion of gene set in each motif
  bar_df <- motif_summary %>%
    mutate(non_genes_in_set = total_genes_in_set - genes_in_set) %>%
    pivot_longer(cols = c(genes_in_set, non_genes_in_set),
                 names_to = "Category", values_to = "Count") %>%
    mutate(Category = ifelse(Category == "genes_in_set", "Yes", "No"),
           Fraction = Count / total_genes_in_set)
  
  # Plot barplot
  p_bar <- ggplot(bar_df, aes(x = motif, y = Fraction, fill = Category)) +
    geom_bar(stat = "identity", position = "stack") +
    geom_text(aes(label = scales::percent(Fraction, accuracy = 0.1)),
              position = position_stack(vjust = 0.5), color = "white", size = 5) +
    scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0,1.2)) +
    scale_fill_manual(values = c("Yes" = "#377EB8", "No" = "#E41A1C")) +
    labs(
      title = paste0("Proportion of ", gene_set_name, " Genes in Motifs"),
      x = "Motif",
      y = "Percentage of Gene Set",
      fill = gene_set_name
    ) +
    theme_minimal(base_size = 14)
  
  print(p_bar)
  
  # Forest plot: odds ratios
  p_forest <- ggplot(motif_summary, aes(x = odds_ratio, y = forcats::fct_rev(motif),
                                        xmin = conf_low, xmax = conf_high)) +
    geom_pointrange(size = 1) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "grey40") +
    scale_x_log10() +
    labs(
      title = paste0("Odds Ratio of ", gene_set_name, " Genes in Motifs"),
      x = "Odds Ratio (log scale)",
      y = "Motif"
    ) +
    theme_minimal(base_size = 14)
  
  print(p_forest)
  
  return(motif_summary)
}

# ----------------------------
# Run workflow for all gene sets
# ----------------------------
results_list <- imap(gene_sets, function(gene_set, gs_name) {
  summarize_motif_genes(gene_set, gs_name, motifs)
})

```


```{r AIC Genes Proportion Cormotif RUVs}
#read in my AIC gene set
AIC_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS")

AIC_set <- unique(na.omit(AIC_genes))

#AIC genes inside each motif
in_motif1_AIC <- sum(final_genes_1_RUV %in% AIC_set)
in_motif2_AIC <- sum(final_genes_2_RUV %in% AIC_set)

#non-AIC genes inside each motif
in_motif1_nonAIC <- length(final_genes_1_RUV) - in_motif1_AIC
in_motif2_nonAIC <- length(final_genes_2_RUV) - in_motif2_AIC

#make contingency tables for fishers exact tests
contingency_motifs_AIC <- matrix(c(
  in_motif1_AIC, in_motif1_nonAIC,
  in_motif2_AIC, in_motif2_nonAIC),
  nrow = 2, byrow = TRUE
)

#print the contingency tables
print(contingency_motifs_AIC)

#perform a fisher's exact test (small sample size)
fisher_test_motifs_AIC <- fisher.test(contingency_motifs_AIC)
#print fisher's exact test results
print(fisher_test_motifs_AIC)

#make a summary table of all of these data to plot
motif_summary_AIC <- tibble(
  Motif = c("Motif1", "Motif2"),
  AIC = c(in_motif1_AIC, in_motif2_AIC),
  non_AIC = c(in_motif1_nonAIC, in_motif2_nonAIC)
) %>%
  pivot_longer(cols = c(AIC, non_AIC), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "AIC", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_AIC$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_AIC <- motif_summary_AIC %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_AIC$Category <- factor(motif_summary_AIC$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_AIC, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_AIC %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of AIC Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "AIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_AIC <- in_motif1_AIC / length(final_genes_1_RUV)
prop_motif2_AIC <- in_motif2_AIC / length(final_genes_2_RUV)
p_val_AIC <- fisher_test_motifs_AIC$p.value

cat(sprintf("Motif1: %.2f%% AIC genes (%d/%d)\n", 100*prop_motif1_AIC, in_motif1_AIC, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% AIC genes (%d/%d)\n", 100*prop_motif2_AIC, in_motif2_AIC, length(final_genes_2_RUV)))
cat(sprintf("AIC Fisher's Exact Test p-value: %.5f\n", p_val_AIC))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_AIC$estimate))


```


##p53 Targets Proportion Barplots Redo
```{r p53 Cormotif RUVs Proportion Barplots clustlike + p.post}

#read in my p53 gene set
p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

p53_set <- unique(na.omit(p53_target_genes))

#p53 genes inside each motif
in_motif1_p53 <- sum(final_genes_1_RUV %in% p53_set)
in_motif2_p53 <- sum(final_genes_2_RUV %in% p53_set)

#non-p53 genes inside each motif
in_motif1_nonp53 <- length(final_genes_1_RUV) - in_motif1_p53
in_motif2_nonp53 <- length(final_genes_2_RUV) - in_motif2_p53

#make contingency tables for fishers exact tests
contingency_motifs_p53 <- matrix(c(
  in_motif1_p53, in_motif1_nonp53,
  in_motif2_p53, in_motif2_nonp53),
  nrow = 2, byrow = TRUE
)

#print the contingency tables
print(contingency_motifs_p53)

#perform a fisher's exact test (small sample size)
fisher_test_motifs_p53 <- fisher.test(contingency_motifs_p53)
#print fisher's exact test results
print(fisher_test_motifs_p53)

#make a summary table of all of these data to plot
motif_summary_p53 <- tibble(
  Motif = c("Motif1", "Motif2"),
  p53 = c(in_motif1_p53, in_motif2_p53),
  non_p53 = c(in_motif1_nonp53, in_motif2_nonp53)
) %>%
  pivot_longer(cols = c(p53, non_p53), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_p53$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_p53 <- motif_summary_p53 %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_p53$Category <- factor(motif_summary_p53$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_p53, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53 %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of p53 Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_p53 <- in_motif1_p53 / length(final_genes_1_RUV)
prop_motif2_p53 <- in_motif2_p53 / length(final_genes_2_RUV)
p_val_p53 <- fisher_test_motifs_p53$p.value

cat(sprintf("Motif1: %.2f%% p53 genes (%d/%d)\n", 100*prop_motif1_p53, in_motif1_p53, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% p53 genes (%d/%d)\n", 100*prop_motif2_p53, in_motif2_p53, length(final_genes_2_RUV)))
cat(sprintf("p53 Fisher's Exact Test p-value: %.5f\n", p_val_p53))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_p53$estimate))


```


#Step 1 - Create Dataframes and Combine all ROIs by Image
```{r Create Summary Sheets}
#create a group of this before running the actual function to combine them below
ind_roi_all <- bind_rows(ind2_roi, ind4_roi) %>% 
  mutate(
    Magnification = case_when(
      grepl("10X", ROI_File) ~ "10X",
      grepl("20X", ROI_File) ~ "20X",
      TRUE ~ "Other"
    ),
    Treatment = case_when(
      grepl("DOX", ROI_File) ~ "DOX",
      grepl("DMSO", ROI_File) ~ "DMSO",
      TRUE ~ "Other"
    ),
    Timepoint = case_when(
      grepl("24T", ROI_File) ~ "24T",
      grepl("24R", ROI_File) ~ "24R",
      grepl("144R", ROI_File) ~ "144R",
      TRUE ~ "Other"
    ),
    Condition = paste0(Treatment, Timepoint),
    Individual = case_when(
      grepl("87", ROI_File) ~ "Ind2",
      grepl("75", ROI_File) ~ "Ind4",
      TRUE ~ "Other"
    )
  ) %>% 
  dplyr::filter(Magnification != "Other") %>% 
  dplyr::filter(!grepl("^2nd", ROI_File, ignore.case = TRUE)) %>% 
  dplyr::filter(!grepl("Other", Timepoint, ignore.case = TRUE))

#now that I've read in the csv files for each, I want to collapse them by image
collapse_to_image <- function(roi_df) {
  roi_df %>%
    mutate(Image = gsub("_ROI.*", "", ROI_File),
           Image = gsub("\\.zip$", "", Image),
           Image = trimws(Image)
           ) %>%   
    group_by(Image) %>%
    summarise(
      Mean_of_Mean   = mean(Mean_Intensity, na.rm = TRUE),
      Mean_of_Median = mean(Median_Intensity, na.rm = TRUE),
      Mean_of_Max    = mean(Max_Intensity, na.rm = TRUE),
      Mean_Percent_Red_Positive = mean(Percent_Red_Positive, na.rm = TRUE),
      Mean_Red_Positive_Pixels  = mean(Red_Positive_Pixels, na.rm = TRUE),
      .groups = "drop"
    )
}

#use this for both individuals to create a summary
ind2_img_summary <- collapse_to_image(ind2_roi) %>% mutate(Individual = "Ind2")
ind4_img_summary <- collapse_to_image(ind4_roi) %>% mutate(Individual = "Ind4")

# saveRDS(ind2_img_summary, "data/new/IF_quant/ind2_image_level_summary.RDS")
# saveRDS(ind4_img_summary, "data/new/IF_quant/ind4_image_level_summary.RDS")

ind2_img_summary <- readRDS("data/new/IF_quant/ind2_image_level_summary.RDS")

ind4_img_summary <- readRDS("data/new/IF_quant/ind4_image_level_summary.RDS")

#now that I've made these summaries for both individuals, combine them together
roi_image_level_summary <- bind_rows(ind2_img_summary, ind4_img_summary)

#make sure to remove secondary only samples
roi_image_level_summary <- roi_image_level_summary %>% 
  dplyr::filter(!grepl("^2nd", Image, ignore.case = TRUE))

# saveRDS(roi_image_level_summary, "data/new/IF_quant/roi_image_level_summary.RDS")

roi_image_level_summary <- readRDS("data/new/IF_quant/roi_image_level_summary.RDS")

#now I want to make a metadata table from my image_level_summary with the nuclei counts
image_level_metadata <- read.csv("data/image_level_summary_yH2AX_quant.csv")

image_level_metadata <- image_level_metadata %>%
  mutate(Image = gsub("^Cell_intensity_", "", Image))

image_level_metadata <- image_level_metadata %>%
  filter(!grepl("nucleitest|nucleiedittest|edittest", Image, ignore.case = TRUE))
#remove the nuclei_edit ones I tried since they're not included here

#now integrate these together to get a master summary table
#remove any 2nd only controls and any 10X or 40X images

merged_image_summary <- image_level_metadata %>% 
  dplyr::select(Individual, Treatment, Timepoint, Magnification, Image, Nuclei_Count) %>% 
  dplyr::left_join(roi_image_level_summary, by = c("Image", "Individual")) %>% 
  dplyr::filter(!grepl("40X", Magnification)) %>%
  dplyr::filter(!grepl("^2nd", Image)) %>% 
  dplyr::filter(!grepl("10X", Magnification)) #remove 10X now

#prepare final merged image-level summary
#add in condition so I can join later
merged_image_summary <- merged_image_summary %>%
  mutate(
    Condition = paste0(Treatment, Timepoint)
  ) 

#save this as a csv and rds so I have it for later
# write.csv(merged_image_summary, "data/new/IF_quant/merged_image_level_summary.csv", row.names = FALSE)
# saveRDS(merged_image_summary, "data/new/IF_quant/merged_image_level_summary.RDS")

```

#Step 2 - Select Consistent Nuclei Numbers - 3 Images vs 5
```{r Select Consistent Nuclei Images}

#select top 3 nuclei consistent images per individual/magnification/condition
#with 20% consistency filter
consistent_images_top_nuclei_3 <- merged_image_summary %>%
  group_by(Individual, Magnification, Timepoint, Treatment) %>%
  mutate(Median_Nuclei = median(Nuclei_Count, na.rm = TRUE)) %>%
  # Keep images within 20% of median nuclei
  filter(Nuclei_Count >= 0.8 * Median_Nuclei,
         Nuclei_Count <= 1.2 * Median_Nuclei) %>%
  ungroup() %>%
  group_by(Individual, Magnification, Condition) %>%
  slice_max(order_by = Nuclei_Count, n = 3, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(Percent_Red_Positive = Mean_Percent_Red_Positive)


#select top 5 nuclei consistent images per individual/magnification/condition
#with 20% consistency filter
consistent_images_top_nuclei <- merged_image_summary %>%
  group_by(Individual, Magnification, Timepoint, Treatment) %>%
  mutate(Median_Nuclei = median(Nuclei_Count, na.rm = TRUE)) %>%
  # Keep images within 20% of median nuclei
  filter(Nuclei_Count >= 0.8 * Median_Nuclei,
         Nuclei_Count <= 1.2 * Median_Nuclei) %>%
  ungroup() %>%
  group_by(Individual, Magnification, Condition) %>%
  slice_max(order_by = Nuclei_Count, n = 5, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(Percent_Red_Positive = Mean_Percent_Red_Positive)


```

#Step 3 - Normalize 5 Images by Max Intensity
```{r Normalize 5 Consistent Images by Max Intensity}

#calculate the maximum percentage of red intensity per each magnification
max_percent_per_mag_3 <- consistent_images_top_nuclei_3 %>%
  group_by(Magnification) %>%
  summarise(Max_Percent = max(Mean_of_Max, na.rm = TRUE), .groups = "drop")

max_percent_per_mag_5 <- consistent_images_top_nuclei %>% 
  group_by(Magnification) %>% 
  summarise(Max_Percent = max(Mean_of_Max, na.rm = TRUE), .groups = "drop")

#then make a summary with the percentages for normalization
individual_summary_step3_3 <- consistent_images_top_nuclei_3 %>%
  left_join(max_percent_per_mag, by = "Magnification") %>%
  mutate(Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Percent) * 100)

individual_summary_step3_5 <- consistent_images_top_nuclei %>%
  left_join(max_percent_per_mag, by = "Magnification") %>%
  mutate(Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Percent) * 100)

#normalize the data from the previous step
max_percent_per_mag_3 <- consistent_images_top_nuclei_3 %>%
  group_by(Magnification) %>%
  summarise(Max_Percent = max(Mean_Percent_Red_Positive, na.rm = TRUE), .groups = "drop")

max_percent_per_mag_5 <- consistent_images_top_nuclei %>%
  group_by(Magnification) %>%
  summarise(Max_Percent = max(Mean_Percent_Red_Positive, na.rm = TRUE), .groups = "drop")

#put these into individual summaries for both 3 and 5 consistent nuclei images
individual_summary_step3_3 <- consistent_images_top_nuclei_3 %>%
  left_join(max_percent_per_mag, by = "Magnification") %>%
  mutate(Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Percent) * 100)

individual_summary_step3_5 <- consistent_images_top_nuclei %>%
  left_join(max_percent_per_mag, by = "Magnification") %>%
  mutate(Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Percent) * 100)

```

#Step 4 - Collapse Images by Individual
```{r Mean of Individual}

#collapse per individual for plotting (after normalization)

individual_summary_step4_3 <- individual_summary_step3_3 %>%
  group_by(Magnification, Individual, Treatment, Timepoint, Condition) %>%
  summarise(
    Mean_Percent_Positive = mean(Percent_Red_Positive, na.rm = TRUE),
    .groups = "drop"
  )


individual_summary_step4_5 <- individual_summary_step3_5 %>%
  group_by(Magnification, Individual, Treatment, Timepoint, Condition) %>%
  summarise(
    Mean_Percent_Positive = mean(Percent_Red_Positive, na.rm = TRUE),
    .groups = "drop"
  )



```

#Step 5 - Test for Significance with T tests on Step 4
```{r Statistical Testing - T Tests}

#calculate significance using a t test across conditions
#test DOX vs DMSO at each timepoint

#3 images
stats_t_table_IF_3 <- individual_summary_step4_3 %>%
  filter(Treatment %in% c("DOX","DMSO")) %>%
  group_by(Magnification, Timepoint) %>%
  summarise(
    t_test = list(t.test(Norm_Percent_Positive[Treatment=="DOX"],
                         Norm_Percent_Positive[Treatment=="DMSO"])),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    t_stat = t_test$statistic,
    df = t_test$parameter,
    p_value = t_test$p.value,
    signif = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  ) %>%
  dplyr::select(Magnification, Timepoint, t_stat, df, p_value, signif)

print(stats_t_table_IF_3)

#5 images
stats_t_table_IF_5 <- individual_summary_step4_5 %>%
  filter(Treatment %in% c("DOX","DMSO")) %>%
  group_by(Magnification, Timepoint) %>%
  summarise(
    t_test = list(t.test(Norm_Percent_Positive[Treatment=="DOX"],
                         Norm_Percent_Positive[Treatment=="DMSO"])),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    t_stat = t_test$statistic,
    df = t_test$parameter,
    p_value = t_test$p.value,
    signif = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  ) %>%
  dplyr::select(Magnification, Timepoint, t_stat, df, p_value, signif)

print(stats_t_table_IF_5)

```

```{r Normalized Boxplots Intensity}

plot_individuals_boxplot_step5 <- function(df, mag_label, stats_table) {
  
  df_sub <- df %>% 
    filter(Magnification == mag_label) %>%
    mutate(Condition = factor(Condition, levels = c("DOX24T","DMSO24T",
                                                    "DOX24R","DMSO24R",
                                                    "DOX144R","DMSO144R")))
  
  stats_sub <- stats_table %>% 
    filter(Magnification == mag_label) %>%
    mutate(
      x_pos = case_when(
        Timepoint == "24T"  ~ 1.5,
        Timepoint == "24R"  ~ 3.5,
        Timepoint == "144R" ~ 5.5
      ),
      y_pos = max(df_sub$Norm_Percent_Positive, na.rm = TRUE) * 1.05
    )
  
  ggplot(df_sub, aes(x = Condition, y = Norm_Percent_Positive)) +
    geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
    geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
    geom_text(data = stats_sub,
              aes(x = x_pos, y = y_pos, label = signif),
              inherit.aes = FALSE) +
    labs(title = paste0("Normalized Percent Red Positive - ", mag_label),
         x = "Condition", y = "Normalized Percent Positive (%)") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top")
}

#run plots

plot_individuals_boxplot_step5(individual_summary_step5, "10X", stats_t_table_IF)
plot_individuals_boxplot_step5(individual_summary_step5, "20X", stats_t_table_IF)

```

#Step by Step Boxplots
```{r Boxplots Step by Step}
#plotting functions to check each step along the way

condition_levels <- c("DOX24T", "DOX24R", "DOX144R", "DMSO24T", "DMSO24R", "DMSO144R")

#step 1: all raw data 10X + 20X

plot_step1 <- ggplot(ind_roi_all, 
                     aes(x = paste0(Treatment, Timepoint), y = Percent_Red_Positive)) +
  geom_boxplot() +
  geom_point(aes(color = Individual), alpha = 0.6, size = 1.5, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  scale_x_discrete(limits = condition_levels) +
  labs(title = "Step 1: ROI-Level Percent Red Positive",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step1

#step 1.5: raw image-level summary data

plot_step1.5 <- ggplot(merged_image_summary, 
                       aes(x = Condition, y = Mean_Percent_Red_Positive)) +
  geom_boxplot() +
  geom_point(aes(color = Individual), alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 1.5: Image-Level Percent Red Positive",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  scale_x_discrete(limits = condition_levels) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step1.5


#step 2: selecting consistent nuclei for each condition
plot_step2_3 <- ggplot(consistent_images_top_nuclei_3, 
                     aes(x = Condition, y = Mean_Percent_Red_Positive)) +
  geom_boxplot() +
  geom_point(aes(color = Individual), alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 2: 3 Consistent Nuclei Images per Condition",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  scale_x_discrete(limits = condition_levels) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step2_3

#step 2: selecting consistent nuclei for each condition (5 images)
plot_step2_5 <- ggplot(consistent_images_top_nuclei, 
                     aes(x = Condition, y = Mean_Percent_Red_Positive)) +
  geom_boxplot() +
  geom_point(aes(color = Individual), alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 2: 5 Consistent Nuclei Images per Condition",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  scale_x_discrete(limits = condition_levels) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step2_5

#step 3: normalized 3 images per condition for percent red positive by area

#make individual summaries for consistent images (3 or 5) but not collapsed by individual
individual_summary_step3_3 <- consistent_images_top_nuclei_3 %>%
  left_join(max_percent_per_mag, by = "Magnification") %>%
  mutate(Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Percent) * 100)

individual_summary_step3_5 <- consistent_images_top_nuclei %>%
  left_join(max_percent_per_mag, by = "Magnification") %>%
  mutate(Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Percent) * 100)

#plot step 3: 3 images
plot_step3_3 <- ggplot(individual_summary_step3_3, 
                     aes(x = Condition, y = Norm_Percent_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 4: Normalized Percent Red Positive (0100 scale) (3)",
       x = "Condition", y = "Normalized Percent Positive") +
  theme_bw() +
  scale_x_discrete(limits = condition_levels) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step3_3

#plot step 3: 5 images
plot_step3_5 <- ggplot(individual_summary_step3_5, 
                     aes(x = Condition, y = Norm_Percent_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 3: Normalized Percent Red Positive (0100 scale) (5)",
       x = "Condition", y = "Normalized Percent Positive") +
  theme_bw() +
  scale_x_discrete(limits = condition_levels) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step3_5

#step 4: combined by individual

#combine all 3 images into one point
individual_summary_step4_3 <- individual_summary_step3_3 %>%
  group_by(Magnification, Individual, Treatment, Timepoint, Condition) %>%
  summarise(
    Norm_Percent_Positive = mean(Norm_Percent_Positive, na.rm = TRUE),
    .groups = "drop"
  )

#combine all 5 images into one point
individual_summary_step4_5 <- individual_summary_step3_5 %>%
  group_by(Magnification, Individual, Treatment, Timepoint, Condition) %>%
  summarise(
    Norm_Percent_Positive = mean(Norm_Percent_Positive, na.rm = TRUE),
    .groups = "drop"
  )

#plot boxplots of consolidated individual (3 images) normalized
plot_step4_3 <- ggplot(individual_summary_step4_3, 
                     aes(x = Condition, y = Norm_Percent_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 4: Normalized Percent Positive by Individual (3)",
       x = "Condition", y = "Mean Percent Red Positive") +
  theme_bw() +
  scale_x_discrete(limits = condition_levels) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step4_3

#plot boxplots of consolidated individual (5 images) normalized 
plot_step4_5 <- ggplot(individual_summary_step4_5, 
                     aes(x = Condition, y = Norm_Percent_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 4: Normalized Percent Positive by Individual (5)",
       x = "Condition", y = "Mean Percent Red Positive") +
  theme_bw() +
  scale_x_discrete(limits = condition_levels) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

plot_step4_5

#step 5: statistical testing with t tests across conditions

#3 images
stats_t_table_IF_3 <- individual_summary_step4_3 %>%
  filter(Treatment %in% c("DOX","DMSO")) %>%
  group_by(Magnification, Timepoint) %>%
  summarise(
    t_test = list(t.test(Norm_Percent_Positive[Treatment=="DOX"],
                         Norm_Percent_Positive[Treatment=="DMSO"])),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    t_stat = t_test$statistic,
    df = t_test$parameter,
    p_value = t_test$p.value,
    signif = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  ) %>%
  dplyr::select(Magnification, Timepoint, t_stat, df, p_value, signif)

print(stats_t_table_IF_3)

#5 images
stats_t_table_IF_5 <- individual_summary_step4_5 %>%
  filter(Treatment %in% c("DOX","DMSO")) %>%
  group_by(Magnification, Timepoint) %>%
  summarise(
    t_test = list(t.test(Norm_Percent_Positive[Treatment=="DOX"],
                         Norm_Percent_Positive[Treatment=="DMSO"])),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    t_stat = t_test$statistic,
    df = t_test$parameter,
    p_value = t_test$p.value,
    signif = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  ) %>%
  dplyr::select(Magnification, Timepoint, t_stat, df, p_value, signif)

print(stats_t_table_IF_5)


plot_individuals_boxplot_step5 <- function(df, mag_label, stats_table) {
  
  df_sub <- df %>% 
    filter(Magnification == mag_label) %>%
    mutate(Condition = factor(Condition, levels = c("DOX24T","DMSO24T",
                                                    "DOX24R","DMSO24R",
                                                    "DOX144R","DMSO144R")))
  
  stats_sub <- stats_table %>% 
    filter(Magnification == mag_label) %>%
    mutate(
      x_pos = case_when(
        Timepoint == "24T"  ~ 1.5,
        Timepoint == "24R"  ~ 3.5,
        Timepoint == "144R" ~ 5.5
      ),
      y_pos = max(df_sub$Norm_Percent_Positive, na.rm = TRUE) * 1.05
    )
  
  ggplot(df_sub, aes(x = Condition, y = Norm_Percent_Positive)) +
    geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
    geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
    geom_text(data = stats_sub,
              aes(x = x_pos, y = y_pos, label = signif),
              inherit.aes = FALSE) +
    labs(title = paste0("Normalized Percent Red Positive - ", mag_label),
         x = "Condition", y = "Normalized Percent Positive (%)") +
    theme_bw() +
    scale_x_discrete(limits = condition_levels) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top")
}

#run plots

step5_boxplot_10x_3 <- plot_individuals_boxplot_step5(individual_summary_step4_3, "10X", stats_t_table_IF_3)
step5_boxplot_10x_5 <- plot_individuals_boxplot_step5(individual_summary_step4_5, "10X", stats_t_table_IF_5)
step5_boxplot_20x_3 <- plot_individuals_boxplot_step5(individual_summary_step4_3, "20X", stats_t_table_IF)
step5_boxplot_20x_5 <- plot_individuals_boxplot_step5(individual_summary_step4_5, "20X", stats_t_table_IF)

#print plots
step5_boxplot_10x_3
step5_boxplot_10x_5
step5_boxplot_20x_3
step5_boxplot_20x_5
```

```{r Test Significance on Step 3}

#3 images
stats_t_table_IF_3_3 <- individual_summary_step3_3 %>%
  filter(Treatment %in% c("DOX","DMSO")) %>%
  group_by(Magnification, Timepoint) %>%
  summarise(
    t_test = list(t.test(Norm_Percent_Positive[Treatment=="DOX"],
                         Norm_Percent_Positive[Treatment=="DMSO"])),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    t_stat = t_test$statistic,
    df = t_test$parameter,
    p_value = t_test$p.value,
    signif = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  ) %>%
  dplyr::select(Magnification, Timepoint, t_stat, df, p_value, signif)

print(stats_t_table_IF_3_3)

#5 images
stats_t_table_IF_3_5 <- individual_summary_step3_5 %>%
  filter(Treatment %in% c("DOX","DMSO")) %>%
  group_by(Magnification, Timepoint) %>%
  summarise(
    t_test = list(t.test(Norm_Percent_Positive[Treatment=="DOX"],
                         Norm_Percent_Positive[Treatment=="DMSO"])),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    t_stat = t_test$statistic,
    df = t_test$parameter,
    p_value = t_test$p.value,
    signif = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  ) %>%
  dplyr::select(Magnification, Timepoint, t_stat, df, p_value, signif)

print(stats_t_table_IF_3_5)


plot_individuals_boxplot_step3 <- function(df, mag_label, stats_table) {
  
  df_sub <- df %>% 
    filter(Magnification == mag_label) %>%
    mutate(Condition = factor(Condition, levels = c("DOX24T","DMSO24T",
                                                    "DOX24R","DMSO24R",
                                                    "DOX144R","DMSO144R")))
  
  stats_sub <- stats_table %>% 
    filter(Magnification == mag_label) %>%
    mutate(
      x_pos = case_when(
        Timepoint == "24T"  ~ 1.5,
        Timepoint == "24R"  ~ 3.5,
        Timepoint == "144R" ~ 5.5
      ),
      y_pos = max(df_sub$Norm_Percent_Positive, na.rm = TRUE) * 1.05
    )
  
  ggplot(df_sub, aes(x = Condition, y = Norm_Percent_Positive)) +
    geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
    geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
    geom_text(data = stats_sub,
              aes(x = x_pos, y = y_pos, label = signif),
              inherit.aes = FALSE) +
    labs(title = paste0("Normalized Percent Red Positive - ", mag_label),
         x = "Condition", y = "Normalized Percent Positive (%)") +
    theme_bw() +
    scale_x_discrete(limits = condition_levels) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top")
}

#run plots

step5_boxplot_10x_3_3 <- plot_individuals_boxplot_step3(individual_summary_step3_3, "10X", stats_t_table_IF_3_3)
step5_boxplot_10x_3_5 <- plot_individuals_boxplot_step3(individual_summary_step3_5, "10X", stats_t_table_IF_3_5)
step5_boxplot_20x_3_3 <- plot_individuals_boxplot_step3(individual_summary_step3_3, "20X", stats_t_table_IF_3_3)
step5_boxplot_20x_3_5 <- plot_individuals_boxplot_step3(individual_summary_step3_5, "20X", stats_t_table_IF_3_5)

#print plots
step5_boxplot_10x_3_3
step5_boxplot_10x_3_5
step5_boxplot_20x_3_3
step5_boxplot_20x_3_5
```


```{r Plot Step 4 Stats Image Level}
# Function for Step 4 plots with Step 3 stats
plot_step4_with_step3_stats <- function(df, mag_label, stats_table) {
  
  df_sub <- df %>% 
    filter(Magnification == mag_label) %>%
    mutate(Condition = factor(Condition, levels = c("DOX24T","DMSO24T",
                                                    "DOX24R","DMSO24R",
                                                    "DOX144R","DMSO144R")))
  
  stats_sub <- stats_table %>% 
    filter(Magnification == mag_label) %>%
    mutate(
      x_pos = case_when(
        Timepoint == "24T"  ~ 1.5,
        Timepoint == "24R"  ~ 3.5,
        Timepoint == "144R" ~ 5.5
      ),
      y_pos = max(df_sub$Norm_Percent_Positive, na.rm = TRUE) * 1.05
    )
  
  ggplot(df_sub, aes(x = Condition, y = Norm_Percent_Positive)) +
    geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
    geom_point(aes(color = Individual), alpha = 0.6, size = 3) +
    geom_text(data = stats_sub,
              aes(x = x_pos, y = y_pos, label = signif),
              inherit.aes = FALSE) +
    labs(title = paste0("Normalized Red Intensity per Area per Individual - ", mag_label),
         x = "Condition", y = "Normalized Percent Positive (%)") +
    theme_bw() +
    scale_x_discrete(limits = condition_levels) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top")
}

# Example usage:
plot_step4_with_step3_stats(individual_summary_step4_3, "10X", stats_t_table_IF_3_3)
plot_step4_with_step3_stats(individual_summary_step4_5, "20X", stats_t_table_IF_3_5)

```

#swap 3 and 5 to do stats on image level

#now do DOX/VEH
```{r Step 6 DOX/VEH}

# -----------------------------
# Step 5: DOX/VEH ratio for plotting (Step 4 consolidated)
# -----------------------------

# 3 images
DOX_VEH_ratio_3 <- individual_summary_step4_3 %>%
  dplyr::select(Magnification, Timepoint, Individual, Treatment, Norm_Percent_Positive) %>%
  pivot_wider(names_from = Treatment, values_from = Norm_Percent_Positive) %>%
  mutate(
    DOX = as.numeric(DOX),
    DMSO = as.numeric(DMSO),
    DOX_over_VEH = (DOX / DMSO) #fold change
  )

# 5 images
DOX_VEH_ratio_5 <- individual_summary_step4_5 %>%
  dplyr::select(Magnification, Timepoint, Individual, Treatment, Norm_Percent_Positive) %>%
  pivot_wider(names_from = Treatment, values_from = Norm_Percent_Positive) %>%
  mutate(
    DOX = as.numeric(DOX),
    DMSO = as.numeric(DMSO),
    DOX_over_VEH = (DOX / DMSO) #fold change
  )

# -----------------------------
# Step 6: Prepare Step 3 image-level data for t-tests
# -----------------------------

#3 images
DOX_VEH_step3_3 <- individual_summary_step3_3 %>%
  dplyr::select(Magnification, Timepoint, Individual, Treatment, Norm_Percent_Positive) %>%
  pivot_wider(names_from = Treatment, values_from = Norm_Percent_Positive) %>%
  mutate(
    DOX = as.numeric(DOX),
    DMSO = as.numeric(DMSO),
    DOX_over_VEH = (DOX / DMSO)
  )

#5 images
DOX_VEH_step3_5 <- individual_summary_step3_5 %>%
  dplyr::select(Magnification, Timepoint, Individual, Treatment, Norm_Percent_Positive) %>%
  pivot_wider(names_from = Treatment, values_from = Norm_Percent_Positive) %>%
  mutate(
    DOX = as.numeric(DOX),
    DMSO = as.numeric(DMSO),
    DOX_over_VEH = (DOX / DMSO) * 100
  )

# -----------------------------
# Step 3: Pairwise t-tests across timepoints (image-level)
# -----------------------------

# Choose 3 or 5 images for t-tests
DOX_VEH_step3 <- DOX_VEH_step3_3  # or DOX_VEH_step3_5

timepoint_tests_image <- DOX_VEH_step3 %>%
  group_by(Magnification) %>%
  pairwise_t_test(
    DOX_over_VEH ~ Timepoint,
    p.adjust.method = "BH"
  ) %>%
  mutate(
    y.position = max(DOX_VEH_step3$DOX_over_VEH, na.rm = TRUE) * 1.05,
    label = case_when(
      p.adj < 0.001 ~ "***",
      p.adj < 0.01  ~ "**",
      p.adj < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  )

# -----------------------------
# Step 4: Plot DOX/VEH fold change with significance brackets
# -----------------------------

timepoint_levels <- c("24T", "24R", "144R")  # ensure usual order

# Choose 3 or 5 images for plotting
DOX_VEH_plot <- DOX_VEH_ratio_3  # or DOX_VEH_ratio_5

ggplot(DOX_VEH_plot, aes(x = factor(Timepoint, levels = timepoint_levels), y = DOX_over_VEH)) +
  geom_boxplot(fill = "lightblue", alpha = 0.6) +
  geom_point(aes(color = Individual), size = 3, position = position_jitter(width = 0.1)) +
  facet_wrap(~Magnification, scales = "free_x") +
  stat_pvalue_manual(
    timepoint_tests_image,
    label = "label",
    x = "group1",
    xend = "group2",
    y.position = "y.position",
    tip.length = 0.02,
    bracket.size = 0.5
  ) +
  geom_hline(yintercept = 100, linetype = "dashed", color = "red") +  # reference line at no change
  labs(
    title = "DOX / VEH Fold Change (%) - Pairwise Timepoint Comparisons",
    x = "Timepoint",
    y = "DOX / VEH Fold Change (%)"
  ) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")



```


#IF Quant Swap Order
```{r IF Workflow Swap 3 and 4}
# =============================
# Standardize ROI-level data
# =============================
ind_roi_all <- ind_roi_all %>%
  dplyr::mutate(
    Image = gsub("\\.zip$", "", ROI_File),
    Image = gsub("_ROI.*", "", Image),
    Image = trimws(Image)
  ) %>%
  dplyr::select(-ROI_File)

# Add Condition column
ind_roi_all <- ind_roi_all %>%
  dplyr::mutate(
    Condition = paste0(Treatment, Timepoint),
    Condition = factor(Condition, levels = c("DOX24T","DMSO24T","DOX24R","DMSO24R","DOX144R","DMSO144R"))
  )

merged_image_summary <- merged_image_summary %>%
  dplyr::mutate(
    Condition = paste0(Treatment, Timepoint),
    Condition = factor(Condition, levels = c("DOX24T","DMSO24T","DOX24R","DMSO24R","DOX144R","DMSO144R"))
  )

# =========================================
# Step 1: All ROI points
# =========================================
plot_step1 <- ggplot(ind_roi_all,
                     aes(x = Condition, y = Mean_Percent_Red_Positive, color = Individual)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(alpha = 0.6, size = 1.5, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 1: All ROI Points", x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# =========================================
# Step 1.5: ROI points summarized per image
# =========================================
roi_image_summary <- merged_image_summary %>%
  dplyr::group_by(Image, Individual, Magnification, Condition, Treatment, Timepoint) %>%
  dplyr::summarise(
    Mean_Percent_Red_Positive = mean(Mean_Percent_Red_Positive, na.rm = TRUE),
    Mean_Red_Positive_Pixels = mean(Mean_Red_Positive_Pixels, na.rm = TRUE),
    Nuclei_Count = mean(Nuclei_Count, na.rm = TRUE),
    .groups = "drop"
  )

plot_step1_5 <- ggplot(roi_image_summary,
                       aes(x = Condition, y = Mean_Percent_Red_Positive, color = Individual)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 1.5: ROI Points Summarized per Image",
       x = "Condition", y = "Mean Percent Red Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# =========================================
# Step 2: Top 5 nuclei images per condition
# =========================================
consistent_images <- roi_image_summary %>%
  dplyr::group_by(Individual, Magnification, Condition) %>%
  dplyr::slice_max(order_by = Nuclei_Count, n = 5, with_ties = FALSE) %>%
  dplyr::ungroup()

plot_step2 <- ggplot(consistent_images,
                     aes(x = Condition, y = Mean_Percent_Red_Positive, color = Individual)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 2: Top 5 Nuclei Images per Condition",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# =========================================
# Step 3: Normalize by max intensity per magnification
# =========================================
# Find global max intensity per magnification
global_max <- consistent_images %>%
  dplyr::group_by(Magnification) %>%
  dplyr::summarise(Max_Intensity = max(Mean_Red_Positive_Pixels, na.rm = TRUE),
                   .groups = "drop")

consistent_images_norm <- consistent_images %>%
  dplyr::left_join(global_max, by = "Magnification") %>%
  dplyr::mutate(Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Intensity) * 100)

plot_step3 <- ggplot(consistent_images_norm,
                     aes(x = Condition, y = Norm_Percent_Positive, color = Individual)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 3: Normalized Percent Red Positive per Image",
       x = "Condition", y = "Normalized Percent Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# =========================================
# Step 4: Mean per individual
# =========================================
individual_summary <- consistent_images_norm %>%
  dplyr::group_by(Individual, Magnification, Condition, Treatment, Timepoint) %>%
  dplyr::summarise(
    Mean_Norm_Percent_Positive = mean(Norm_Percent_Positive, na.rm = TRUE),
    .groups = "drop"
  )

plot_step4 <- ggplot(individual_summary,
                     aes(x = Condition, y = Mean_Norm_Percent_Positive, color = Individual)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(alpha = 0.6, size = 3, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 4: Mean Normalized Percent Positive per Individual",
       x = "Condition", y = "Mean Normalized Percent Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# =========================================
# Step 5: Statistical testing per condition
# =========================================
stats_t_table_IF <- individual_summary %>%
  dplyr::group_by(Magnification, Timepoint) %>%
  dplyr::summarise(
    t_test = list(t.test(Mean_Norm_Percent_Positive ~ Treatment)),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    t_stat = sapply(t_test, function(x) x$statistic),
    df     = sapply(t_test, function(x) x$parameter),
    P_value = sapply(t_test, function(x) x$p.value),
    signif = cut(P_value, breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
                  labels = c("***","**","*","ns"))
  )

# Step 5 plot function
plot_step5 <- function(df, stats_table, mag_label){
  df_sub <- df %>% dplyr::filter(Magnification == mag_label)
  stats_sub <- stats_table %>% dplyr::filter(Magnification == mag_label) %>%
    dplyr::mutate(x_pos = case_when(Timepoint == "24T"  ~ 1.5,
                                    Timepoint == "24R"  ~ 3.5,
                                    Timepoint == "144R" ~ 5.5),
                  y_pos = max(df_sub$Mean_Norm_Percent_Positive, na.rm = TRUE)*1.05)
  
  ggplot(df_sub, aes(x = Condition, y = Mean_Norm_Percent_Positive, color = Individual)) +
    geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
    geom_point(alpha = 0.6, size = 3, position = position_identity()) +
    geom_text(data = stats_sub, aes(x = x_pos, y = y_pos, label = signif),
              inherit.aes = FALSE) +
    labs(title = paste0("Step 5: Normalized Percent Positive with t-tests - ", mag_label),
         x = "Condition", y = "Mean Normalized Percent Positive") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top")
}

plot_step5_10X <- plot_step5(individual_summary, stats_t_table_IF, "10X")
plot_step5_20X <- plot_step5(individual_summary, stats_t_table_IF, "20X")

# =========================================
# Step 6: DOX/VEH ratio per individual
# =========================================
ratio_summary <- individual_summary %>%
  dplyr::group_by(Individual, Magnification, Timepoint) %>%
  dplyr::summarise(
    DOX = Mean_Norm_Percent_Positive[Treatment=="DOX"],
    VEH = Mean_Norm_Percent_Positive[Treatment=="DMSO"],
    DOX_VEH_Ratio = DOX / VEH,
    .groups = "drop"
  )

plot_step6 <- ggplot(ratio_summary,
                     aes(x = Timepoint, y = DOX_VEH_Ratio, color = Individual)) +
  geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
  geom_point(alpha = 0.6, size = 3, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  labs(title = "Step 6: DOX / VEH Ratio per Individual",
       x = "Timepoint", y = "DOX / VEH") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# =========================================
# Step 7: Statistical testing across timepoints
# =========================================

# Ensure Timepoint is factored correctly
ratio_summary <- ratio_summary %>%
  dplyr::mutate(Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R")))

# Define the comparisons
timepoint_comparisons <- list(
  c("24T", "24R"),
  c("24R", "144R"),
  c("24T", "144R")
)

# Compute t-tests and prepare stats table
stats_step7 <- ratio_summary %>%
  dplyr::group_by(Magnification) %>%
  do({
    df_sub <- .
    results <- lapply(timepoint_comparisons, function(tp) {
      group1 <- df_sub %>% dplyr::filter(Timepoint == tp[1]) %>% dplyr::pull(DOX_VEH_Ratio)
      group2 <- df_sub %>% dplyr::filter(Timepoint == tp[2]) %>% dplyr::pull(DOX_VEH_Ratio)
      if(length(group1) < 1 | length(group2) < 1) return(NULL) # skip if missing
      test <- t.test(group1, group2)
      data.frame(
        Magnification = unique(df_sub$Magnification),
        Comparison = paste(tp[1], "vs", tp[2]),
        x_start = as.numeric(factor(tp[1], levels=c("24T","24R","144R"))),
        x_end   = as.numeric(factor(tp[2], levels=c("24T","24R","144R"))),
        y_pos   = max(df_sub$DOX_VEH_Ratio, na.rm = TRUE) * 1.05,
        t_stat  = test$statistic,
        df      = test$parameter,
        P_value = test$p.value,
        signif  = dplyr::case_when(
          test$p.value < 0.001 ~ "***",
          test$p.value < 0.01  ~ "**",
          test$p.value < 0.05  ~ "*",
          TRUE ~ "ns"
        )
      )
    })
    do.call(rbind, results)
  }) %>%
  dplyr::ungroup()

# Plotting function for Step 7
plot_step7_ratio <- function(df, stats_table, mag_label) {
  df_sub <- df %>% dplyr::filter(Magnification == mag_label)
  stats_sub <- stats_table %>% dplyr::filter(Magnification == mag_label)
  
  ggplot(df_sub, aes(x=Timepoint, y=DOX_VEH_Ratio)) +
    geom_boxplot(alpha=0.6, fill="lightgray", outlier.shape = NA) +
    geom_point(aes(color=Individual), alpha=0.6, size=3, position=position_identity()) +
    # Draw lines for comparisons
    geom_segment(data=stats_sub, 
                 aes(x=x_start, xend=x_end, y=y_pos, yend=y_pos),
                 inherit.aes=FALSE) +
    # Add significance stars
    geom_text(data=stats_sub, aes(x=(x_start+x_end)/2, y=y_pos*1.02, label=signif),
              inherit.aes=FALSE, size=5) +
    scale_x_discrete(limits = levels(df_sub$Timepoint)) +
    labs(title=paste0("Step 7: DOX/VEH Ratio Comparisons - ", mag_label),
         x="Timepoint", y="DOX / VEH Ratio") +
    theme_bw() +
    theme(axis.text.x=element_text(angle=45, hjust=1),
          legend.position="top")
}

# Generate plots for 10X and 20X
plot_step7_10X <- plot_step7_ratio(ratio_summary, stats_step7, "10X")
plot_step7_20X <- plot_step7_ratio(ratio_summary, stats_step7, "20X")

# Print stats table
stats_step7
```

#test IF quant
```{r Step 6 and 7 Test}

# =========================================
# Step 1: Ensure Timepoint is factored correctly
# =========================================
individual_summary <- individual_summary %>%
  mutate(Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R")))

# =========================================
# Step 2: Compute DOX/VEH ratios per individual
# =========================================
ratio_summary <- individual_summary %>%
  filter(Magnification == "20X") %>%
  mutate(Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"))) %>%
  pivot_wider(names_from = Treatment, values_from = Mean_Norm_Percent_Positive) %>%
  # Add a small offset to avoid division by zero
  mutate(DOX_VEH_Ratio = DOX / (DMSO + 1e-6))  # tiny number added if DMSO=0

# =========================================
# Step 3: Define timepoint comparisons
# =========================================
timepoint_comparisons <- list(
  c("24T", "24R"),
  c("24R", "144R"),
  c("24T", "144R")
)

# =========================================
# Step 4: Compute t-tests per Magnification
# =========================================
stats_step7 <- ratio_summary %>%
  group_by(Magnification) %>%
  do({
    df_sub <- .
    results <- lapply(timepoint_comparisons, function(tp) {
      group1 <- df_sub %>% filter(Timepoint == tp[1]) %>% pull(DOX_VEH_Ratio)
      group2 <- df_sub %>% filter(Timepoint == tp[2]) %>% pull(DOX_VEH_Ratio)
      if(length(group1) < 1 | length(group2) < 1) return(NULL)
      
      test <- t.test(group1, group2)
      
      data.frame(
        Magnification = unique(df_sub$Magnification),
        Comparison = paste(tp[1], "vs", tp[2]),
        x_start = as.numeric(factor(tp[1], levels = c("24T","24R","144R"))),
        x_end   = as.numeric(factor(tp[2], levels = c("24T","24R","144R"))),
        y_pos   = max(df_sub$DOX_VEH_Ratio, na.rm = TRUE) * 1.05,
        t_stat  = test$statistic,
        df      = test$parameter,
        P_value = test$p.value,
        signif  = case_when(
          test$p.value < 0.001 ~ "***",
          test$p.value < 0.01  ~ "**",
          test$p.value < 0.05  ~ "*",
          TRUE ~ "ns"
        )
      )
    })
    do.call(rbind, results)
  }) %>%
  ungroup()

# =========================================
# Step 5: Function to plot by magnification
# =========================================
plot_step7_ratio <- function(df, stats_table, mag_label) {
  df_sub <- df %>% filter(Magnification == mag_label)
  stats_sub <- stats_table %>% filter(Magnification == mag_label)
  
  ggplot(df_sub, aes(x = Timepoint, y = DOX_VEH_Ratio)) +
    geom_boxplot(alpha = 0.6, fill = "lightgray", outlier.shape = NA) +
    geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
    # Lines for comparisons
    geom_segment(data = stats_sub, 
                 aes(x = x_start, xend = x_end, y = y_pos, yend = y_pos),
                 inherit.aes = FALSE) +
    geom_text(data = stats_sub, 
              aes(x = (x_start + x_end)/2, y = y_pos*1.02, label = signif),
              inherit.aes = FALSE, size = 5) +
    scale_x_discrete(limits = levels(df_sub$Timepoint)) +
    labs(title = paste0("DOX/VEH Ratio Comparisons - ", mag_label),
         x = "Timepoint", y = "DOX / VEH Ratio") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top")
}

# =========================================
# Step 6: Generate separate plots
# =========================================
plot_10X <- plot_step7_ratio(ratio_summary, stats_step7, "10X")
plot_20X <- plot_step7_ratio(ratio_summary, stats_step7, "20X")

# =========================================
# Step 7: Print the stats table
# =========================================
stats_step7


```


```{r IF Quant Updated}

# library(dplyr)
# library(ggplot2)
# library(tidyr)
# library(purrr)

# ---------------------------
# Factor levels
# ---------------------------
condition_levels <- c("DOX24T","DMSO24T","DOX24R","DMSO24R","DOX144R","DMSO144R")
timepoint_levels <- c("24T","24R","144R")

# ---------------------------
# Step 1: ROI-level percent red positive
# ---------------------------
plot_step1 <- ggplot(ind_roi_all, 
                     aes(x = paste0(Treatment, Timepoint), y = Percent_Red_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightblue", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 1.5, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  scale_x_discrete(limits = condition_levels) +
  labs(title = "Step 1: ROI-Level Percent Red Positive",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# ---------------------------
# Step 1.5: Image-level percent red positive
# ---------------------------
plot_step1.5 <- ggplot(merged_image_summary, 
                       aes(x = Condition, y = Mean_Percent_Red_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightblue", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  scale_x_discrete(limits = condition_levels) +
  labs(title = "Step 1.5: Image-Level Percent Red Positive",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# ---------------------------
# Step 2: select top 5 nuclei per condition
# ---------------------------
top5_images <- merged_image_summary %>%
  dplyr::group_by(Individual, Magnification, Condition) %>%
  dplyr::slice_max(order_by = Nuclei_Count, n = 5, with_ties = FALSE) %>%
  dplyr::ungroup()

plot_step2 <- ggplot(top5_images,
                     aes(x = Condition, y = Mean_Percent_Red_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightgreen", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 2, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  scale_x_discrete(limits = condition_levels) +
  labs(title = "Step 2: Top 5 Nuclei Images per Condition",
       x = "Condition", y = "Percent Red Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# ---------------------------
# Step 3: normalize top 5 images per individual
# ---------------------------
global_max <- max(top5_images$Mean_Percent_Red_Positive, na.rm = TRUE)

consistent_images_step3 <- consistent_images_top_nuclei %>%
  dplyr::group_by(Magnification) %>%
  dplyr::mutate(
    Max_Global = max(Max_Intensity, na.rm = TRUE),
    Norm_Percent_Positive = (Mean_Percent_Red_Positive / Max_Global) * 100
  ) %>%
  dplyr::ungroup()


individual_summary_step3 <- individual_summary_step3 %>%
  dplyr::mutate(
    Condition = as.character(Condition),
    Timepoint = substr(Condition, nchar(Condition)-2+1, nchar(Condition)),
    Condition = factor(Condition, levels = condition_levels),
    Timepoint = factor(Timepoint, levels = timepoint_levels)
  )

plot_step3 <- ggplot(individual_summary_step3,
                     aes(x = Condition, y = Norm_Percent_Positive)) +
  geom_boxplot(alpha = 0.6, fill = "lightcoral", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
  facet_wrap(~Magnification, scales = "free_x") +
  scale_x_discrete(limits = condition_levels) +
  labs(title = "Step 3: Normalized Percent Red Positive per Individual",
       x = "Condition", y = "Normalized Percent Positive") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")

# ---------------------------
# Step 4: mean of normalized top 5 per individual
# ---------------------------
plot_step4 <- plot_step3 # same plot, already normalized per individual

# ---------------------------
# Step 5: t-tests DOX vs VEH at each timepoint per magnification
# ---------------------------
stats_t_table_step5 <- individual_summary_step3 %>%
  dplyr::mutate(Timepoint = substr(Condition, nchar(Condition)-2+1, nchar(Condition))) %>%
  dplyr::group_by(Magnification, Timepoint) %>%
  dplyr::summarise(
    t_test = list(t.test(Norm_Percent_Positive ~ substr(Condition,1,3), data = dplyr::cur_data())),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    p_value = sapply(t_test, function(x) x$p.value),
    signif = dplyr::case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01  ~ "**",
      p_value < 0.05  ~ "*",
      TRUE            ~ "ns"
    ),
    x_pos = dplyr::case_when(
      Timepoint == "24T" ~ 1.5,
      Timepoint == "24R" ~ 3.5,
      Timepoint == "144R" ~ 5.5
    ),
    y_pos = max(individual_summary_step3$Norm_Percent_Positive, na.rm = TRUE)*1.05
  )

plot_step5 <- function(df, mag_label, stats_table){
  df_sub <- df %>% dplyr::filter(Magnification == mag_label)
  stats_sub <- stats_table %>% dplyr::filter(Magnification == mag_label)
  
  ggplot(df_sub, aes(x = Condition, y = Norm_Percent_Positive)) +
    geom_boxplot(alpha = 0.6, fill = "lightcoral", outlier.shape = NA) +
    geom_point(aes(color = Individual), alpha = 0.6, size = 3, position = position_identity()) +
    geom_text(data = stats_sub, aes(x = x_pos, y = y_pos, label = signif), inherit.aes = FALSE) +
    facet_wrap(~Magnification, scales = "free_x") +
    scale_x_discrete(limits = condition_levels) +
    labs(title = paste0("Step 5: Normalized Percent Positive w/ t-tests - ", mag_label),
         x = "Condition", y = "Normalized Percent Positive (%)") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "top")
}

plot_step5_10X <- plot_step5(individual_summary_step3, "10X", stats_t_table_step5)
plot_step5_20X <- plot_step5(individual_summary_step3, "20X", stats_t_table_step5)

# ---------------------------
# Step 6: DOX/VEH ratio per individual (%)
# ---------------------------
step6_ratio <- individual_summary_step3 %>%
  tidyr::separate(Condition, into=c("Treatment","Timepoint"), sep="(?<=DOX|DMSO)") %>%
  dplyr::group_by(Individual, Magnification, Timepoint) %>%
  dplyr::summarise(
    DOX = Norm_Percent_Positive[Treatment=="DOX"],
    VEH = Norm_Percent_Positive[Treatment=="DMSO"],
    DOX_VEH_Percent = (DOX/VEH)*100,
    .groups = "drop"
  ) %>%
  dplyr::mutate(Timepoint = factor(Timepoint, levels = timepoint_levels))

plot_step6 <- ggplot(step6_ratio,
                     aes(x = Timepoint, y = DOX_VEH_Percent)) +
  geom_boxplot(alpha = 0.6, fill="lightgoldenrod", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 3) +
  facet_wrap(~Magnification, scales="free_x") +
  labs(title = "Step 6: DOX/VEH Percent Positive per Individual",
       x = "Timepoint", y = "DOX/VEH (%)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position="top")

# ---------------------------
# Step 7: t-tests between timepoints for Step 6 ratio
# ---------------------------
comparisons <- list(c("24T","24R"), c("24R","144R"), c("24T","144R"))

stats_step7 <- step6_ratio %>%
  dplyr::group_by(Magnification) %>%
  dplyr::summarise(
    t_tests = list(sapply(comparisons, function(x){
      t.test(DOX_VEH_Percent[Timepoint==x[1]],
             DOX_VEH_Percent[Timepoint==x[2]])$p.value
    })),
    .groups="drop"
  ) %>%
  tidyr::unnest_wider(t_tests, names_sep="_") %>%
  dplyr::mutate(signif = purrr::map_chr(c(t_tests_1,t_tests_2,t_tests_3), ~dplyr::case_when(
    .x < 0.001 ~ "***",
    .x < 0.01  ~ "**",
    .x < 0.05  ~ "*",
    TRUE       ~ "ns"
  )))

plot_step7 <- ggplot(step6_ratio,
                     aes(x = Timepoint, y = DOX_VEH_Percent)) +
  geom_boxplot(alpha = 0.6, fill="lightgoldenrod", outlier.shape = NA) +
  geom_point(aes(color = Individual), alpha = 0.6, size = 3) +
  facet_wrap(~Magnification, scales="free_x") +
  labs(title = "Step 7: DOX/VEH Ratio with Timepoint t-tests",
       x = "Timepoint", y = "DOX/VEH (%)") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position="top")

# ---------------------------
# Print all plots to check
# ---------------------------
plot_step1
plot_step1.5
plot_step2
plot_step3
plot_step4
plot_step5_10X
plot_step5_20X
plot_step6
plot_step7

```


#Top2i Genes Comparisons
```{r Load in Top2i DEG sets}

#Renee's Top2i drug datasets
DEGs_RM_list <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Renee/siglist_final.RDS") 

#only keep the conditions that I want to compare to
keep_conditions <- c("sigVDA24", "sigVDX24", "sigVEP24", "sigVMT24")

DEGs_RM_24 <- DEGs_RM_list[keep_conditions]

#change the first column to Entrez_ID for all sets
DEGs_RM_24 <- lapply(DEGs_RM_24, function(df) {
  # Rename the first column to Entrez_ID, regardless of current name
  colnames(df)[1] <- "Entrez_ID"
  return(df)
})

#DOX
DOX_RM_DEGs <- DEGs_RM_24$sigVDX24 %>% 
  as.data.frame()

dim(DOX_RM_DEGs)
#6645 genes

#Das.data.frame()#DNR
DNR_RM_DEGs <- DEGs_RM_24$sigVDA24 %>% 
  as.data.frame()

dim(DNR_RM_DEGs)
#7017 genes

#EPI
EPI_RM_DEGs <- DEGs_RM_24$sigVEP24 %>% 
  as.data.frame()

dim(EPI_RM_DEGs)
#6328 genes

#MTX
MTX_RM_DEGs <- DEGs_RM_24$sigVMT24 %>% 
  as.data.frame()

dim(MTX_RM_DEGs)
#1115 genes

#now combine these all into one dataframe for later

DEGs_RM_24_df <- dplyr::bind_rows(
  # DOX_RM_DEGs %>% mutate(Drug = "DOX_RM"),
  DNR_RM_DEGs %>% mutate(Drug = "DAUN_RM"),
  EPI_RM_DEGs %>% mutate(Drug = "EPI_RM"),
  MTX_RM_DEGs %>% mutate(Drug = "MITO_RM"),
)


#Sayan's Top2i drug datasets

#CX 0.5 24hr
CX_SP_24 <- read.csv("C:/Users/emmap/RDirectory/Recovery_RNAseq/Sayan/Toptable_CX_0.5_24.csv") 

dim(CX_SP_24)
#14279 genes, make sure to now filter this for significance

#DOX 0.5 24hr
DOX_SP_24 <- read.csv("C:/Users/emmap/RDirectory/Recovery_RNAseq/Sayan/Toptable_DOX_0.5_24.csv")
dim(DOX_SP_24)
#14279 genes, filter for significance

#filter both above for adj.P.Val < 0.05

DEGs_SP_sig <- list(
  "CX_SP" = CX_SP_24$Entrez_ID[CX_SP_24$adj.P.Val < 0.05],
  "DOX_SP" = DOX_SP_24$Entrez_ID[DOX_SP_24$adj.P.Val < 0.05]
)

#now make dataframes and place them with RM's data to complete my Top2i comparative dataframe

CX_SP_DEGs <- CX_SP_24 %>%
  filter(adj.P.Val < 0.05) %>%
  as.data.frame() 

dim(CX_SP_DEGs)
#278 genes

DOX_SP_DEGs <- DOX_SP_24 %>%
  filter(adj.P.Val < 0.05) %>%
  as.data.frame()

dim(DOX_SP_DEGs)
#9828 genes

#since SP's data has Entrez_ID as an integer rather than a character, coerce these to character in order for bind_rows to work properly

CX_SP_DEGs$Entrez_ID <- as.character(CX_SP_DEGs$Entrez_ID)
DOX_SP_DEGs$Entrez_ID <- as.character(DOX_SP_DEGs$Entrez_ID)

#these two also don't have a SYMBOL column so let's add that in

#CX df
CX_SP_DEGs <- CX_SP_DEGs %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  ) %>%
  dplyr::select(Entrez_ID, SYMBOL, everything())  # move SYMBOL to second column

# Same for df6
DOX_SP_DEGs <- DOX_SP_DEGs %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  ) %>%
  dplyr::select(Entrez_ID, SYMBOL, everything())


DEGs_Top2i_24_df <- dplyr::bind_rows(
  DOX_RM_DEGs %>% mutate(Treatment = "DOX_RM"),
  DNR_RM_DEGs %>% mutate(Treatment = "DAUN_RM"),
  EPI_RM_DEGs %>% mutate(Treatment = "EPI_RM"),
  MTX_RM_DEGs %>% mutate(Treatment = "MITO_RM"),
  CX_SP_DEGs %>% mutate(Treatment = "CX_SP"),
  DOX_SP_DEGs %>% mutate(Treatment = "DOX_SP")
) 
  
#now this table has all columns consistently named and in the same formats

# saveRDS(DEGs_Top2i_24_df, "data/new/DEGlist_Top2i_SP_RM.RDS")

DEGs_Top2i_24_df <- readRDS("data/new/DEGlist_Top2i_SP_RM.RDS")

#also make a list version just in case

DEGs_Top2i_24_list <- list(
  "DOX_RM" = DOX_RM_DEGs, #6645 DEGs
  "DNR_RM" = DNR_RM_DEGs, #7017 DEGs
  "EPI_RM" = EPI_RM_DEGs, #6328 DEGs
  "MTX_RM" = MTX_RM_DEGs, #1115 DEGs
  "CX_SP" = CX_SP_DEGs, #278 DEGs
  "DOX_SP" = DOX_SP_DEGs #9828 DEGs
)

#total 10,106 DEGs from SP
#total 21,105 DEGs from RM

# saveRDS(DEGs_Top2i_24_list, "data/new/DEGs_Top2i_RM_SP_list.RDS")

DEGs_Top2i_24_list <- readRDS("data/new/DEGs_Top2i_RM_SP_list.RDS")

```

##Proportion Barplots with Top2i DEGs

```{r Proportion Barplots with Permutation Testing TOP2i Treatments}
#this is the correct workflow with permutation testing

#1. Read in DEGs
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% dplyr::select(-X)
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% dplyr::select(-X)
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% dplyr::select(-X)

deg_list <- list(
  "24T"   = DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05],
  "24R"   = DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05],
  "144R"  = DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]
)

# D24T DEGs (reference set)
d24t_set <- unique(na.omit(as.character(deg_list$"24T")))
cat("Total D24T DE genes:", length(d24t_set), "\n")

# Background (all genes tested)
all_genes <- rownames(filcpm_matrix)
cat("Total background genes:", length(all_genes), "\n")

#2. Define treatment DEG sets
comparison_DEGs <- list(
  DOX_RM = as.character(DOX_RM_DEGs$Entrez_ID),
  DNR_RM = as.character(DNR_RM_DEGs$Entrez_ID),
  EPI_RM = as.character(EPI_RM_DEGs$Entrez_ID),
  MTX_RM = as.character(MTX_RM_DEGs$Entrez_ID),
  CX_SP  = as.character(CX_SP_DEGs$Entrez_ID),
  DOX_SP = as.character(DOX_SP_DEGs$Entrez_ID)
)

#3. Build data for stacked proportion barplot
plot_df <- purrr::map_dfr(names(comparison_DEGs), function(name) {
  comp_DEGs <- unique(comparison_DEGs[[name]])
  
  overlap <- sum(d24t_set %in% comp_DEGs)
  non_overlap <- length(d24t_set) - overlap
  
  tibble(
    Treatment = name,
    Category = c("Overlap", "Non-overlap"),
    Count = c(overlap, non_overlap),
    Total = length(d24t_set),
    Fraction = c(overlap, non_overlap)/length(d24t_set)
  )
})

plot_df <- plot_df %>%
  mutate(
    Treatment = factor(Treatment, levels = names(comparison_DEGs)),
    Category = factor(Category, levels = c("Overlap", "Non-overlap"))
  )

#Legend labels (with n counts)
legend_labels <- plot_df %>%
  filter(Category == "Overlap") %>%
  mutate(Label = paste0(Category, " (n=", Count, ")")) %>%
  dplyr::select(Treatment, Label) %>%
  deframe()

#4. Permutation test for enrichment
perm_test_overlap <- function(gene_set, d24t_genes, gene_universe, n_perm=10000) {
  observed <- length(intersect(d24t_genes, gene_set))
  
  perm_overlaps <- replicate(n_perm, {
    random_genes <- sample(gene_universe, length(d24t_genes))
    length(intersect(random_genes, gene_set))
  })
  
  p_val <- mean(perm_overlaps >= observed)
  enrichment <- observed / mean(perm_overlaps)
  
  return(list(observed=observed,
              mean_perm=mean(perm_overlaps),
              enrichment=enrichment,
              p_value=p_val))
}

perm_results <- lapply(comparison_DEGs, perm_test_overlap,
                       d24t_genes = d24t_set,
                       gene_universe = all_genes,
                       n_perm = 10000)

#Summary stats table
perm_summary_df <- map_dfr(names(perm_results), function(name) {
  res <- perm_results[[name]]
  tibble(
    Treatment = name,
    Observed = res$observed,
    MeanPerm = res$mean_perm,
    Enrichment = res$enrichment,
    PValue = res$p_value
  )
}) %>%
  mutate(FDR = p.adjust(PValue, method = "BH"),
         Significant = case_when(
           FDR < 0.001 ~ "***",
           FDR < 0.01  ~ "**",
           FDR < 0.05  ~ "*",
           TRUE ~ "ns"
         ))

#Show summary stats table
print(perm_summary_df)

#5. Label positions
#Inside overlap bars: percentages
overlap_labels <- plot_df %>%
  filter(Category == "Overlap") %>%
  left_join(perm_summary_df %>% dplyr::select(Treatment, Significant), by = "Treatment") %>%
  mutate(
    Label = paste0(round(Fraction*100, 1), "%"),
    y_pos = 0.5   # fixed position at 50% for all treatments
  )

#Above bars: significance stars
label_positions <- plot_df %>%
  group_by(Treatment) %>%
  summarise(y_pos = 1.0, .groups = "drop") %>%
  left_join(perm_summary_df %>% dplyr::select(Treatment, Significant), by = "Treatment")

#6. Final barplot
ggplot(plot_df, aes(x = Treatment, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", width = 0.6) +
  
  # percentages inside overlap bars (fixed position)
  geom_text(
    data = overlap_labels,
    aes(x = Treatment, y = y_pos, label = Label),
    inherit.aes = FALSE,
    color = "white",
    fontface = "bold",
    size = 4
  ) +
  
  # significance stars above bars
  geom_text(
    data = label_positions,
    aes(x = Treatment, y = y_pos, label = Significant),
    inherit.aes = FALSE,
    size = 4,
    fontface = "bold",
    color = "black"
  ) +
  
  scale_y_continuous(labels = scales::percent_format(scale = 100), limits = c(0, 1)) +
  scale_fill_manual(values = c("Overlap" = "#e41a1c", "Non-overlap" = "#377eb8"),
                    labels = legend_labels) +
  labs(
    title = "Proportion of TOP2i DEGs in D24T DEGs",
    x = "Treatment",
    y = "Percentage",
    fill = "TOP2i DEGs"
  ) +
  theme_custom()


#now I want to make another version of this where I can split up the plots between SP and RM

rm_treatments <- c("DOX_RM", "DNR_RM", "MTX_RM", "EPI_RM")
sp_treatments <- c("DOX_SP", "CX_SP")


##RM Plot
plot_df_RM <- plot_df %>% dplyr::filter(Treatment %in% rm_treatments) %>% 
  mutate(Treatment = factor(Treatment, levels = rm_treatments))

overlap_labels_RM <- overlap_labels %>% dplyr::filter(Treatment %in% rm_treatments)
label_positions_RM <- label_positions %>% dplyr::filter(Treatment %in% rm_treatments)

p_RM <- ggplot(plot_df_RM, aes(x = Treatment, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", width = 0.8) +
  geom_text(
    data = overlap_labels_RM,
    aes(x = Treatment, y = y_pos, label = Label),
    inherit.aes = FALSE,
    color = "white", fontface = "bold", size = 4
  ) +
  geom_text(
    data = label_positions_RM, 
    aes(x = Treatment, y = y_pos, label = Significant),
    inherit.aes = FALSE,
    size = 4, fontface = "bold", color = "black"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 100), limits = c(0,1)) +
  scale_fill_manual(values = c("Overlap" = "#E41A1C", "Non-overlap" = "#377EB8"),
                    labels = legend_labels) +
  labs(title = "RM Treatments", x = "Treatment", y = "Percentage", fill = "TOP2i DEGs") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


##SP plot

plot_df_SP <- plot_df %>% dplyr::filter(Treatment %in% sp_treatments) %>% 
  mutate(Treatment = factor(Treatment, levels = c("DOX_SP", "CX_SP")))

overlap_labels_SP <- overlap_labels %>% filter(Treatment %in% sp_treatments)
label_positions_SP <- label_positions %>% filter(Treatment %in% sp_treatments)

p_SP <- ggplot(plot_df_SP, aes(x = Treatment, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", ) +
  geom_text(
    data = overlap_labels_SP,
    aes(x = Treatment, y = y_pos, label = Label),
    inherit.aes = FALSE,
    color = "white", fontface = "bold", size = 4
  ) +
  geom_text(
    data = label_positions_SP,
    aes(x = Treatment, y = y_pos, label = Significant),
    inherit.aes = FALSE,
    size = 4, fontface = "bold", color = "black"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 100), limits = c(0, 1)) +
  scale_fill_manual(values = c("Overlap" = "#e41a1c", "Non-overlap" = "#377eb8"),
                    labels = legend_labels) +
  labs(title = "SP Treatments", x = "Treatment", y = "Percentage", fill = "TOP2i DEGs") +
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#show plots
p_RM
p_SP

```

```{r Proportion Barplot TOP2i vs t0 DEGs combined}
#make the same plot as above but combined and in a specific order
#this is with permutation testing

#read in DEGs
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% dplyr::select(-X)
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% dplyr::select(-X)
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% dplyr::select(-X)

deg_list <- list(
  "24T" = DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05],
  "24R" = DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05],
  "144R" = DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]
)

# D24T DEGs (reference set)
d24t_set <- unique(na.omit(as.character(deg_list$"24T")))
cat("Total D24T DE genes:", length(d24t_set), "\n")

# Background (all genes tested)
all_genes <- rownames(filcpm_matrix)
cat("Total background genes:", length(all_genes), "\n")

#define treatment DEG sets + remove DOX
comparison_DEGs <- list(
  CX_SP  = as.character(CX_SP_DEGs$Entrez_ID),
  DNR_RM = as.character(DNR_RM_DEGs$Entrez_ID),
  EPI_RM = as.character(EPI_RM_DEGs$Entrez_ID),
  MTX_RM = as.character(MTX_RM_DEGs$Entrez_ID)
)

#build data for stacked proportion barplot
plot_df <- purrr::map_dfr(names(comparison_DEGs), function(name) {
  comp_DEGs <- unique(comparison_DEGs[[name]])
  
  overlap <- sum(d24t_set %in% comp_DEGs)
  non_overlap <- length(d24t_set) - overlap
  
  tibble(
    Treatment = name,
    Category = c("Overlap", "Non-overlap"),
    Count = c(overlap, non_overlap),
    Total = length(d24t_set),
    Fraction = c(overlap, non_overlap)/length(d24t_set)
  )
})

plot_df <- plot_df %>%
  mutate(
    Treatment = factor(Treatment, 
                       levels = c("CX_SP",
                                  "DNR_RM",
                                  "EPI_RM", 
                                  "MTX_RM")),
    Category = factor(Category, 
                      levels = c("Overlap",
                                 "Non-overlap"))
  )

#Legend labels (with n counts)
legend_labels <- plot_df %>%
  filter(Category == "Overlap") %>%
  mutate(Label = paste0(Category, " (n=", Count, ")")) %>%
  dplyr::select(Treatment, Label) %>%
  deframe()

#4. Permutation test for enrichment
perm_test_overlap <- function(gene_set, d24t_genes, gene_universe, n_perm=10000) {
  observed <- length(intersect(d24t_genes, gene_set))
  
  perm_overlaps <- replicate(n_perm, {
    random_genes <- sample(gene_universe, length(d24t_genes))
    length(intersect(random_genes, gene_set))
  })
  
  p_val <- mean(perm_overlaps >= observed)
  enrichment <- observed / mean(perm_overlaps)
  
  return(list(observed=observed,
              mean_perm=mean(perm_overlaps),
              enrichment=enrichment,
              p_value=p_val))
}

perm_results <- lapply(comparison_DEGs, perm_test_overlap,
                       d24t_genes = d24t_set,
                       gene_universe = all_genes,
                       n_perm = 10000)

#Summary stats table
perm_summary_df <- map_dfr(names(perm_results), function(name) {
  res <- perm_results[[name]]
  tibble(
    Treatment = name,
    Observed = res$observed,
    MeanPerm = res$mean_perm,
    Enrichment = res$enrichment,
    PValue = res$p_value
  )
}) %>%
  mutate(FDR = p.adjust(PValue, method = "BH"),
         Significant = case_when(
           FDR < 0.001 ~ "***",
           FDR < 0.01  ~ "**",
           FDR < 0.05  ~ "*",
           TRUE ~ "ns"
         ))

#Show summary stats table
print(perm_summary_df)

#5. Label positions
#Inside overlap bars: percentages
overlap_labels <- plot_df %>%
  filter(Category == "Overlap") %>%
  left_join(perm_summary_df %>% dplyr::select(Treatment, Significant), by = "Treatment") %>%
  mutate(
    Label = paste0(round(Fraction*100, 1), "%"),
    y_pos = 0.5   # fixed position at 50% for all treatments
  )

#Above bars: significance stars
label_positions <- plot_df %>%
  group_by(Treatment) %>%
  summarise(y_pos = 1.0, .groups = "drop") %>%
  left_join(perm_summary_df %>% dplyr::select(Treatment, Significant), by = "Treatment")

#6. Final barplot
TOP2i_Combined <- ggplot(plot_df, aes(x = Treatment, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", width = 0.6) +
  
  # percentages inside overlap bars (fixed position)
  geom_text(
    data = overlap_labels,
    aes(x = Treatment, y = y_pos, label = Label),
    inherit.aes = FALSE,
    color = "white",
    fontface = "bold",
    size = 4
  ) +
  
  # significance stars above bars
  geom_text(
    data = label_positions,
    aes(x = Treatment, y = y_pos, label = Significant),
    inherit.aes = FALSE,
    size = 4,
    fontface = "bold",
    color = "black"
  ) +
  
  scale_y_continuous(labels = scales::percent_format(scale = 100), limits = c(0, 1)) +
  scale_fill_manual(values = c("Overlap" = "#e41a1c", "Non-overlap" = "#377eb8"),
                    labels = legend_labels) +
  labs(
    title = "Proportion of TOP2i DEGs in D24T DEGs",
    x = "Treatment",
    y = "Percentage",
    fill = "TOP2i DEGs"
  ) +
  theme_custom()

save_plot(
  plot = TOP2i_Combined,
  folder = output_folder,
  filename = "TOP2i_Barplot_Combined_Fig4_EMP",
  height = 6,
  width = 8
)

```


#Proportion Barplots of TOP2i against Sustained Motif 2
```{r Proportion Barplots TOP2i Drugs vs Sustained Motif}

# =======================
# Inputs
# =======================
final_genes_1_RUV <- readRDS("data/new/RUV/CMF/final_genes_1_RUV.RDS")
final_genes_2_RUV <- readRDS("data/new/RUV/CMF/final_genes_2_RUV.RDS")

motif1_set <- unique(na.omit(final_genes_1_RUV))
motif2_set <- unique(na.omit(final_genes_2_RUV))

all_tested_genes <- unique(c(motif1_set, motif2_set))

comparison_DEGs <- list(
  DOX_RM = as.character(DOX_RM_DEGs$Entrez_ID),
  DNR_RM = as.character(DNR_RM_DEGs$Entrez_ID),
  EPI_RM = as.character(EPI_RM_DEGs$Entrez_ID),
  MTX_RM = as.character(MTX_RM_DEGs$Entrez_ID),
  CX_SP  = as.character(CX_SP_DEGs$Entrez_ID),
  DOX_SP = as.character(DOX_SP_DEGs$Entrez_ID)
)

# =======================
# Permutation test function
# =======================
perm_test_overlap <- function(ref_genes, test_genes, background, n_perm = 10000) {
  observed <- length(intersect(ref_genes, test_genes))
  
  perm_overlaps <- replicate(n_perm, {
    random_genes <- sample(background, length(ref_genes))
    length(intersect(random_genes, test_genes))
  })
  
  p_val <- mean(perm_overlaps >= observed)
  enrichment <- observed / mean(perm_overlaps)
  
  tibble(
    Observed = observed,
    Expected = mean(perm_overlaps),
    Enrichment = enrichment,
    P_Value = p_val
  )
}

# =======================
# Function to create barplot dataframe for one motif
# =======================
prepare_plot_df <- function(motif_set, motif_name) {
  map_dfr(names(comparison_DEGs), function(treat) {
    res <- perm_test_overlap(motif_set, comparison_DEGs[[treat]], all_tested_genes)
    tibble(
      Treatment = treat,
      Category = c("DEG", "Non-DEG"),
      Count = c(res$Observed, length(motif_set) - res$Observed),
      Fraction = c(res$Observed / length(motif_set), 1 - res$Observed / length(motif_set)),
      P_Value = res$P_Value,
      Significant = case_when(
        res$P_Value < 0.001 ~ "***",
        res$P_Value < 0.01  ~ "**",
        res$P_Value < 0.05  ~ "*",
        TRUE ~ ""
      ),
      Motif = motif_name
    )
  })
}

# =======================
# Prepare data for Motif 1 and Motif 2
# =======================
plot_df_motif1 <- prepare_plot_df(motif1_set, "Motif1")
plot_df_motif2 <- prepare_plot_df(motif2_set, "Motif2")

# =======================
# Plotting function
# =======================
plot_motif <- function(plot_df, motif_name) {
  label_positions <- plot_df %>%
    filter(Category == "DEG") %>%
    mutate(y_pos = 1.0)  # fixed position for stars

  ggplot(plot_df, aes(x = Treatment, y = Fraction, fill = Category)) +
    geom_bar(stat = "identity") +
    geom_text(aes(y = Fraction + 0.05, label = Significant),
              data = label_positions, size = 6, fontface = "bold", color = "black") +
    scale_y_continuous(labels = scales::percent_format(scale = 100), limits = c(0,1)) +
    scale_fill_manual(values = c("DEG" = "blue", "Non-DEG" = "red")) +
    labs(
      title = paste0("Overlap of TOP2i DEGs on ", motif_name, " Genes"),
      x = "Treatment",
      y = "Percent Overlap",
      fill = ""
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold")
    )
}

# =======================
# Plot Motif 1 and Motif 2 separately
# =======================
plot_motif(plot_df_motif1, "Motif 1")
plot_motif(plot_df_motif2, "Motif 2")

# =======================
# Summary stats tables
# =======================
stats_table_motif1 <- plot_df_motif1 %>%
  filter(Category == "DEG") %>%
  mutate(Percent = Fraction * 100) %>%
  dplyr::select(Treatment, Count, Percent, Enrichment, P_Value, Significant)

stats_table_motif2 <- plot_df_motif2 %>%
  filter(Category == "DEG") %>%
  mutate(Percent = Fraction * 100) %>%
  dplyr::select(Treatment, Count, Percent, Enrichment, P_Value, Significant)

print(stats_table_motif1)
print(stats_table_motif2)

```

```{r TOP2i in Sustained vs Recovered Motifs}

# Inputs
final_genes_1_RUV <- readRDS("data/new/RUV/CMF/final_genes_1_RUV.RDS")
final_genes_2_RUV <- readRDS("data/new/RUV/CMF/final_genes_2_RUV.RDS")

motif1_set <- unique(na.omit(final_genes_1_RUV))
motif2_set <- unique(na.omit(final_genes_2_RUV))

all_tested_genes <- unique(c(final_genes_1_RUV, final_genes_2_RUV))

comparison_DEGs <- list(
  DOX_RM = as.character(DOX_RM_DEGs$Entrez_ID),
  DNR_RM = as.character(DNR_RM_DEGs$Entrez_ID),
  EPI_RM = as.character(EPI_RM_DEGs$Entrez_ID),
  MTX_RM = as.character(MTX_RM_DEGs$Entrez_ID),
  CX_SP  = as.character(CX_SP_DEGs$Entrez_ID),
  DOX_SP = as.character(DOX_SP_DEGs$Entrez_ID)
)

# Fisher's exact test per treatment
fisher_test_overlap <- function(motif1, motif2, degs) {
  a <- sum(motif1 %in% degs)
  b <- length(motif1) - a
  c <- sum(motif2 %in% degs)
  d <- length(motif2) - c
  
  contingency <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE)
  fisher_res <- fisher.test(contingency)
  
  list(
    contingency = contingency,
    p_value = fisher_res$p.value,
    significant = case_when(
      fisher_res$p.value < 0.001 ~ "***",
      fisher_res$p.value < 0.01  ~ "**",
      fisher_res$p.value < 0.05  ~ "*",
      TRUE ~ ""
    )
  )
}

# Prepare summary table for plotting
plot_summary <- map_dfr(names(comparison_DEGs), function(treat) {
  degs <- comparison_DEGs[[treat]]
  
  # Fisher test
  fisher_res <- fisher_test_overlap(motif1_set, motif2_set, degs)
  
  # Counts for each motif
  motif1_overlap <- sum(motif1_set %in% degs)
  motif1_nonoverlap <- length(motif1_set) - motif1_overlap
  motif2_overlap <- sum(motif2_set %in% degs)
  motif2_nonoverlap <- length(motif2_set) - motif2_overlap
  
  tibble(
    Treatment = treat,
    Motif = rep(c("Motif1", "Motif2"), each = 2),
    Category = rep(c("DEG", "Non-DEG"), 2),
    Count = c(motif1_overlap, motif1_nonoverlap, motif2_overlap, motif2_nonoverlap),
    Fraction = c(motif1_overlap, motif1_nonoverlap, motif2_overlap, motif2_nonoverlap) /
               c(length(motif1_set), length(motif1_set), length(motif2_set), length(motif2_set)),
    Significant = rep(c(fisher_res$significant, ""), 2)  # only on DEG bars
  )
})

# Ensure correct order
plot_summary$Category <- factor(plot_summary$Category, levels = c("DEG", "Non-DEG"))

# Position stars at y = 1
label_positions <- plot_summary %>%
  filter(Category == "DEG") %>%
  mutate(y_pos = 1)

# Plot
top2i_barplot_motifs_supp7 <- ggplot(plot_summary, aes(x = Treatment, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(data = label_positions %>% filter(Significant != ""),
            aes(x = Treatment, y = y_pos, label = Significant),
            inherit.aes = FALSE, size = 6, fontface = "bold", color = "black") +
  geom_text(aes(label = paste0(round(Fraction*100,1), "")),
            position = position_stack(vjust = 0.5), size = 5, color = "white") +
  scale_y_continuous(limits = c(0, 1)) +
  scale_fill_manual(values = c("DEG" = "blue", "Non-DEG" = "red")) +
  facet_wrap(~Motif) +
  labs(
    title = "Overlap of TOP2i DEGs on Recovered vs Sustained",
    x = "Treatment",
    y = "Overlap (%)",
    fill = ""
  ) +
  theme_custom()

save_plot(
  plot = top2i_barplot_motifs_supp7,
  filename = "Supp7_TOP2i_Barplots_EMP",
  folder = output_folder,
  height = 5,
  width = 8.5
)

# =======================
# Print percentages and p-values
# =======================
for(treat in names(comparison_DEGs)) {
  degs <- comparison_DEGs[[treat]]
  motif1_overlap <- sum(motif1_set %in% degs)
  motif2_overlap <- sum(motif2_set %in% degs)
  prop1 <- motif1_overlap / length(motif1_set)
  prop2 <- motif2_overlap / length(motif2_set)
  fisher_res <- fisher_test_overlap(motif1_set, motif2_set, degs)
  
  cat(sprintf("%s - Motif1: %.2f%% (%d/%d), Motif2: %.2f%% (%d/%d), Fisher p = %.5f\n",
              treat, 100*prop1, motif1_overlap, length(motif1_set),
              100*prop2, motif2_overlap, length(motif2_set),
              fisher_res$p_value))
}

```

#Forest Plot TOP2i Sustained vs Recovered
```{r Forest Plots of TOP2i M1 vs M2}
#use the workflow above to now plot forest plots of odds ratios for these comparisons
#I am comparing sets of DEGs from other TOP2i against my motifs here
#I want to use my fisher's exact test data

#same inputs as before to preserve them
final_genes_1_RUV <- readRDS("data/new/RUV/CMF/final_genes_1_RUV.RDS")
final_genes_2_RUV <- readRDS("data/new/RUV/CMF/final_genes_2_RUV.RDS")

motif1_set <- unique(na.omit(final_genes_1_RUV))
motif2_set <- unique(na.omit(final_genes_2_RUV))

all_tested_genes <- unique(c(final_genes_1_RUV, final_genes_2_RUV))

#remove DOX and preserve order DNR EPI MTX CX
comparison_DEGs_noDOX <- list(
  DNR_RM = as.character(DNR_RM_DEGs$Entrez_ID),
  EPI_RM = as.character(EPI_RM_DEGs$Entrez_ID),
  MTX_RM = as.character(MTX_RM_DEGs$Entrez_ID),
  CX_SP  = as.character(CX_SP_DEGs$Entrez_ID)
)

treatment_order <- c("DNR_RM", "EPI_RM", "MTX_RM", "CX_SP")

fisher_test_overlap <- function(motif1, motif2, degs) {
  a <- sum(motif1 %in% degs)
  b <- length(motif1) - a
  c <- sum(motif2 %in% degs)
  d <- length(motif2) - c
  
  contingency <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE)
  fisher_res <- fisher.test(contingency)
  
  tibble(
    OR = unname(fisher_res$estimate),
    CI_low = fisher_res$conf.int[1],
    CI_high = fisher_res$conf.int[2],
    p_value = fisher_res$p.value,
    Significant = case_when(
      fisher_res$p.value < 0.001 ~ "***",
      fisher_res$p.value < 0.01 ~ "**",
      fisher_res$p.value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )
}


#build a summary table for the results of fishers exact for the forest plots
forest_summary <- map_dfr(names(comparison_DEGs_noDOX), function(treat) {
  res <- fisher_test_overlap(motif2_set, motif1_set, comparison_DEGs_noDOX[[treat]])
  res %>% mutate(Treatment = treat)
}) %>% 
  mutate(Treatment = factor(Treatment, levels = rev(treatment_order)), #define order
         Group = ifelse(grepl("_RM$", Treatment), "RM", "SP"))

#create my combined plot
forest_TOP2i <- ggplot(forest_summary, 
                       aes(y = Treatment, x = OR, 
                           xmin = CI_low, xmax = CI_high, 
                           color = Group)) + 
  geom_point(size = 4) +
  geom_errorbarh(height = 0.2, linewidth = 0.5, color = "black") +
  geom_text(aes(label = Significant), position = position_nudge(y = 0.1), 
            color = "black", fontface = "bold", size = 5) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  scale_x_log10(limits = c(0.1, 1000),
                breaks = c(0.1, 1, 10, 100, 1000)) +
  # xlim(c(0,250)) +
  scale_color_manual(values = c("_" = "grey", "_" = "grey")) + #remove the groups this way even though it's not the best method
  labs(
    title = "Sustained vs Recovered TOP2i Odds Ratios",
    x = "Odds Ratio (log scale)",
    y = "TOP2i Treatment"
    # color = "Group"
  ) +
  theme_bw(base_size = 14)

forest_TOP2i

#make a summary table

forest_summary_TOP2i <- forest_summary

# View(forest_summary_TOP2i)

```



#Proportion Barplots Genes from Other Studies
```{r Import Genes}
#Import the genes that you'll be using for these barplots
#one of them is the DOX cardiotox set (I've been calling DIC)

#define gene sets by SYMBOL - convert to Entrez_ID shortly

# liu_set <- c("UGT1A9","PPP2R2B","SPINK6","HPGDS","SCMH1","CA12","ERBB2","HADHA","DUSP14","DGKH", "DHODH","MYLK3","TRAPPC4","ESRRG","CALY","MAPKBP1","DPEP1","ME3","PRSS1","SLC7A11","FNTA")

# sapp_set <- c("EDC4","GALNT18","C1QTNF2","EIF1AD","PALMD","XRN2","TMEM189","MANEAL","C11orf49","ARL6IP4", "GUCY2C","GLIPR1L2","F10","MRS2","MYC","SLCO1A2","TFPT","MATR3","ENTHD2","CAB39L","EXOSC10","KDM3B","C11orf57","KIAA1033","CYP3A7","C5orf51","RRAS","BUD13","ZNHIT3","PRRG3","GGT6","FUNDC2","SLCO1B3","GLRX3","POU6F1","TEX36","PLEKHO1","TGFA","DUSP15","COX5B","IFT81","ZNF474","MSANTD4","DGCR8","OSBPL9","MPDU1","KCNJ14","INF2","TSSC1","STT3A","GRAMD4","GTDC1","CORO1B","CCDC61","ING1","SLC25A6","GH2","STEAP4","POM121","POLQ","DNAJC10","ARTN","CRYGB","NUCB2","SLC25A51","DGCR2","CCDC85C","TOMM40","TNNC2","SHD","CMPK2","ARHGAP32","CDC14A","OR8G5","ZNF559","ENPP3","HOXA10","TAGLN2","CABYR","BST2","NAT1","PDE1B","COL19A1","COL4A2","ATPAF2","HIRIP3","RNF13","CD163","SERPINC1","SMPDL3B","OR52N4","BCAN","H1F0","EPS8","TECPR1","NAA25","KIAA1161","PTPN13","C6orf165","IL18BP","LTB4R","SLC2A2","CYCS","KLHL30","LYPD3","ABCD1","PUS3","GKN2","FAM169B","MBD3L2","OR10P1","SDR9C7","ACTBL2","ZNF630","ATP13A3","VPS29","ARSG","TTC39C","HUNK","C14orf93","SLC1A3","NPY1R","ZNF883","DLGAP3","MKLN1","UNK","HES1","PAGE2B","DCAF17","NDFIP1","HAUS5","DSCR3","CBLL1","PITPNM1","SLC16A9","SNAP47","SLC10A6","C15orf56","CLPSL2","RASAL3","C19orf25","ITGAE","KRT38","ADAM19","TMEM53","PYURF","SREBF2","RPL17","ATXN7L1","IL15RA","LYRM5","MPV17","KRTAP3-1","TMEM170B","SLC35G2","PPP1R16A","SH3TC2","LGALS8","DDX28","HERPUD2","CAMTA2","DERL1","OR5D16","DDX17","COPZ2","KRT10", "KIAA1024","NINL","SMARCAD1")
# 
# length(sapp_set)
# 
# dic_set

# # --- Step 2: Convert SYMBOL to Entrez IDs ---
# convert_to_entrez <- function(symbols) {
#   mapped <- AnnotationDbi::select(org.Hs.eg.db,
#                                   keys = symbols,
#                                   keytype = "SYMBOL",
#                                   columns = "ENTREZID")
#   unique(na.omit(mapped$ENTREZID))
# }
# 
# liu_ids  <- convert_to_entrez(liu_set)
# sapp_ids <- convert_to_entrez(sapp_set)
# # dic_ids  <- convert_to_entrez(dic_set)

# saveRDS(liu_ids, "data/new/RUV/liu_dataset_entrez.RDS")
# saveRDS(sapp_ids, "data/new/RUV/sapp_dataset_entrez.RDS")
# saveRDS(dic_set, "data/new/RUV/fonoudi_dataset_entrez.RDS")

#read in the new processed gene sets after conversion to entrez ids
liu_ids <- readRDS("data/new/RUV/liu_dataset_entrez.RDS")
sapp_ids <- readRDS("data/new/RUV/sapp_dataset_entrez.RDS")
fonoudi_ids <- readRDS("data/new/RUV/fonoudi_dataset_entrez.RDS")
#fonoudi is also known as DIC but change that name to represent your other AIC gene set instead; AIC = DIC now

# --- Step 3: Define DE gene sets (replace with your Entrez IDs) ---
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% dplyr::select(-X)
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% dplyr::select(-X)
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% dplyr::select(-X)

DE_24T <- DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05]
DE_24R <-  DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05]
DE_144R <- DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]

# Background (all genes tested)
all_genes <- rownames(filcpm_matrix)
cat("Total background genes:", length(all_genes), "\n")


# --- Step 4: Function to classify ---
categorize_gene <- function(g) {
  in24T <- g %in% DE_24T
  in24R <- g %in% DE_24R
  in144R <- g %in% DE_144R
  
  if (in24T && !in24R && !in144R) {
    return("DE in 24T only")
  } else if (in24T && in24R && !in144R) {
    return("DE in 24T and 24R")
  } else if (in24T && in24R && in144R) {
    return("DE in all timepoints")
  } else {
    return("Not DE")
  }
}

# --- Step 5: Build data frame ---
studies <- list(
  Liu   = liu_ids,
  Sapp  = sapp_ids,
  Fonoudi   = fonoudi_ids,
  AllGenes = all_genes
)

df <- lapply(names(studies), function(study) {
  ids <- studies[[study]]
  cats <- sapply(ids, categorize_gene)
  data.frame(Study = study, Category = cats)
}) %>% bind_rows()

# --- Step 6: Summarize counts and proportions ---
summary_table <- df %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop_last") %>%
  mutate(Proportion = Count / sum(Count))

# --- Step 6b: Print summary table in console ---
summary_table %>%
  arrange(Study, Category) %>%
  mutate(Percent = round(Proportion*100, 1)) %>%
  print(n = Inf)  # show all rows

# --- Step 6b: Factor Study with AllGenes last ---
study_levels <- c("AllGenes", "Fonoudi", "Liu", "Sapp")
summary_table <- summary_table %>%
  mutate(
    Study = factor(Study, levels = study_levels)
  )

# --- Step 6c: Rename categories for plot labels ---
category_labels <- c(
  "DE in 24T only"       = "DE in t0 only",
  "DE in 24T and 24R"    = "DE in t0 + t24",
  "DE in all timepoints" = "DE in t0 + t24 + t144",
  "Not DE"               = "Not DE"
)

# --- Step 7: Plot with reordered bars and relabeled categories ---
genestud_bar_stack <- ggplot(summary_table, aes(x = Study, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1)),
            position = position_stack(vjust = 0.5),
            size = 3.5, color = "white") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(
    values = c(
      "DE in 24T only"       = "#1f77b4",
      "DE in 24T and 24R"    = "#ff7f0e",
      "DE in all timepoints" = "#2ca02c",
      "Not DE"               = "#d62728"
    ),
    labels = category_labels
  ) +
  scale_x_discrete(labels = c("All", "Fonoudi", "Liu", "Sapp")) +
  theme_custom() +
  labs(
    y = "Proportion of Genes",
    x = "",
    fill = "Category"
  )

save_plot(
  plot = genestud_bar_stack,
  filename = "StackedBarplot_OtherStudies_EMP",
  folder = output_folder,
  height = 6, width = 6
)
```


```{r Proportion Barplots Other Studies CMF}
#now define these same plots by motif membership

final_genes_1_RUV

final_genes_2_RUV

# All genes
all_genes <- unique(c(final_genes_1_RUV, final_genes_2_RUV))

# --- Step 2: Function to categorize by motif membership ---
categorize_motif <- function(g) {
  if (g %in% final_genes_1_RUV) {
    return("Recovered")
  } else if (g %in% final_genes_2_RUV) {
    return("Sustained")
  } else {
    return(NA)
  }
}

#Step 3: Build dataset of all studies
studies <- list(
  Liu   = liu_ids,
  Sapp  = sapp_ids,
  Fonoudi   = dic_set,
  AllGenes = all_genes
)

df_motif <- lapply(names(studies), function(study) {
  ids <- studies[[study]]
  cats <- sapply(ids, categorize_motif)
  data.frame(Study = study, Category = cats)
}) %>% bind_rows()

#remove unassigned/na genes
df_motif <- df_motif %>% dplyr::filter(!is.na(Category))

# --- Step 4: Summarize counts and proportions ---
summary_motif <- df_motif %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop_last") %>%
  mutate(Proportion = Count / sum(Count))

# --- Step 4b: Print summary table in console ---
summary_motif %>%
  arrange(Study, Category) %>%
  mutate(Percent = round(Proportion*100, 1)) %>%
  print(n = Inf)

# --- Step 5: Factor Study and Category for proper order ---
study_levels <- c("AllGenes", "Fonoudi", "Liu", "Sapp")
category_levels <- c("Sustained", "Recovered")

summary_motif <- summary_motif %>%
  mutate(
    Study = factor(Study, levels = study_levels),
    Category = factor(Category, levels = category_levels)
  )

# --- Step 6: Plot ---
ggplot(summary_motif, 
       aes(x = Study, 
           y = Proportion, 
           fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1)),
            position = position_stack(vjust = 0.5),
            size = 3.5, color = "white") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(values = c(
    "Recovered"  = "#1f77b4",
    "Sustained"  = "#ff7f0e"
    )) +
  scale_x_discrete(labels = c("Motif Genes", "Fonoudi et al.", "Liu et al.", "Sapp et al.")) +
  theme_minimal(base_size = 14) +
  labs(
    y = "Proportion of Genes",
    x = "",
    fill = "Motif Category"
  )


```

##eQTLs Bar plots
```{r eQTL DOX data eLife Knowles 2018}
#now similarly to the above plots, I want to test these eQTLs against my motifs

#first get the proportion of genes from each motif in these gene sets

#then perform fisher's exact testing and make forest plots later

#read in these datasets from the Knowles 2018 eLife paper

# elife_33480_supp4_v2 <- read_delim("D:/DXR Project/eQTLs/elife-33480-supp4-v2.gz", 
#     delim = "\t", escape_double = FALSE, 
#     trim_ws = TRUE)
# View(elife_33480_supp4_v2)
# 
# saveRDS(elife_33480_supp4_v2, "data/new/eQTLs/knowles_eqtls_supp4.RDS")

# knowles_eqtls_supp4 <- readRDS("data/new/eQTLs/knowles_eqtls_supp4.RDS")

#now read in the second supplementary dataset
# library(readr)
# elife_33480_supp5_v2 <- read_delim("D:/DXR Project/eQTLs/elife-33480-supp5-v2.gz", 
#     delim = "\t", escape_double = FALSE, 
#     trim_ws = TRUE)
# View(elife_33480_supp5_v2)

# saveRDS(elife_33480_supp5_v2, "data/new/eQTLs/knowles_eqtls_supp5.RDS")

# knowles_eqtls_supp5 <- readRDS("data/new/eQTLs/knowles_eqtls_supp5.RDS")

#now that I've read in both of these sets, convert ensembl id to entrez id so I can compare with my data directly

#ensembl to entrezid

# convert_ids <- function(df, id_col = "gene") {
#   ids <- df[[id_col]]
#   
#   mapped <- AnnotationDbi::select(
#     org.Hs.eg.db,
#     keys = ids,
#     keytype = "ENSEMBL",
#     columns = c("ENTREZID", "SYMBOL")
#   )
#   
#   # Rename to make join explicit
#   colnames(mapped)[colnames(mapped) == "ENSEMBL"] <- id_col
#   colnames(mapped)[colnames(mapped) == "ENTREZID"] <- "Entrez_ID"
#   
#   df_out <- df %>%
#     left_join(mapped, by = id_col)
#   
#   return(df_out)
# }
# 
# knowles_eqtls_supp4_annot <- convert_ids(knowles_eqtls_supp4, "gene")
# knowles_eqtls_supp5_annot <- convert_ids(knowles_eqtls_supp5, "gene")

#now that I've converted these to have entrez_id, go ahead and make the barplots

# saveRDS(knowles_eqtls_supp4_annot, "data/new/eQTLs/knowles_eqtls_supp4_entrez.RDS.RDS")
# saveRDS(knowles_eqtls_supp5_annot, "data/new/eQTLs/knowles_eqtls_supp5_entrez.RDS.RDS")

#now read in the finalized sets with entrezid


#first check that there are any genes that appear in final_genes_1_RUV or final_genes_2_RUV
recovered_overlap <- intersect(all_genes_knowles, final_genes_1_RUV)
sustained_overlap <- intersect(all_genes_knowles, final_genes_2_RUV)

length(recovered_overlap)
length(sustained_overlap)

#there is some overlap with both of these motifs so go ahead with assigning genes

# --- Step 1: Entrez IDs ---
knowles4_ids <- unique(knowles_eqtls_supp4_annot$Entrez_ID[!is.na(knowles_eqtls_supp4_annot$Entrez_ID)])
knowles5_ids <- unique(knowles_eqtls_supp5_annot$Entrez_ID[!is.na(knowles_eqtls_supp5_annot$Entrez_ID)])
all_genes_knowles <- unique(c(knowles4_ids, knowles5_ids))
all_tested_genes <- unique(c(final_genes_1_RUV, final_genes_2_RUV))

# Motif sets in Entrez_ID
recovered_entrez <- final_genes_1_RUV
sustained_entrez <- final_genes_2_RUV

# --- Step 2: Define studies ---
studies_knowles <- list(
  MotifGenes = all_tested_genes,
  "Marginal eQTLs" = knowles4_ids,
  "Response eQTLs" = knowles5_ids
)

# --- Step 3: Categorize ---
categorize_motif <- function(g) {
  if (g %in% recovered_entrez) return("Recovered")
  else if (g %in% sustained_entrez) return("Sustained")
  else return(NA)
}

# --- Step 4: Build summary ---
df_motif_knowles <- lapply(names(studies_knowles), function(study) {
  ids <- studies_knowles[[study]]
  cats <- sapply(ids, categorize_motif)
  
  # Count per category
  df <- data.frame(Category = cats, stringsAsFactors = FALSE) %>%
    filter(!is.na(Category)) %>%
    group_by(Category) %>%
    summarise(Count = n(), .groups = "drop") %>%
    complete(Category = c("Recovered", "Sustained"), fill = list(Count = 0)) %>%
    mutate(Study = study,
           TotalGenes = length(ids))  # total genes in study for scaling
  return(df)
}) %>% bind_rows()

# --- Step 5: Compute proportions scaled to 100% per study ---
summary_motif_knowles <- df_motif_knowles %>%
  mutate(Proportion = Count / TotalGenes)  # divide by total genes, not just motif genes

# --- Step 6: Factor levels ---
study_levels <- c("Motif Genes", "Marginal eQTLs", "Response eQTLs")
category_levels <- c("Sustained", "Recovered")

summary_motif_knowles <- summary_motif_knowles %>%
  mutate(
    Study = factor(Study, levels = study_levels),
    Category = factor(Category, levels = category_levels)
  )

# --- Step 7: Plot with n on top ---
ggplot(df_motif_knowles, aes(x = Study, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity") +
  # Proportion labels inside the bars
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1)),
            position = position_stack(vjust = 0.5),
            size = 3.5, color = "white") +
  # n = total motif genes inside the bars (at top of each bar)
  geom_text(data = df_motif_knowles %>% group_by(Study) %>% summarise(all_tested_genes = unique(all_tested_genes)),
            aes(x = Study, y = 1, label = paste0("n = ", all_tested_genes)),
            inherit.aes = FALSE, vjust = -0.2, size = 3.5, color = "black") +
  # Significance connecting line above Marginal vs Response
  geom_segment(aes(x = 2, xend = 3, y = 1.05, yend = 1.05), inherit.aes = FALSE, size = 0.7) +
  geom_text(data = data.frame(Study = 2.5, y = 1.08, sig = sig_label),
            aes(x = Study, y = y, label = sig),
            inherit.aes = FALSE, size = 6) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
  scale_fill_manual(values = c(
    "Recovered" = "#1f77b4",
    "Sustained" = "#ff7f0e"
  )) +
  scale_x_discrete(labels = c("All Knowles Genes", "Marginal eQTLs", "Response eQTLs")) +
  theme_minimal(base_size = 14) +
  labs(
    y = "Proportion of Motif Genes (%)",
    x = "",
    fill = "Motif Category",
    title = "Knowles et al.: Proportion of eQTL-associated Motif Genes"
  )


#fisher's exact test instead of chi square since I have small sample size
# 2x2 contingency table
cont_table_pair

# Fisher's Exact Test
fisher_res <- fisher.test(cont_table_pair)
pval_fisher <- fisher_res$p.value

# Determine significance
sig_label <- if (pval_fisher < 0.001) "***" else if (pval_fisher < 0.01) "**" else if (pval_fisher < 0.05) "*" else "ns"

sig_label


#make a stats table
# --- Step 1: Create a function to categorize by motif ---
categorize_motif <- function(g) {
  if (g %in% final_genes_1_RUV) "Recovered"
  else if (g %in% final_genes_2_RUV) "Sustained"
  else NA
}

# --- Step 2: Build data frames for each eQTL set ---
df_marginal <- data.frame(
  Gene = knowles4_ids,
  Category = sapply(knowles4_ids, categorize_motif)
) %>% filter(!is.na(Category)) %>%
  group_by(Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Study = "Marginal eQTLs")

df_response <- data.frame(
  Gene = knowles5_ids,
  Category = sapply(knowles5_ids, categorize_motif)
) %>% filter(!is.na(Category)) %>%
  group_by(Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Study = "Response eQTLs")

# Combine all
summary_table <- bind_rows(df_marginal, df_response)

# --- Step 3: Add proportions ---
summary_table <- summary_table %>%
  group_by(Study) %>%
  mutate(Proportion = Count / sum(Count)) %>%
  ungroup()

# --- Step 4: Build 2x2 table and Fisher's Exact Test ---
cont_table <- matrix(c(
  df_marginal$Count[df_marginal$Category == "Recovered"],
  df_marginal$Count[df_marginal$Category == "Sustained"],
  df_response$Count[df_response$Category == "Recovered"],
  df_response$Count[df_response$Category == "Sustained"]
), nrow = 2, byrow = TRUE)
rownames(cont_table) <- c("Marginal", "Response")
colnames(cont_table) <- c("Recovered", "Sustained")

fisher_res <- fisher.test(cont_table)
pval_fisher <- fisher_res$p.value
odds_ratio <- fisher_res$estimate

# --- Step 5: Add Fisher results to the table ---
summary_table <- summary_table %>%
  mutate(Fisher_pvalue = ifelse(Study %in% c("Marginal eQTLs", "Response eQTLs"), pval_fisher, NA),
         Odds_Ratio = ifelse(Study %in% c("Marginal eQTLs", "Response eQTLs"), odds_ratio, NA))

# --- Step 6: Print summary ---
summary_table %>%
  select(Study, Category, Count, Proportion, Fisher_pvalue, Odds_Ratio) %>%
  arrange(Study, Category) %>%
  print(n = Inf)


```

#USE THIS ONE eQTLs
```{r eQTLs overlap in CMF Genes}

# Knowles eQTLs vs Motif Genes

# --- Step 1: Load data ---
# knowles_eqtls_supp4 <- readRDS("data/new/eQTLs/knowles_eqtls_supp4.RDS")
# knowles_eqtls_supp5 <- readRDS("data/new/eQTLs/knowles_eqtls_supp5.RDS")

# --- Step 2: Helper to convert Ensembl -> Entrez ---
# convert_ids <- function(df, id_col = "gene") {
#   ids <- df[[id_col]]
#   mapped <- AnnotationDbi::select(
#     org.Hs.eg.db,
#     keys = ids,
#     keytype = "ENSEMBL",
#     columns = c("ENTREZID", "SYMBOL")
#   )
#   colnames(mapped)[colnames(mapped) == "ENSEMBL"] <- id_col
#   colnames(mapped)[colnames(mapped) == "ENTREZID"] <- "Entrez_ID"
#   
#   df_out <- df %>%
#     left_join(mapped, by = id_col)
#   return(df_out)
# }

# knowles_eqtls_supp4_annot <- convert_ids(knowles_eqtls_supp4, "gene")
# knowles_eqtls_supp5_annot <- convert_ids(knowles_eqtls_supp5, "gene")


# saveRDS(knowles_eqtls_supp4_annot, "data/new/eQTLs/knowles_eqtls_supp4_entrez.RDS")
# saveRDS(knowles_eqtls_supp5_annot, "data/new/eQTLs/knowles_eqtls_supp5_entrez.RDS")

#load entrez and hgnc converted dataframes

knowles_eqtls_supp4_annot <- readRDS("data/new/eQTLs/knowles_eqtls_supp4_entrez.RDS")
knowles_eqtls_supp5_annot <- readRDS("data/new/eQTLs/knowles_eqtls_supp5_entrez.RDS")

# --- Step 3: Extract Entrez IDs ---
knowles4_ids <- unique(knowles_eqtls_supp4_annot$Entrez_ID[!is.na(knowles_eqtls_supp4_annot$Entrez_ID)])
knowles5_ids <- unique(knowles_eqtls_supp5_annot$Entrez_ID[!is.na(knowles_eqtls_supp5_annot$Entrez_ID)])
all_genes_knowles <- unique(c(knowles4_ids, knowles5_ids))

# --- Step 4: Motif gene sets (already in Entrez_ID) ---
recovered_entrez <- final_genes_1_RUV
sustained_entrez <- final_genes_2_RUV
all_tested_genes <- unique(c(recovered_entrez, sustained_entrez))

# --- Step 5: Categorization function ---
categorize_motif <- function(g) {
  if (g %in% recovered_entrez) return("Recovered")
  else if (g %in% sustained_entrez) return("Sustained")
  else return(NA)
}

# --- Step 6: Build summary per study ---
studies_knowles <- list(
  "Motif Genes"    = all_tested_genes,
  "Marginal eQTLs" = knowles4_ids,
  "Response eQTLs" = knowles5_ids
)

df_motif_knowles <- lapply(names(studies_knowles), function(study) {
  ids <- studies_knowles[[study]]
  cats <- sapply(ids, categorize_motif)
  
  data.frame(Category = cats, stringsAsFactors = FALSE) %>%
    filter(!is.na(Category)) %>%
    group_by(Category) %>%
    summarise(Count = n(), .groups = "drop") %>%
    complete(Category = c("Recovered", "Sustained"), fill = list(Count = 0)) %>%
    mutate(Study = study,
           TotalGenes = sum(Count),
           Proportion = Count / sum(Count))
}) %>% bind_rows()

# --- Step 7: Factor ordering ---
df_motif_knowles <- df_motif_knowles %>%
  mutate(
    Study = factor(Study, levels = c("Motif Genes", "Marginal eQTLs", "Response eQTLs")),
    Category = factor(Category, levels = c("Sustained", "Recovered"))
  )

# --- Step 8: Fishers Exact Test (Marginal vs Response) ---
df_marginal <- df_motif_knowles %>% filter(Study == "Marginal eQTLs") %>% select(Category, Count)
df_response <- df_motif_knowles %>% filter(Study == "Response eQTLs") %>% select(Category, Count)

cont_table <- matrix(c(
  df_marginal$Count[df_marginal$Category == "Recovered"],
  df_marginal$Count[df_marginal$Category == "Sustained"],
  df_response$Count[df_response$Category == "Recovered"],
  df_response$Count[df_response$Category == "Sustained"]
), nrow = 2, byrow = TRUE)
rownames(cont_table) <- c("Marginal", "Response")
colnames(cont_table) <- c("Recovered", "Sustained")

fisher_res <- fisher.test(cont_table)

# Significance stars
sig_label <- if (fisher_res$p.value < 0.001) {
  "***"
} else if (fisher_res$p.value < 0.01) {
  "**"
} else if (fisher_res$p.value < 0.05) {
  "*"
} else {
  "ns"
}

# --- Step 9: Plot ---
p <- ggplot(df_motif_knowles, aes(x = Study, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity") +
  # % labels inside bars
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1, suffix = NULL)),
            position = position_stack(vjust = 0.5), size = 3.5, color = "white") +
  geom_text(data = df_motif_knowles %>% group_by(Study) %>% summarise(n = sum(Count)),
            aes(x = Study, y = 1, label = paste0("n = ", n)),
            inherit.aes = FALSE, vjust = -0.2, size = 3.5, color = "black") +
  # Significance annotation above Marginal vs Response
  geom_segment(aes(x = 2, xend = 3, y = 0.9, yend = 0.9),
               inherit.aes = FALSE, size = 0.7) +
  geom_text(aes(x = 2.5, y = 1.08, label = sig_label),
            inherit.aes = FALSE, size = 6) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 1.1)) +
  scale_fill_manual(values = c("Recovered" = "#1f77b4", "Sustained" = "#ff7f0e")) +
  theme_minimal(base_size = 14) +
  labs(
    y = "Proportion of Motif Genes (%)",
    x = "",
    fill = "Motif Category",
    title = "Knowles et al.: Proportion of eQTL-associated Motif Genes"
  )

print(p)

# --- Step 10: Output summary stats ---
summary_stats <- data.frame(
  Comparison = "Marginal vs Response eQTLs",
  P_value = fisher_res$p.value,
  Odds_Ratio = fisher_res$estimate,
  CI_lower = fisher_res$conf.int[1],
  CI_upper = fisher_res$conf.int[2]
)

print("===== Contingency Table =====")
print(cont_table)
print("===== Fishers Exact Test Results =====")
print(summary_stats)


```


#Combine all studies and split by type
```{r Combine all studies}

#collect gene sets from all sources
all_genes <- unique(filcpm_matrix)
all_mtf_genes <- unique(c(final_genes_1_RUV, final_genes_2_RUV))

# knowles_eqtls_supp4_annot <- readRDS("data/new/eQTLs/knowles_eqtls_supp4_entrez.RDS")
# knowles_eqtls_supp5_annot <- readRDS("data/new/eQTLs/knowles_eqtls_supp5_entrez.RDS")
# 
# knowles4_ids <- unique(knowles_eqtls_supp4_annot$Entrez_ID[!is.na(knowles_eqtls_supp4_annot$Entrez_ID)])
# knowles5_ids <- unique(knowles_eqtls_supp5_annot$Entrez_ID[!is.na(knowles_eqtls_supp5_annot$Entrez_ID)])

# saveRDS(knowles4_ids, "data/new/eQTLs/knowles_ids_supp4.RDS")
# saveRDS(knowles5_ids, "data/new/eQTLs/knowles_ids_supp5.RDS")

#sustained gene groups
inc_sus_genes <- df_sustained_full_all %>%
  dplyr::filter(Category == "absFC t144 > t0")

dec_sus_genes <- df_sustained_full_all %>%
  dplyr::filter(Category == "absFC t144 < t0")

# saveRDS(inc_sus_genes, "data/new/RUV/CMF/Progressing_Sustained_M2_Set_genes.RDS")
   
# saveRDS(dec_sus_genes, "data/new/RUV/CMF/Recovering_Sustained_M2_Set_genes.RDS")

#read in the ids for eQTLs marginal and response
m_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp4.RDS")
r_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp5.RDS")

all_eqtls <- unique(c(m_eqtls_ids, r_eqtls_ids))

#read in the ids for all other gene sets
liu_ids <- readRDS("data/new/RUV/liu_dataset_entrez.RDS")
sapp_ids <- readRDS("data/new/RUV/sapp_dataset_entrez.RDS")
fonoudi_ids <- readRDS("data/new/RUV/fonoudi_dataset_entrez.RDS") #prev DIC
AIC_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS") #this is now DIC
AIC_set <- unique(na.omit(AIC_genes)) #this is now DIC
p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")
p53_set <- unique(na.omit(p53_target_genes))
DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")
ddr_set <- unique(na.omit(DNA_damage_genes))

# --- Step 2: Function to categorize by motif membership ---
categorize_motif <- function(g) {
  if (g %in% final_genes_1_RUV) {
    return("Recovered")
  } else if (g %in% final_genes_2_RUV) {
    return("Sustained")
  } else {
    return(NA)
  }
}


#build dataset of all studies being included
all_studies <- list(
  "All Genes" = all_genes,
  "All Motif Genes" = all_mtf_genes,
  "Fonoudi" = fonoudi_ids,
  "Liu" = liu_ids,
  "Sapp" = sapp_ids,
  "DIC Set" = AIC_set,
  "Marginal eQTLs" = knowles4_ids,
  "Response eQTLs" = knowles5_ids
)

df_motif <- lapply(names(all_studies), function(study) {
  ids <- all_studies[[study]]
  cats <- sapply(ids, categorize_motif)
  data.frame(Study = study, Category = cats, stringsAsFactors = FALSE)
}) %>% bind_rows()

# Remove unassigned / NA genes
df_motif <- df_motif %>% filter(!is.na(Category))

# --- Step 4: Summarize counts and proportions ---
summary_motif <- df_motif %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop_last") %>%
  mutate(Proportion = Count / sum(Count))

# Print summary table
summary_motif %>%
  arrange(Study, Category) %>%
  mutate(Percent = round(Proportion*100, 1)) %>%
  print(n = Inf)

# --- Step 5: Factor Study and Category for proper order ---
study_levels <- c("All Genes", "All Motif Genes", "Fonoudi", "Liu", "Sapp", "Marginal eQTLs", "Response eQTLs")
category_levels <- c("Sustained", "Recovered")

summary_motif <- summary_motif %>%
  mutate(
    Study = factor(Study, levels = study_levels),
    Category = factor(Category, levels = category_levels)
  )

# --- Step 6: Plot ---
everyset_prop_bar_knowles <- ggplot(summary_motif, aes(x = Study, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1)),
            position = position_stack(vjust = 0.5),
            size = 3.5, color = "white") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(values = c(
    "Recovered"  = "#1f77b4",
    "Sustained"  = "#ff7f0e"
  )) +
  scale_x_discrete(labels = c("All \n Genes", 
                              "All Cluster \n Genes", 
                              "Fonoudi \n et al.", 
                              "Liu \n et al.", 
                              "Sapp \n et al.",
                              "Marginal \n eQTLs", 
                              "Response \n eQTLs")) +
  theme_custom() +
  labs(
    y = "Proportion of Genes",
    x = "",
    fill = "Motif Category",
    title = "Knowles et al.: Proportion of eQTL-associated Genes by Motif Category"
  )

save_plot(plot = everyset_prop_bar_knowles,
          folder = output_folder,
          filename = "Prop_Barplot_eQTLs_AllGeneSets_Motifs_EMP",
          height = 6,
          width = 8)

#now make a version with forest plots of odds ratios with each motif


```

#Forest All Genes
```{r Combine Gene Sets Forest Plots of Odds Ratios}

#collect gene sets from all sources
m_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp4.RDS")
r_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp5.RDS")
all_eqtls <- unique(c(m_eqtls_ids, r_eqtls_ids))
all_genes <- unique(filcpm_matrix)
all_mtf_genes <- unique(c(final_genes_1_RUV, final_genes_2_RUV))
liu_ids <- readRDS("data/new/RUV/liu_dataset_entrez.RDS")
sapp_ids <- readRDS("data/new/RUV/sapp_dataset_entrez.RDS")
fonoudi_ids <- readRDS("data/new/RUV/fonoudi_dataset_entrez.RDS") #prev DIC
DIC_rm_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS") #now DIC
p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")
DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

#read in cluster genes for recovered and sustained
final_genes_1_RUV <- readRDS("data/new/RUV/CMF/final_genes_1_RUV.RDS")
final_genes_2_RUV <- readRDS("data/new/RUV/CMF/final_genes_2_RUV.RDS")

#include two subsets of sustained - progressing and recovering
proSus_genes_df <- readRDS("data/new/RUV/CMF/Progressing_Sustained_M2_Set_genes.RDS")  #t0 < t144 #should be 296 genes total
recSus_genes_df <- readRDS("data/new/RUV/CMF/Recovering_Sustained_M2_Set_genes.RDS")  #t0 > t144 #should be 205 genes total
#these are full dataframes of information with their characteristics
#make another set called
# proSus_genes <- proSus_genes_df$Entrez_ID
# recSus_genes <- recSus_genes_df$Entrez_ID

# saveRDS(proSus_genes, "data/new/RUV/CMF/proSus_entrezids.RDS")
# saveRDS(recSus_genes, "data/new/RUV/CMF/recSus_entrezids.RDS")

proSus_genes <- readRDS("data/new/RUV/CMF/proSus_entrezids.RDS")
length(proSus_genes)
recSus_genes <- readRDS("data/new/RUV/CMF/recSus_entrezids.RDS")
length(recSus_genes)

#list of gene categories
gene_cats <- list( 
  "DNA Damage Response Genes" = unique(na.omit(DNA_damage_genes)),
  "DOX Cardiotoxicity Genes" = unique(na.omit(AIC_genes)),
  "p53 Target Genes" = unique(na.omit(p53_target_genes)),
  "Fonoudi et al." = fonoudi_ids,
  "Liu et al." = liu_ids,
  "Sapp et al." = sapp_ids,
  "Marginal eQTLs" = m_eqtls_ids,
  "Response eQTLs" = r_eqtls_ids
)

#make a function to run through fisher's exact testing to find odds ratios
#comparing each sustained group to recovered for all
fisher_test_enrichment <- function(gene_cats, test_genes, ref_genes) {
  a <- sum(test_genes %in% gene_cats)
  b <- length(test_genes) - a
  c <- sum(ref_genes %in% gene_cats)
  d <- length(ref_genes) - c
  
  mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
                dimnames = list(Group = c("Test", "Reference"),
                                Category = c("InSet", "NotInSet")))
  
  ft <- fisher.test(mat)
  
  tibble(
    OR = unname(ft$estimate),
    CI_low = ft$conf.int[1],
    CI_high = ft$conf.int[2],
    p_value = ft$p.value,
    Significant = case_when(
      ft$p.value < 0.001 ~ "***",
      ft$p.value < 0.01  ~ "**",
      ft$p.value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  )
}


#function to compare the gene sets to one another
compare_sets <- function(test_genes, ref_genes, label) {
  summary_df <- map_dfr(names(gene_cats), function(cat_name) {
    res <- fisher_test_enrichment(gene_cats[[cat_name]], 
                                  test_genes, ref_genes)
    res %>% mutate(Category = cat_name)
  })
  
  summary_df$Category <- factor(summary_df$Category, 
                                levels = rev(names(gene_cats)))
  summary_df$Comparison <- label
  return(summary_df)
}

#make all comparisons
comparisons <- bind_rows(
  compare_sets(final_genes_2_RUV, 
               final_genes_1_RUV, 
               "Sustained vs Recovered"),
  compare_sets(recSus_genes,
               final_genes_1_RUV, 
               "recSustained vs Recovered"),
  compare_sets(proSus_genes, 
               final_genes_1_RUV,
               "proSustained vs Recovered")
)

comparisons <- comparisons %>%
  mutate(
    OR_plot = ifelse(OR == 0, 1e-3, OR),
    CI_low_plot = ifelse(CI_low == 0, 1e-3, CI_low),
    CI_high_plot = ifelse(CI_high == 0, 1e-3, CI_high)
  )

#order factors for plotting
comparisons$Category <- factor(comparisons$Category, levels = rev(names(gene_cats)))

comparisons$Comparison <- factor(
  comparisons$Comparison,
  levels = c("Sustained vs Recovered", 
             "recSustained vs Recovered", 
             "proSustained vs Recovered")
)

#generate six forest plots: 3x log scale, 3x standard scale

make_forest_plot <- function(df, log_scale = TRUE) {
  
  #add a small epsilon to avoid plotting issues
  epsilon <- 0.001
  df_plots <- df %>%
    mutate(
      OR_plot = ifelse(OR == 0, epsilon, OR),
      CI_low_plot = ifelse(CI_low == 0, epsilon, CI_low),
      CI_high_plot = CI_high
    )
  
  #then make the plots for linear and log
  p <- ggplot(df_plots, 
              aes(y = Category, x = OR_plot, 
                  xmin = CI_low_plot, xmax = CI_high_plot)) +
    geom_point(size = 3.5) +
    geom_errorbarh(height = 0.5,
                   linewidth = 0.5, 
                   linetype = "solid", 
                   color = "black") +
    geom_text(aes(label = Significant), 
              position = position_nudge(y = 0.3),
              color = "black", 
              size = 4) +
    geom_vline(xintercept = 1, 
               linetype = "dashed", 
               color = "red") +
    labs(x = ifelse(log_scale, "Odds Ratio (log scale)", "Odds Ratio"),
         y = "",
         title = unique(df_plots$Comparison)) +
    theme_custom() 

  # Apply consistent scale with limits covering all CIs
  if (log_scale) {
    p <- p + scale_x_log10(limits = c(0.001, 
                                      max(df$CI_high_plot, 
                                               na.rm = TRUE) * 2))
  } else {
    p <- p + scale_x_continuous(limits = c(-2, 40))
  }

  return(p)
}

#optional breaks to put in scale_x_log10 
##limits = c(0.01, 100), breaks = c(0.01, 0.1, 1, 10, 100)
#breaks = c(0.01, 0.1, 1, 10, 100, 1000, 10000)

#plot all forest plots
plots <- comparisons %>%
  group_split(Comparison) %>%
  map(~list(
    log = make_forest_plot(.x, log_scale = TRUE),
    linear = make_forest_plot(.x, log_scale = FALSE)
  ))

#create and view summary table
forest_summary_ordered <- comparisons %>%
  mutate(Category = factor(Category, 
                           levels = c("DNA Damage Response Genes", 
                                      "DOX Cardiotoxicity Genes", 
                                      "p53 Target Genes", 
                                      "Fonoudi et al.", 
                                      "Liu et al.", 
                                      "Sapp et al.", 
                                      "Marginal eQTLs", 
                                      "Response eQTLs"))) %>%
  arrange(Comparison, Category) %>%
  mutate(
    OR = round(OR, 3),
    CI_low = round(CI_low, 3),
    CI_high = round(CI_high, 3),
    p_value = signif(p_value, 3)
  )

#print the summary for all stats
print(forest_summary_ordered)

#label my comparisons for plots
comparison_labels <- c("Sus_Rec", "recSus_Rec", "proSus_Rec")

# for (i in seq_along(plots)) {
#   comp_name <- comparison_labels[i]
# 
#   # log-scale plot
#   save_plot(
#     plot = plots[[i]]$log,
#     filename = paste0("ForestPlot_", comp_name, "_log"),
#     folder = output_folder
#   )

  # # linear-scale plot
  # save_plot(
  #   plot = plots[[i]]$linear,
  #   filename = paste0("ForestPlot_", comp_name, "_linear_old"),
  #   folder = output_folder
  # )
# }


#now make the linear plots more polished
make_linear_forest_plot <- function(df) {
  
  #add a small epsilon to avoid plotting issues
  epsilon <- 0.001
  df_plot <- df %>%
    mutate(
      OR_plot = ifelse(OR == 0, epsilon, OR),
      CI_low_plot = ifelse(CI_low == 0, epsilon, CI_low),
      CI_high_plot = CI_high
    )
  
  # Find maximum x limit to show all CIs
  # x_max <- max(df_plot$CI_high_plot, na.rm = TRUE) * 1.2
  # x_min <- 0 # start from 0 so small ORs are visible
  
  p <- ggplot(df_plot, aes(y = Category, x = OR_plot,
                           xmin = CI_low_plot, 
                           xmax = CI_high_plot)) +
    geom_point(size = 3.5) +
    geom_errorbarh(height = 0.5, linewidth = 0.5, color = "black") +
    geom_text(aes(label = Significant), 
              position = position_nudge(y = 0.3), size = 4) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
    labs(x = "Odds Ratio (linear scale)", y = "Gene Set",
         title = unique(df$Comparison)) +
    theme_custom() +
    coord_cartesian(xlim = c(-2, 40))
  
  return(p)
}


comparisons$Comparison <- factor(
  comparisons$Comparison,
  levels = c("Sustained vs Recovered", 
             "recSustained vs Recovered", 
             "proSustained vs Recovered")
)

linear_plots <- comparisons %>%
  group_split(Comparison) %>%
  map(~ make_linear_forest_plot(.x))

# for (i in seq_along(linear_plots)) {
#   comp_name <- comparison_labels[i]
#   
#   # linear-scale plot
#   save_plot(
#     plot = linear_plots[[i]],
#     filename = paste0("ForestPlot_", comp_name, "_linear_EMP"),
#     folder = output_folder
#   )
# }

```

#Sustained Groups Forest Plots of Odds Ratios
```{r Odds Ratios Forest Plots Sus v Rec}

#load in all gene set data for forest plots 
m_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp4.RDS")
r_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp5.RDS")
liu_ids <- readRDS("data/new/RUV/liu_dataset_entrez.RDS")
sapp_ids <- readRDS("data/new/RUV/sapp_dataset_entrez.RDS")
fonoudi_ids <- readRDS("data/new/RUV/fonoudi_dataset_entrez.RDS")
AIC_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS") # DIC set
p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")
DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

final_genes_1_RUV <- readRDS("data/new/RUV/CMF/final_genes_1_RUV.RDS") # Recovered
final_genes_2_RUV <- readRDS("data/new/RUV/CMF/final_genes_2_RUV.RDS") # Sustained
proSus_genes <- readRDS("data/new/RUV/CMF/Progressing_Sustained_M2_Set_genes.RDS")
recSus_genes <- readRDS("data/new/RUV/CMF/Recovering_Sustained_M2_Set_genes.RDS")

#exchange proSus for the new set
proSus_genes_1 

```


```{r Overlap log2cpm}

#check overlap of proSus and recSus genes with all included sets
all_cat_genes <- unique(unlist(gene_cats))
recSus_overlap <- recSus_genes[recSus_genes %in% all_cat_genes]
length(recSus_overlap) #42 genes overlapping
recSus_overlap
#gene ids:
#57822, 5453, 1263, 55283, 8407, 118738, 355, 10346, 272, 220001, 3014, 1111, 441631, 1017, 55332, 54331, 5228, 2242, 56963, 2232, 129607, 6382, 26154, 83959, 55959, 30811, 11200, 3976, 4071, 2261, 1310, 27445, 4897, 8794, 8797, 9134, 81704
#check the genes to make sure that t0 > t144

proSus_overlap <- proSus_genes[proSus_genes %in% all_cat_genes]
length(proSus_overlap) #27 genes overlapping
proSus_overlap
#gene ids:
#84958, 29899, 983, 64787, 5888, 9133, 9235, 1006, 672, 9518, 55355, 1869, 2177, 993, 10721, 55214, 1363, 79682, 891, 1719, 995, 3161, 1026, 55166, 51435, 10592, 60401

#make a dataframe to assess which source these different genes overlapped in

cat_genes_df <- map_dfr(names(gene_cats), function(cat) {
  tibble(
    Entrez_ID = intersect(all_cat_genes, gene_cats[[cat]]),
    Category = cat
  )
})

dim(cat_genes_df)
#1499 genes overall from all categories

#filter overlaps for proSus
proSus_overlap <- cat_genes_df %>%
  filter(Entrez_ID %in% proSus_genes)
#33 genes overlap

#filter overlaps for recSus
recSus_overlap <- cat_genes_df %>%
  filter(Entrez_ID %in% recSus_genes)
#42 genes overlap

#also sanity check that these genes are DEGs that overlap with proSus recSus
sets_for_overlap <- list(
  proSus = proSus_overlap$Entrez_ID,
  recSus = recSus_overlap$Entrez_ID,
  geneSets = unique(unlist(gene_cats))
)

deg_wide <- combined_toptables_dxr_RUV %>%
  mutate(
    Timepoint = case_when(
      Time == "24T"  ~ "t0",
      Time == "24R"  ~ "t24",
      Time == "144R" ~ "t144",
      TRUE ~ NA_character_
    ),
    absFC = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, SYMBOL, Timepoint, logFC, absFC, adj.P.Val) %>%
  filter(!is.na(SYMBOL)) %>%
  pivot_wider(
    names_from = Timepoint,
    values_from = c(logFC, absFC, adj.P.Val),
    names_sep = "_"
  ) %>%
  mutate(
    DEG_t0   = adj.P.Val_t0   < 0.05,
    DEG_t24  = adj.P.Val_t24  < 0.05,
    DEG_t144 = adj.P.Val_t144 < 0.05
  )

recSus_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% recSus_overlap$Entrez_ID)

proSus_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% proSus_overlap$Entrez_ID)

#check whether the assumptions are stil the same that the absFC is t0 < t144
#recSus
recSus_pattern <- recSus_degs %>%
  mutate(correct_pattern = absFC_t0 > absFC_t144)

#proSus
proSus_pattern <- proSus_degs %>%
  mutate(correct_pattern = absFC_t0 < absFC_t144)

recSus_summary <- recSus_pattern %>%
  summarise(
    total_genes = n(),
    n_correct = sum(correct_pattern, na.rm = TRUE),
    percent_correct = 100 * n_correct / total_genes
  )

proSus_summary <- proSus_pattern %>%
  summarise(
    total_genes = n(),
    n_correct = sum(correct_pattern, na.rm = TRUE),
    percent_correct = 100 * n_correct / total_genes
  )

recSus_summary #37 genes follow the pattern
proSus_summary #27 genes follow the pattern



#since there are fewer genes here, I believe that there are multiples of the same genes within different categories
gene_category_counts <- cat_genes_df %>%
  group_by(Entrez_ID) %>%
  summarise(n_categories = n_distinct(Category),
            categories = paste(unique(Category), collapse = ", "),
            .groups = "drop") %>%
  arrange(desc(n_categories))

#pull genes that are in more than one category
shared_genes <- gene_category_counts %>%
  filter(n_categories > 1)

#view the genes that are shared across categories for curiosity
shared_genes
#160 genes are shared across at least two categories 
#(predominantly the eQTLs and reQTLs with 103 shared genes)


#find gene symbols
proSus_overlap <- proSus_overlap %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

recSus_overlap <- recSus_overlap %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

#now plot these example genes for each

#first change colnames pf my expression dataframe to match factors
boxplot_new <- boxplot1

expr_cols <- setdiff(colnames(boxplot_new), c("Entrez_ID", "SYMBOL"))

rename_cond <- function(colnames_vec) {
  colnames_vec <- gsub("DMSO", "VEH", colnames_vec)       # DMSO -> VEH
  colnames_vec <- gsub("_24T_", "_t0_", colnames_vec)     # 24T -> t0
  colnames_vec <- gsub("_24R_", "_t24_", colnames_vec)    # 24R -> t24
  colnames_vec <- gsub("_144R_", "_t144_", colnames_vec)  # 144R -> t144
  colnames_vec <- gsub("Ind6REP", "6R", colnames_vec)     # Ind6REP -> 6R
  colnames_vec <- gsub("Ind", "", colnames_vec)           
  return(colnames_vec)
}

new_expr_cols <- rename_cond(expr_cols)
colnames(boxplot_new)[match(expr_cols, colnames(boxplot_new))] <- new_expr_cols


#process the cpm data
process_cpm_data_cormotif <- function(gene_id, expr_df) {
  gene_data <- expr_df %>% filter(Entrez_ID == gene_id)
  
  long_data <- gene_data %>%
    pivot_longer(
      cols = -c(Entrez_ID, SYMBOL),
      names_to = "Sample",
      values_to = "log2CPM"
    ) %>%
    mutate(
      Treatment = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("VEH", Sample) ~ "VEH",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("t0", Sample) ~ "t0",
        grepl("t24", Sample) ~ "t24",
        grepl("t144", Sample) ~ "t144",
        TRUE ~ NA_character_
      ),
      Individual = case_when(
        grepl("1$", Sample) ~ "1",
        grepl("2$", Sample) ~ "2",
        grepl("3$", Sample) ~ "3",
        grepl("4$", Sample) ~ "4",
        grepl("5$", Sample) ~ "5",
        grepl("6$", Sample) ~ "6",
        grepl("6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Treatment, Timepoint, sep = "_")
    )
  
  # Set factor levels for plotting order
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c("DOX_t0", "VEH_t0", 
               "DOX_t24", "VEH_t24", 
               "DOX_t144", "VEH_t144")
  )
  
  return(long_data)
}

# Function to generate plots for a set of genes
generate_overlap_plots_cormotif <- function(overlap_df, expr_df, comparison_label) {
  plots <- list()
  
  for (gene_id in overlap_df$Entrez_ID) {
    gene_data <- process_cpm_data_cormotif(gene_id, expr_df)
    
    # Get SYMBOL and all categories
    gene_symbol <- unique(gene_data$SYMBOL)
    gene_categories <- overlap_df$Category[overlap_df$Entrez_ID == gene_id]
    gene_categories <- paste(unique(gene_categories), collapse = ", ")
    
    p <- ggplot(gene_data, aes(x = Condition, 
                               y = log2CPM,
                               fill = Condition)) +
      geom_boxplot(outlier.shape = NA) +
      geom_point(aes(color = Individual), size = 2, 
                 alpha = 0.9,
                 position = position_identity()) +
      scale_fill_manual(values = txtime_col) +
      scale_color_manual(values = ind_col) +
      ggtitle(paste0(gene_symbol,
                     " (", comparison_label, " in ", gene_categories, ") ")) +
      labs(x = "Condition", y = "log2cpm") +
      theme_custom()
    
    # Use Entrez_ID + SYMBOL + comparison label for the list name to guarantee uniqueness
    plot_name <- paste0(gene_symbol, "_", gene_id, "_", comparison_label)
    plots[[plot_name]] <- p
  }
  
  return(plots)
}

#generate plots for both
proSus_plots <- generate_overlap_plots_cormotif(proSus_overlap, boxplot_new, "proSus")
recSus_plots <- generate_overlap_plots_cormotif(recSus_overlap, boxplot_new, "recSus")

#preview all plots
for (p in c(proSus_plots, recSus_plots)) print(p)

# #save all of these plots with unique names
# for (plot_name in names(proSus_plots)) {
#   save_plot(proSus_plots[[plot_name]], 
#             filename = paste0("ExGene_", plot_name, "_EMP"), 
#             folder = output_folder)
# }
# 
# for (plot_name in names(recSus_plots)) {
#   save_plot(recSus_plots[[plot_name]], 
#             filename = paste0("ExGene_", plot_name, "_EMP"), 
#             folder = output_folder)
# }

```


#New Analysis 09/25/25

##Motifs overlapping DEGs barplot
```{r Barplot of CMF motifs on DEGs}

#Import the CMF genes that you'll be using for these barplots
final_genes_1_RUV <- readRDS("data/new/RUV/CMF/final_genes_1_RUV.RDS")
final_genes_2_RUV <- readRDS("data/new/RUV/CMF/final_genes_2_RUV.RDS")


#define DE gene sets
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") 
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% dplyr::select(-X)
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% dplyr::select(-X)

DE_24T <- DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05]
DE_24R <-  DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05]
DE_144R <- DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]

# Background (all genes tested)
all_genes <- rownames(filcpm_matrix)
cat("Total background genes:", length(all_genes), "\n")
#should be comparing to background of all expressed genes, 14319 total

# --- Step 4: Function to classify ---
categorize_gene <- function(g) {
  in24T <- g %in% DE_24T
  in24R <- g %in% DE_24R
  in144R <- g %in% DE_144R
  
  if (in24T && !in24R && !in144R) {
    return("DE in 24T only")
  } else if (in24T && in24R && !in144R) {
    return("DE in 24T and 24R")
  } else if (in24T && in24R && in144R) {
    return("DE in all timepoints")
  } else {
    return("Not DE")
  }
}

# --- Step 5: Build data frame ---
motif_gene_test <- list(
  Sustained   = final_genes_2_RUV,
  Recovered  = final_genes_1_RUV,
  AllGenes = unique(all_genes, na.rm = TRUE)
)

df <- lapply(names(motif_gene_test), function(motif_study) {
  ids <- motif_gene_test[[motif_study]]
  cats <- sapply(ids, categorize_gene)
  data.frame(Motif_study = motif_study, Category = cats)
}) %>% bind_rows()

# --- Step 6: Summarize counts and proportions ---
summary_table_mtf <- df %>%
  group_by(Motif_study, Category) %>%
  summarise(Count = n(), .groups = "drop_last") %>%
  mutate(Proportion = Count / sum(Count))

# --- Step 6b: Print summary table in console ---
summary_table_mtf %>%
  arrange(Motif_study, Category)

# --- Step 6b: Factor Study with AllGenes last ---
mtf_levels <- c("AllGenes", "Sustained", "Recovered")
summary_table_mtf <- summary_table_mtf %>%
  mutate(
    Study = factor(Motif_study, levels = mtf_levels),
    Percent = round(Proportion*100, 1)
  )  %>%  
  print(n = Inf) 

# --- Step 6c: Rename categories for plot labels ---
category_labels <- c(
  "DE in 24T only"       = "DE in t0 only",
  "DE in 24T and 24R"    = "DE in t0 + t24",
  "DE in all timepoints" = "DE in t0 + t24 + t144",
  "Not DE"               = "Not DE"
)

# --- Step 7: Plot with reordered bars and relabeled categories ---
mtf_deg_overlap_plot <- ggplot(summary_table_mtf, aes(x = Motif_study, y = Percent, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Percent),
            position = position_stack(vjust = 0.5),
            size = 3.5, color = "white") +
  scale_y_continuous(limits = c(0,100)) +
  scale_fill_manual(
    values = c(
      "DE in 24T only"       = "#1f77b4",
      "DE in 24T and 24R"    = "#ff7f0e",
      "DE in all timepoints" = "#2ca02c",
      "Not DE"               = "#d62728"
    ),
    labels = category_labels
  ) +
  scale_x_discrete() +
  theme_custom()  +
  labs(
    y = "Percent of Genes (%)",
    x = "",
    fill = "Category"
  )

print(mtf_deg_overlap_plot)

save_plot(
  plot = mtf_deg_overlap_plot,
  filename = "DEGs_vs_motifs_EMP",
  folder = output_folder
)

```

##Evaluate Sustained motif over time vs DEGs
```{r Categories for Sustained Motif Genes}

#read in the gene set that you'll use - sustained
final_genes_2_RUV
#501 genes

#read in toptables after RUV, need logFC 
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") 
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% 
  dplyr::select(-(X))
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% 
  dplyr::select(-(X))

combined_toptables_dxr_list <- list(
  "t0" = DOX_24T_R,
  "t24" = DOX_24R_R,
  "t144" = DOX_144R_R
)

#filter for significance based on adj p < 0.05 and mutate logFC into absolute logFC (absFC)
# all_DEGs_dxr <- lapply(combined_toptables_dxr_RUV, function(df) {
#   df %>% 
#     dplyr::filter(adj.P.Val < 0.05) %>% 
#     mutate(absFC = abs(logFC))
# })

all_genes_dxr <- lapply(combined_toptables_dxr_RUV, function(df) {
  df %>% 
    mutate(absFC = abs(logFC))
})

#background (all expressed genes)
all_genes <- rownames(filcpm_matrix)
# all_genes <- readRDS("data/new/RUV/all_expressed_genes_list.RDS")
cat("Total background genes:", length(all_genes), "\n")
# saveRDS(all_genes, "data/new/RUV/all_expressed_genes_list.RDS")
#should be comparing to background of all expressed genes, 14319 total

#I have four categories I would like to classify my sustained gene set into to see if sustained is an appropriate name
#are the genes changing over time? are they staying the same?
#category 1: DEGs at t144
#category 2: t0 < t144
#category 3: t0 > t144
#category 4: t0 = t144

#now that I have the absolute logFC and the list of my significant DEGs, make a function

#create a function to categorize my sustained genes
categorize_sustained <- function(gene, all_genes_dxr) {
  #pull tibbles
  t0  <- all_genes_dxr[["t0"]]
  t144 <- all_genes_dxr[["t144"]]
  
  #pull absLogFC values if gene exists, else NA
  absFC_t0  <- if (gene %in% t0$Entrez_ID)  t0 %>%
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t144 <- if (gene %in% t144$Entrez_ID) t144 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  
  #assign categories based on comparison first
  if (!is.na(absFC_t0) & !is.na(absFC_t144)) {
    if (absFC_t0 < absFC_t144) {
      return("absFC t0 < t144")
    } else if (absFC_t0 > absFC_t144) {
      return("absFC t0 > t144")
    } else if (absFC_t0 == absFC_t144) {
      return("absFC t0 = t144")
    }
  }
  if (gene %in% t144$Entrez_ID) {
    return("DEG t144")
  }
  
  return("nonDE")
}

#apply function to sustained motif 2 genes
sustained_cats <- sapply(final_genes_2_RUV, categorize_sustained, all_genes_dxr = all_genes_dxr)

#build dataframe for plotting
df_sustained <- data.frame(
  Study = "Sustained",
  Entrez_ID = final_genes_2_RUV,
  Category = sustained_cats,
  stringsAsFactors = FALSE
)

#make another small dataframe including the logFC abslogFC etc
#prepare each toptable manually
t0 <- combined_toptables_dxr_RUV[["t0"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t0 = logFC,
    adjP_t0  = adj.P.Val,
    Sig_t0   = ifelse(adj.P.Val < 0.05, "yes", "no"),
    absFC_t0 = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t0, adjP_t0, Sig_t0, absFC_t0)

t24 <- combined_toptables_dxr_RUV[["t24"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t24 = logFC,
    adjP_t24  = adj.P.Val,
    Sig_t24   = ifelse(adj.P.Val < 0.05, "yes", "no"),
    absFC_t24 = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t24, adjP_t24, Sig_t24, absFC_t24)

t144 <- combined_toptables_dxr_RUV[["t144"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t144 = logFC,
    adjP_t144  = adj.P.Val,
    Sig_t144   = ifelse(adj.P.Val < 0.05, "yes", "no"),
    absFC_t144 = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t144, adjP_t144, Sig_t144, absFC_t144)

#change type to match
df_sustained$Entrez_ID <- as.integer(df_sustained$Entrez_ID)
t0$Entrez_ID <- as.integer(t0$Entrez_ID)
t24$Entrez_ID <- as.integer(t24$Entrez_ID)
t144$Entrez_ID <- as.integer(t144$Entrez_ID)


# Join all timepoints to sustained genes
df_sustained_full <- df_sustained %>%
  left_join(t0,   by = "Entrez_ID") %>%
  left_join(t24,   by = "Entrez_ID") %>%
  left_join(t144,  by = "Entrez_ID")

# write.csv(df_sustained_full, "data/new/RUV/CMF/sustained_df_logfc_changes_EMP_250925.csv")

######

summary_sustained <- df_sustained %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Proportion = Count / sum(Count))

#define colors and labels
category_labels <- c(
  "DEGs at t144"       = "DE at t144",
  "absFC t0 < t144"   = "absFC t0 < t144",
  "absFC t0 > t144"   = "absFC t0 > t144",
  "absFC t144 = t0"   = "absFC t144 = t0",
  "Not DE"             = "nonDE"
)

category_colors <- c(
  "DE at t144"       = "#2ca02c",
  "absFC t0 < t144"   = "#1f77b4",
  "absFC t0 > t144"   = "#ff7f0e",
  "absFC t144 = t0"   = "#d62728",
  "nonDE"             = "#d3d3d3"
)

#plot proportion barplot
ggplot(summary_sustained, aes(x = Study, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1)),
            position = position_stack(vjust = 0.5),
            size = 4, color = "white") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(values = category_colors, labels = category_labels) +
  theme_minimal(base_size = 14) +
  labs(
    y = "Proportion of Sustained Genes",
    x = "",
    fill = "Category"
  )

#create summary table
summary_table_sustained <- summary_sustained %>%
  arrange(desc(Proportion)) %>%
  mutate(
    Percent = round(Proportion * 100, 1)
  )

#print full table
print(summary_table_sustained, n = Inf)

###########################################
# #now I want to edit this code to not plot the nonDE section
# 
# categorize_sustained_4 <- function(gene, all_genes_dxr) {
#   #pull tibbles
#   t0  <- all_genes_dxr[["24T"]]
#   t144 <- all_genes_dxr[["144R"]]
#   
#   #pull absLogFC values if gene exists, else NA
#   absFC_24T  <- if (gene %in% t0$Entrez_ID)  t0 %>% filter(Entrez_ID == gene) %>% pull(absFC) else NA_real_
#   absFC_144R <- if (gene %in% t144$Entrez_ID) t144 %>% filter(Entrez_ID == gene) %>% pull(absFC) else NA_real_
#   
#   #assign categories based on comparison first
#   if (!is.na(absFC_24T) & !is.na(absFC_144R)) {
#     if (absFC_144R > absFC_24T) {
#       return("absFC t0 < t144")
#     } else if (absFC_144R < absFC_24T) {
#       return("absFC t0 > t144")
#     } else if (absFC_144R == absFC_24T) {
#       return("absFC t0 = t144")
#     }
#   }
#   if (gene %in% t144R$Entrez_ID) {
#     return("DEG at t144")
#   }
#   return(NA)
# }
# 
# #build dataframe for plotting from sustained genes function
# df_sustained_4 <- data.frame(
#   Study = "Sustained",
#   Entrez_ID = final_genes_2_RUV,
#   Category = sapply(final_genes_2_RUV, categorize_sustained_4, all_DEGs_dxr = all_DEGs_dxr)
# )
# 
# df_sustained_4 <- df_sustained_4 %>% 
#   dplyr::filter(!is.na(Category))
# 
# summary_sustained_4 <- df_sustained_4 %>%
#   group_by(Study, Category) %>%
#   summarise(Count = n(), .groups = "drop") %>%
#   mutate(Proportion = Count / sum(Count),
#          Percent = Count/sum(Count) * 100)
# 
# #define colors and labels
# category_labels_4 <- c(
#   "DEGs at 144R"       = "DEGs at t144",
#   "absFC t144 > t0"   = "absFC t144 > t0",
#   "absFC t144 < t0"   = "absFC t144 < t0",
#   "absFC t144 = t0"   = "absFC t144 = t0"
# )
# 
# category_colors_4 <- c(
#   "DEG at t144"       = "#2ca02c",
#   "absFC t144 > t0"   = "#1f77b4",
#   "absFC t144 < t0"   = "#ff7f0e",
#   "absFC t144 = t0"   = "#d62728"
# )
# 
# #barplot for DE categories only
# plot_summary_sustained_4 <- ggplot(summary_sustained_4, aes(x = Study, y = Percent, fill = Category)) +
#   geom_bar(stat = "identity") +
#   geom_text(aes(label = paste0(round(Percent, 1), "\n(n = ", Count, ")")),
#             position = position_stack(vjust = 0.5),
#             size = 4, color = "white") +
#   scale_y_continuous(limits = c(0,100)) +
#   scale_fill_manual(values = category_colors_4,
#                     labels = category_labels_4) +
#   theme_custom() +
#   labs(
#     y = "Percent of Sustained Genes (%)",
#     x = "",
#     fill = "Category"
#   )
# 
# print(plot_summary_sustained_4)
# 
# save_plot(
#   plot = plot_summary_sustained_4,
#   filename = "Sustained_Proportion_Barplot_DEGs_EMP",
#   folder = output_folder
# )
```

#Sustained Groups Updated Code
```{r Barplots for Sustained Groups}
#combine my toptables together
combined_toptables_dxr_RUV <- list(
  "t0"   = DOX_24T_R %>% mutate(absFC = abs(logFC)),
  "t24"  = DOX_24R_R %>% mutate(absFC = abs(logFC)),
  "t144" = DOX_144R_R %>% mutate(absFC = abs(logFC))
)

all_genes_dxr <- lapply(combined_toptables_dxr_RUV, function(df) {
  df %>%
    # dplyr::filter(adj.P.Val < 0.05) %>%
    mutate(absFC = abs(logFC))
})

#make a function to categorize these genes
categorize_sustained_final <- function(gene, all_genes_dxr) {
  # pull DEGs at t0 and t144
  t0   <- all_genes_dxr[["t0"]]
  t24  <- all_genes_dxr[["t24"]]
  t144 <- all_genes_dxr[["t144"]]
  
  # absFC values if present
  absFC_t0   <- if (gene %in% t0$Entrez_ID)   t0 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t24   <- if (gene %in% t24$Entrez_ID)   t24 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t144 <- if (gene %in% t144$Entrez_ID) t144 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  
  # assign categories based on absFC patterns
  if (!is.na(absFC_t0) & !is.na(absFC_t144)) {
    if (absFC_t0 < absFC_t144) {
      return("recSus")
    } else if (absFC_t0 > absFC_t144) {
      return("proSus")
    } else if (absFC_t0 == absFC_t144) {
      return("absFC_t0 = absFC_t144")
    }
  }
  if (gene %in% t144$Entrez_ID) {
    return("DEG_t144_only")
  }
  return(NA_character_)
}

#make into a dataframe
df_sustained <- data.frame(
  Study = "Sustained",
  Entrez_ID = final_genes_2_RUV,
  Category = sapply(final_genes_2_RUV, categorize_sustained_fixed, all_DEGs_dxr = all_DEGs_dxr),
  stringsAsFactors = FALSE
) %>%
  dplyr::filter(!is.na(Category))

#divide these out by timepoint
t0 <- combined_toptables_dxr[["t0"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t0  = logFC,
    adjP_t0   = adj.P.Val,
    Sig_t0    = ifelse(adj.P.Val < 0.05, "yes", "no"),
    absFC_t0  = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t0, absFC_t0, adjP_t0, Sig_t0)

t144 <- combined_toptables_dxr[["t144"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t144 = logFC,
    adjP_t144  = adj.P.Val,
    Sig_t144   = ifelse(adj.P.Val < 0.05, "yes", "no"),
    absFC_t144 = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t144, absFC_t144, adjP_t144, Sig_t144)

# make sure Entrez_ID types match
df_sustained$Entrez_ID <- as.integer(df_sustained$Entrez_ID)
t0$Entrez_ID <- as.integer(t0$Entrez_ID)
t144$Entrez_ID <- as.integer(t144$Entrez_ID)

# join for full data frame
df_sustained_full <- df_sustained %>%
  left_join(t0,   by = "Entrez_ID") %>%
  left_join(t144, by = "Entrez_ID")

# ---- Summarize ----

summary_sustained <- df_sustained %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Proportion = Count / sum(Count),
         Percent = round(Proportion * 100, 1))

# ---- Plot ----

category_colors <- c(
  "recSus" = "#1f77b4",  
  "proSus" = "#ff7f0e",  
  "absFC_t0 = absFC_t144"          = "#d62728",  
  "DEG_t144_only"                  = "#2ca02c"   
)

plot_sustained_summary <- ggplot(summary_sustained, aes(x = Study, y = Percent, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(Percent, 1), "%\n(n = ", Count, ")")),
            position = position_stack(vjust = 0.5),
            size = 4, color = "white") +
  scale_y_continuous(limits = c(0, 102)) +
  scale_fill_manual(values = category_colors) +
  theme_custom() +
  labs(
    y = "Percent of Sustained Genes (%)",
    x = "",
    fill = "Category"
  )

print(plot_sustained_summary)

save_plot(
  plot = plot_sustained_summary,
  filename = "Sustained_Proportion_Barplot_DEGs_EMP",
  folder = output_folder
)

```


###Go Analysis t0 < t144 genes proSus
```{r GO Analysis increasing abslogFC Previous}
#Of the previous data, I am interested in the genes from our sustained motif that are increasingly different over time 
#this would be the 205 genes where t0 < t144 - named proSus

#I changed this one from filtering for sig DEGs to all
# df_sustained_full_all <- df_sustained_full
# saveRDS(df_sustained_full_all, "data/new/RUV/CMF/sustained_proportions_dataframe.RDS")

# saveRDS(df_sustained_full, "data/new/RUV/CMF/Sustained_groups_dataframe.RDS")

df_sustained_full_all <- readRDS("data/new/RUV/CMF/Sustained_groups_dataframe.RDS")

proSus_genes <- df_sustained_full_all %>% 
  dplyr::filter(Category == "proSus")
  
proSus_gene_list <- proSus_genes$Entrez_ID
length(proSus_gene_list) #205 genes

#background
# all_genes

length(proSus_gene_list)
#now 205 not filt for DEGs

proSus_GOKEGG_RUV <- gost(query = proSus_gene_list,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          significant = TRUE,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

proSus_GOKEGG_genes_RUV <- gostplot(proSus_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
proSus_GOKEGG_genes_RUV

table_proSus_GOKEGG_genes_RUV <- proSus_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_proSus_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

 # write.csv(table_incsus_GOKEGG_genes_RUV, "data/new/RUV/CMF/table_incsus_GOKEGG_genes_RUV.csv")

#GO:BP
table_proSus_genes_GOBP_RUV <- table_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

proSus_table_genes_GOBP_plot <- ggplot(table_proSus_genes_GOBP_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("t0 < t144 (proSus) Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(proSus_table_genes_GOBP_plot)

save_plot(
  plot = proSus_table_genes_GOBP_plot,
  filename = "Sustained_proSus_GOBP_logval_all_EMP",
  folder = output_folder
)

#KEGG
table_proSus_genes_KEGG_RUV <- table_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

proSus_table_genes_KEGG_plot <- ggplot(table_proSus_genes_KEGG_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("t0 < t144 (proSus) Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(proSus_table_genes_KEGG_plot)

save_plot(
  plot = proSus_table_genes_KEGG_plot,
  filename = "Sustained_proSus_KEGG_logval_all_EMP",
  folder = output_folder
)

```

```{r Go Analysis t0 > t144 genes recSus}
#I changed this one from filtering for sig DEGs to all
# df_sustained_full_all <- df_sustained_full
# saveRDS(df_sustained_full_all, "data/new/RUV/CMF/sustained_proportions_dataframe.RDS")

df_sustained_full_all <- readRDS("data/new/RUV/CMF/sustained_proportions_dataframe.RDS")

df_sustained_full_all <- df_sustained_full_all %>%
  mutate(
    absFC_t0   = as.numeric(absFC_t0),
    absFC_t24 = as.numeric(absFC_t24),
    absFC_t144 = as.numeric(absFC_t144)
  )

sus_check <- df_sustained_full_all %>%
  mutate(
    Category_check = case_when(
      absFC_t0 < absFC_t144 & absFC_t24 < absFC_144 ~ "proSus",
      TRUE ~ "notproSus"
    )
  )

table(sus_check$Category_check, useNA = "ifany")

sus_check %>%
  group_by(Category, Category_check) %>%
  summarise(Count = n(), .groups = "drop") %>%
  arrange(desc(Count))

recSus_genes <- df_sustained_full_all %>% 
  dplyr::filter(Category == "recSus")
  
recSus_gene_list <- dec_sus_genes$Entrez_ID

#background
# all_genes

length(recSus_gene_list)
#205 genes in this set

decsus_GOKEGG_RUV <- gost(query = dec_sus_gene_list,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          significant = TRUE,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

decsus_GOKEGG_genes_RUV <- gostplot(decsus_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
decsus_GOKEGG_genes_RUV

table_decsus_GOKEGG_genes_RUV <- decsus_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_decsus_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_decsus_genes_GOBP_RUV <- table_decsus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

decsus_table_genes_GOBP_plot <- ggplot(table_decsus_genes_GOBP_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("t144 < t0 Sustained Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(decsus_table_genes_GOBP_plot)

save_plot(
  plot = decsus_table_genes_GOBP_plot,
  filename = "Sustained_t144_less_t0_GOBP_logval_all_EMP",
  folder = output_folder
)

#KEGG
table_decsus_genes_KEGG_RUV <- table_decsus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

decsus_table_genes_KEGG_plot <- ggplot(table_decsus_genes_KEGG_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("t144 < t0 Sustained Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(decsus_table_genes_KEGG_plot)

save_plot(
  plot = decsus_table_genes_KEGG_plot,
  filename = "Sustained_t144_less_t0_KEGG_logval_all_EMP",
  folder = output_folder
)
```


##Venn Diagram for Figure OLD
```{r Venn Diagram Gene Set Overlap Motifs}
#instead of having a barplot for sustained vs recovered, make this into a venn diagram

#ids for gene sets
liu_ids <- readRDS("data/new/RUV/liu_dataset_entrez.RDS")
sapp_ids <- readRDS("data/new/RUV/sapp_dataset_entrez.RDS")
fonoudi_ids <- readRDS("data/new/RUV/fonoudi_dataset_entrez.RDS")    
#motif genes
length(final_genes_1_RUV)
length(final_genes_2_RUV)

venn_gene_list <- list(
  Fonoudi   = fonoudi_ids,
  Liu       = liu_ids,
  Sapp      = sapp_ids,
  Sustained = final_genes_2_RUV,
  Recovered = final_genes_1_RUV
)

#form this into a Venn Diagram
#this one is non proportional since with multiple overlaps it becomes tricky to make one geometrically

venn_6d_test <- ggVennDiagram(
  venn_gene_list,
  category.names = c("Fonoudi", 
                     "Liu", 
                     "Sapp", 
                     "Sustained", 
                     "Recovered")) + 
  ggtitle("DOX Cardiotoxicity Genes \n Sustained vs Recovered")+
  coord_fixed(ratio = 0.8, xlim = c(0, 1050)) +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient() +
  theme_custom()
  

print(venn_6d_test)

save_plot(
  plot = venn_6d_test,
  filename = "6D_venn_new_EMP",
  folder = output_folder,
  height = 6,
  width = 8
)

#also try an upset plot just for readability
# library(UpSetR)

#input
upset_input <- fromList(venn_gene_list)

upset_plot_motifs_genesets <- upset(upset_input,
      order.by = "freq",
      keep.order = TRUE,
      nsets = 5,
      nintersects = 40,
      mainbar.y.label = "Intersection Size",
      sets.x.label = "Set Size",
      main.bar.color = "black") 

print(upset_plot_motifs_genesets)

#I can't use my usual export because not a ggplot object

```

##Venn Diagram Sustained and Recovered
```{r Sustained Venn}
#now make one venn for sustained vs gene sets

venn_gene_sus <- list(
  Fonoudi   = fonoudi_ids,
  Liu       = liu_ids,
  Sapp      = sapp_ids,
  Sustained = final_genes_2_RUV
)

venn_6d_sus <- ggVennDiagram(
  venn_gene_sus,
  category.names = c("Fonoudi", 
                     "Liu", 
                     "Sapp", 
                     "Sustained")) + 
  ggtitle("DOX Cardiotoxicity Genes in Sustained")+
  coord_fixed(ratio = 0.8) +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient() +
  theme_custom()
  

print(venn_6d_sus)

# save_plot(
#   plot = venn_6d_sus,
#   filename = "6D_venn_sustained_EMP",
#   folder = output_folder,
#   height = 6,
#   width = 8
# )

#now make another one with just the recovered genes
venn_gene_rec <- list(
  Fonoudi   = fonoudi_ids,
  Liu       = liu_ids,
  Sapp      = sapp_ids,
  Recovered = final_genes_1_RUV
)

venn_6d_rec <- ggVennDiagram(
  venn_gene_rec,
  category.names = c("Fonoudi", 
                     "Liu", 
                     "Sapp", 
                     "Recovered")) + 
  ggtitle("DOX Cardiotoxicity Genes in Recovered")+
  coord_fixed(ratio = 0.8) +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient() +
  theme_custom()
  

print(venn_6d_rec)

# save_plot(
#   plot = venn_6d_rec,
#   filename = "6D_venn_recovered_EMP",
#   folder = output_folder,
#   height = 6,
#   width = 8
# )

#now I would like to make a venn diagram that combines the different gene sets of interest against rec and sus

cardiotox_set <- unique(c(liu_ids, sapp_ids, fonoudi_ids))
length(cardiotox_set)
#201 unique genes from these gene sets

venn_genes_combo <- list(
  Cardiotox = cardiotox_set,
  Recovered = final_genes_1_RUV,
  Sustained = final_genes_2_RUV
)

venn_6d_combine <- ggVennDiagram(
  venn_genes_combo,
  category.names = c("Cardiotox \n n = 201",
                     "Recovered \n n = 7602",
                     "Sustained \n n = 501")) + 
  ggtitle("DOX Cardiotoxicity Genes Motif Overlap")+
  # coord_fixed(ratio = 0.8) +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient() +
  theme_custom()
  

print(venn_6d_combine)


#now make this proportional since there are three sets
venn_genes_combo <- list(
  "CT" = cardiotox_set,
  "Rec" = final_genes_1_RUV,
  "Sus" = final_genes_2_RUV
)

fit_venn <- euler(venn_genes_combo)

venn_6d_combine_prop <- plot(
  fit_venn,
               edges = TRUE,
               quantities = TRUE,
               main = "Cardiotoxicity Genes Motif Overlap"
)

print(venn_6d_combine_prop)

save_plot(
  plot = venn_6d_combine_prop,
  filename = "Proportional_Venn_6d_Cardiotox_EMP",
  folder = output_folder
)

```


```{r Forest Plot of odds ratios Sus Groups}

#gene sets
inc_sus_genes   
dec_sus_genes 

# Categories
gene_categories <- list(
  FONOUDI = fonoudi_ids,
  LIU = liu_ids,
  SAPP = sapp_ids,
  DDR = ddr_set,
  DIC = AIC_set,
  P53 = p53_set
)

# Fisher's exact test for inc vs dec within sustained motif
fisher_test_inc_vs_dec <- function(category_genes, inc_genes, dec_genes) {
  a <- sum(inc_genes %in% category_genes)
  b <- length(inc_genes) - a
  c <- sum(dec_genes %in% category_genes)
  d <- length(dec_genes) - c
  
  mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
                dimnames = list(Group = c("Inc", "Dec"), Category = c("Yes", "No")))
  
  ft <- fisher.test(mat)
  
  tibble(
    OR = unname(ft$estimate),
    CI_low = ft$conf.int[1],
    CI_high = ft$conf.int[2],
    p_value = ft$p.value,
    Significant = case_when(
      ft$p.value < 0.001 ~ "***",
      ft$p.value < 0.01  ~ "**",
      ft$p.value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  )
}

# Loop through all categories
forest_summary <- map_dfr(names(gene_categories), function(cat_name) {
  res <- fisher_test_inc_vs_dec(gene_categories[[cat_name]], inc_sus_genes, dec_sus_genes)
  res %>% mutate(Category = cat_name)
})

# Order for plotting
forest_summary$Category <- factor(forest_summary$Category, levels = rev(names(gene_categories)))

# Forest plot
forest_plot <- ggplot(forest_summary, 
                      aes(y = Category, x = OR, xmin = CI_low, xmax = CI_high)) +
  geom_point(size = 4) +
  geom_errorbarh(height = 0.2, linewidth = 0.5, color = "black") +
  geom_text(aes(label = Significant), position = position_nudge(y = 0.1), 
            color = "black", fontface = "bold", size = 5) +
  geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
  scale_x_log10(limits = c(0.01, 100), breaks = c(0.01, 0.1, 1, 10, 100)) +
  labs(
    title = "Inc vs Dec Sustained Genes Odds Ratios by Gene Category",
    x = "Odds Ratio (log scale)",
    y = ""
  ) +
  theme_bw(base_size = 14)

# Plot
forest_plot

# View summary table
forest_summary


```


```{r Proportional Venn Inc (proSus) Dec (recSus) Sustained}

# Create your gene list for the Euler diagram
venn_gene_list <- list(
  CT = cardiotox_set,
  Inc_Sus = inc_sus_gene_list,  
  Dec_Sus = dec_sus_gene_list
)

# Fit Euler diagram
fit <- euler(venn_gene_list)

# Plot proportional Euler diagram
plot(fit,
     quantities = TRUE,
     labels = names(venn_gene_list),
     edges = TRUE,
     main = "Sustained Groups vs Cardiotox Genes")


#check on overlapping genes
proSus_CT_overlap <- intersect(inc_sus_gene_list, cardiotox_set)
proSus_CT_overlap
#gene overlap: 
#10721
length(proSus_CT_overlap)  #should be 1

# Overlap between proSus (Dec_Sus) and CT
recSus_CT_overlap <- intersect(dec_sus_gene_list, cardiotox_set)
recSus_CT_overlap
#overlap genes:
#8407
#129607
#30811
#1310

length(recSus_CT_overlap)  #should be 4

recSus_genes[recSus_genes %in% recSus_CT_overlap]
proSus_genes[proSus_genes %in% proSus_CT_overlap]

#now check to see if these genes overlap properly to other sets too


gene_cats_subset <- gene_cats[c("Fonoudi et al.", "Sapp et al.", "Liu et al.")]
map(gene_cats_subset, ~ intersect(recSus_CT_overlap, .x))   #overlap by category
map(gene_cats_subset, ~ intersect(proSus_CT_overlap, .x))   #overlap by category

CT_genes <- unique(c(fonoudi_ids, sapp_ids, liu_ids))
all_gene_cats <- unlist(gene_cats, use.names = FALSE)  # all forest plot categories

proSus_overlap_sustained <- intersect(proSus_genes, final_genes_2_RUV)
recSus_overlap_sustained <- intersect(recSus_genes, final_genes_2_RUV)

```

```{r Venn Diagram recSus proSus Recovered CT genes}

#combine all of my genes together into one unique set
#I'll later also add in the GWAS genes that I find from the HF GWAs

# CardTox_genes <- unique(unlist(all_cat_genes))
CT_genes <- unique(c(fonoudi_ids, sapp_ids, liu_ids)) #201 genes total
proSus_set <- unique(proSus_overlap$Entrez_ID) #27 genes
recSus_set <- unique(recSus_overlap$Entrez_ID) #37 genes

# 3. Combine into a list for plotting
venn_list_ct <- list(
  CT = CT_genes,
  proSus = proSus_set,
  recSus = recSus_set,
  Recovered = final_genes_1_RUV
)

venn_ct_all <- ggVennDiagram(
  venn_list_ct,
  category.names = c("CT", 
                     "proSus", 
                     "recSus", 
                     "Recovered")) + 
  ggtitle("DOX Cardiotoxicity Genes \n Sustained Categories vs Recovered")+
  # coord_fixed(ratio = 0.8, xlim = c(0, 1050)) +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient() +
  theme_custom()

print(venn_ct_all)

```

#HF GWAS data
```{r Read in HF GWAS data}
#I pulled data from the GWAS catalog for HF associations #https://www.ebi.ac.uk/gwas/efotraits/EFO_0003144


# hf_gwas_all <- read_delim("D:/DXR Project/GWAS/gwas-association-downloaded_2025-11-13-EFO_0003144-withChildTraits.tsv", 
#     delim = "\t", escape_double = FALSE, 
#     trim_ws = TRUE)
# View(hf_gwas_all)


# saveRDS(hf_gwas_all, "data/new/GWAS/hf_gwas_associations_EFO_0003144.RDS")

#extract mapped genes and ensure each are unique
# hf_gwas_mapped <- subset(hf_gwas_all, !is.na(MAPPED_GENE) & MAPPED_GENE != "")
#830 mapped genes, now make sure that they're unique
# hf_gwas_genes <- unique(hf_gwas_mapped$MAPPED_GENE)
#494 genes left after filtering for unique gene symbols
#now translate this into Entrez_ID for ease of analysis

#convert to Entrez_ID
# gene_conversion <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = hf_gwas_genes,
#   keytype = "SYMBOL",
#   columns = c("ENTREZID")
# )

# Remove duplicates or missing IDs
# hf_gwas_genes <- gene_conversion %>%
#   filter(!is.na(ENTREZID)) %>%
#   distinct(SYMBOL, .keep_all = TRUE)

#change the colname to Entrez_ID
# colnames(hf_gwas_genes)[colnames(hf_gwas_genes) == "ENTREZID"] <- "Entrez_ID"


# saveRDS(hf_gwas_genes, "data/new/GWAS/hf_gwas_genes_symbolentrez_mapped.RDS")

#read in the final list of genes (both SYMBOL and Entrez_ID)
hf_gwas_genes <- readRDS("data/new/GWAS/hf_gwas_genes_symbolentrez_mapped.RDS")
#make a version with just the entrez id to combine with other gene sets
#change the colname to Entrez_ID
hf_gwas_genes_list <- hf_gwas_genes$Entrez_ID

```

#Updated Analysis 11/07/25
```{r Redefine the proSus gene set}
#after looking at the log2cpm genes, we see that the patterns are not fully as expected when plotting t24 along with t0 and t144
#redefine this set to be t0 < t24 < t144

#make this set the first set of genes where t0 < t24 & t0 < t144

#combine my toptables together
#combine my toptables together
combined_toptables_dxr_RUV <- list(
  "t0"   = DOX_24T_R %>% mutate(absFC = abs(logFC)),
  "t24"  = DOX_24R_R %>% mutate(absFC = abs(logFC)),
  "t144" = DOX_144R_R %>% mutate(absFC = abs(logFC))
)

all_DEGs_dxr <- lapply(combined_toptables_dxr_RUV, function(df) {
  df %>%
    # dplyr::filter(adj.P.Val < 0.05) %>%
    mutate(absFC = abs(logFC))
})

#make a function to categorize these genes
categorize_sustained_pro <- function(gene, all_DEGs_dxr) {
  # pull DEGs at t0 and t144
  t0   <- all_DEGs_dxr[["t0"]]
  t24  <- all_DEGs_dxr[["t24"]]
  t144 <- all_DEGs_dxr[["t144"]]
  
  # absFC values if present
  absFC_t0   <- if (gene %in% t0$Entrez_ID)   
    t0 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t24  <- if (gene %in% t24$Entrez_ID) 
    t24 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t144 <- if (gene %in% t144$Entrez_ID) 
    t144 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  
  #assign categories based on absFC patterns
  if (!is.na(absFC_t0) & !is.na(absFC_t24) & !is.na(absFC_t144)) {
    if (absFC_t0 < absFC_t24 & absFC_t0 < absFC_t144) {
      return("proSus")
    } 
    }
  return(NA_character_)
}

#proSus = increasing over time t0 < t144 & t0 < t24

#make into a dataframe
proSus_df <- data.frame(
  Study = "Sustained",
  Entrez_ID = final_genes_2_RUV,
  Category = sapply(final_genes_2_RUV, 
                    categorize_sustained_pro, 
                    all_DEGs_dxr = all_DEGs_dxr),
  stringsAsFactors = FALSE
) %>%
  dplyr::filter(!is.na(Category))

#divide these out by timepoint
t0_proSus <- combined_toptables_dxr[["t0"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t0  = logFC,
    adjP_t0   = adj.P.Val,
    Sig_t0    = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t0  = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t0, absFC_t0, adjP_t0, Sig_t0)

t24_proSus <- combined_toptables_dxr[["t24"]] %>% 
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>% 
  mutate(
    logFC_t24 = logFC,
    adjP_t24 = adj.P.Val,
    Sig_t24 = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t24 = abs(logFC)
  ) %>% 
  dplyr::select(Entrez_ID, logFC_t24, absFC_t24, adjP_t24, Sig_t24)

t144_proSus <- combined_toptables_dxr[["t144"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t144 = logFC,
    adjP_t144  = adj.P.Val,
    Sig_t144   = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t144 = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t144, absFC_t144, adjP_t144, Sig_t144)

# make sure Entrez_ID types match
proSus_df$Entrez_ID <- as.integer(proSus_df$Entrez_ID)
t0_proSus$Entrez_ID <- as.integer(t0_proSus$Entrez_ID)
t24_proSus$Entrez_ID <- as.integer(t24_proSus$Entrez_ID)
t144_proSus$Entrez_ID <- as.integer(t144_proSus$Entrez_ID)

# join for full data frame
df_sustained_pro <- proSus_df %>%
  left_join(t0_proSus,   by = "Entrez_ID") %>%
  left_join(t24_proSus,  by = "Entrez_ID") %>% 
  left_join(t144_proSus, by = "Entrez_ID")

proSus_summary <- df_sustained_pro %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Proportion = Count / sum(Count),
         Percent = round(Proportion * 100, 1))


category_colors <- c(
  "proSus" = "#1f77b4"  
  # "proSus" = "#ff7f0e",  
  # "absFC_t0 = absFC_t144"          = "#d62728",  
  # "DEG_t144_only"                  = "#2ca02c"   
)

plot_proSus_summary <- ggplot(proSus_summary, aes(x = Study, y = Percent, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(Percent, 1), "\n(n = ", Count, ")")),
            position = position_stack(vjust = 0.5),
            size = 4, color = "white") +
  scale_y_continuous(limits = c(0, 102)) +
  scale_fill_manual(values = category_colors) +
  theme_custom() +
  labs(
    y = "Percentage of Sustained Genes (%)",
    x = "",
    fill = "Category"
  )

print(plot_proSus_summary)

# save_plot(
#   plot = plot_proSus_summary,
#   filename = "Sustained_Proportion_Barplot_proSus_set1_DEGs_EMP",
#   folder = output_folder
# )


```

#proSus Set 2 t0 < t24 & t0 < t144 & t24 < t144
```{r Set 2 proSus defined}

categorize_sustained_pro <- function(gene, all_DEGs_dxr) {
  # pull DEGs at t0 and t144
  t0   <- all_DEGs_dxr[["t0"]]
  t24  <- all_DEGs_dxr[["t24"]]
  t144 <- all_DEGs_dxr[["t144"]]
  
  # absFC values if present
  absFC_t0   <- if (gene %in% t0$Entrez_ID)   
    t0 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t24  <- if (gene %in% t24$Entrez_ID) 
    t24 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t144 <- if (gene %in% t144$Entrez_ID) 
    t144 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  
  #assign categories based on absFC patterns
  if (!is.na(absFC_t0) & !is.na(absFC_t24) & !is.na(absFC_t144)) {
    if (absFC_t0 < absFC_t24 & absFC_t0 < absFC_t144 & absFC_t24 < absFC_t144) {
      return("proSus")
    } 
    }
  return(NA_character_)
}

#make into a dataframe
proSus_df2 <- data.frame(
  Study = "Sustained",
  Entrez_ID = final_genes_2_RUV,
  Category = sapply(final_genes_2_RUV, 
                    categorize_sustained_pro, 
                    all_DEGs_dxr = all_DEGs_dxr),
  stringsAsFactors = FALSE
) %>%
  dplyr::filter(!is.na(Category))

#divide these out by timepoint
t0_proSus2 <- combined_toptables_dxr[["t0"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t0  = logFC,
    adjP_t0   = adj.P.Val,
    Sig_t0    = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t0  = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t0, absFC_t0, adjP_t0, Sig_t0)

t24_proSus2 <- combined_toptables_dxr[["t24"]] %>% 
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>% 
  mutate(
    logFC_t24 = logFC,
    adjP_t24 = adj.P.Val,
    Sig_t24 = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t24 = abs(logFC)
  ) %>% 
  dplyr::select(Entrez_ID, logFC_t24, absFC_t24, adjP_t24, Sig_t24)

t144_proSus2 <- combined_toptables_dxr[["t144"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t144 = logFC,
    adjP_t144  = adj.P.Val,
    Sig_t144   = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t144 = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t144, absFC_t144, adjP_t144, Sig_t144)

# make sure Entrez_ID types match
proSus_df2$Entrez_ID <- as.integer(proSus_df2$Entrez_ID)
t0_proSus2$Entrez_ID <- as.integer(t0_proSus2$Entrez_ID)
t24_proSus2$Entrez_ID <- as.integer(t24_proSus2$Entrez_ID)
t144_proSus2$Entrez_ID <- as.integer(t144_proSus2$Entrez_ID)

# join for full data frame
df_sustained_pro2 <- proSus_df2 %>%
  left_join(t0_proSus2,   by = "Entrez_ID") %>%
  left_join(t24_proSus2,  by = "Entrez_ID") %>% 
  left_join(t144_proSus2, by = "Entrez_ID")

proSus_summary2 <- df_sustained_pro2 %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Proportion = Count / sum(Count),
         Percent = round(Proportion * 100, 1))

proSus_summary2 <- df_sustained_pro2 %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Proportion = Count / sum(Count),
         Percent = round(Proportion * 100, 1))


category_colors2 <- c(
  "proSus" = "#1f77b4"  
  # "proSus" = "#ff7f0e",  
  # "absFC_t0 = absFC_t144"          = "#d62728",  
  # "DEG_t144_only"                  = "#2ca02c"   
)

plot_proSus_summary2 <- ggplot(proSus_summary2, aes(x = Study, y = Percent, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(Percent, 1), "\n(n = ", Count, ")")),
            position = position_stack(vjust = 0.5),
            size = 4, color = "white") +
  scale_y_continuous(limits = c(0, 102)) +
  scale_fill_manual(values = category_colors) +
  theme_custom() +
  labs(
    y = "Percentage of Sustained Genes (%)",
    x = "",
    fill = "Category"
  )

print(plot_proSus_summary2)

#number of genes in this definition: 

# save_plot(
#   plot = plot_proSus_summary2,
#   filename = "Sustained_Proportion_Barplot_proSus_set2_DEGs_EMP",
#   folder = output_folder
# )


```


#Venn Diagram proSus New Set 1 
```{r Make a venn diagram 4-way with new proSus}
#new proSus set = proSus_gene_list
proSus_gene_list <- proSus_df$Entrez_ID
proSus_gene_list2 <- proSus_df2$Entrez_ID
CT_genes <- unique(c(fonoudi_ids, sapp_ids, liu_ids))

proSus_new1 <- deg_wide %>%
  filter(
    Entrez_ID %in% final_genes_2_RUV,
    absFC_t0 < absFC_t24, 
    absFC_t0 < absFC_t144) %>%
  pull(Entrez_ID) %>%
  unique()

proSus_new2 <- deg_wide %>%
  filter(
    Entrez_ID %in% final_genes_2_RUV,
    absFC_t0 < absFC_t24, 
    absFC_t0 < absFC_t144, 
    absFC_t24 < absFC_t144) %>%
  pull(Entrez_ID) %>%
  unique()

length(proSus_new1) #264 genes
length(proSus_new2) #163 genes

#bring in my gene set
recSus_set <- unique(recSus_overlap$Entrez_ID)
#recovered set cluster
final_genes_1_RUV

#create a venn diagram list for 4 way venn
venn_list_ct1 <- list(
  CT = as.character(CT_genes),
  proSus = as.character(proSus_new1),
  recSus = as.character(recSus_set),
  Recovered = as.character(final_genes_1_RUV)
)

#create a venn diagram list for proSus 2 (stricter definition)
venn_list_ct2 <- list(
  CT = as.character(CT_genes),
  proSus_new = as.character(proSus_new2),
  recSus = as.character(recSus_set),
  Recovered = as.character(final_genes_1_RUV)
)

# 5. Make the 4-way Venn diagram
venn_ct1 <- ggVennDiagram(
  venn_list_ct1,
  category.names = c("CT", "proSus (set1 = 264)", "recSus", "Recovered")
) +
  ggtitle("DOX Cardiotoxicity Genes\n New proSus vs recSus vs Recovered vs CT") +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient(low = "#F9F9F9", high = "#4B9CD3") +
  theme_custom()

# 6. Print
print(venn_ct1)



venn_ct2 <- ggVennDiagram(
  venn_list_ct2,
  category.names = c("CT", "proSus (set2 = 163)", "recSus", "Rec")
) +
  ggtitle("DOX Cardiotoxicity Genes\n New proSus vs recSus vs Recovered vs CT") +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient(low = "#F9F9F9", high = "#4B9CD3") +
  theme_custom()

print(venn_ct2)




```

#log2cpm example genes
```{r log2cpm genes Set 1 proSus}

#check overlap of proSus and recSus genes with all included sets
all_cat_genes <- unique(unlist(gene_cats))
CT_genes
recSus_overlap <- recSus_genes[recSus_genes %in% all_cat_genes]
length(recSus_overlap) #42 genes overlapping
recSus_overlap
#gene ids:
#57822, 5453, 1263, 55283, 8407, 118738, 355, 10346, 272, 220001, 3014, 1111, 441631, 1017, 55332, 54331, 5228, 2242, 56963, 2232, 129607, 6382, 26154, 83959, 55959, 30811, 11200, 3976, 4071, 2261, 1310, 27445, 4897, 8794, 8797, 9134, 81704
#check the genes to make sure that t0 > t144

proSus_overlap <- proSus_genes[proSus_genes %in% all_cat_genes]
length(proSus_overlap) #27 genes overlapping
proSus_overlap
#gene ids:
#84958, 29899, 983, 64787, 5888, 9133, 9235, 1006, 672, 9518, 55355, 1869, 2177, 993, 10721, 55214, 1363, 79682, 891, 1719, 995, 3161, 1026, 55166, 51435, 10592, 60401

#make a dataframe to assess which source these different genes overlapped in

cat_genes_df <- map_dfr(names(gene_cats), function(cat) {
  tibble(
    Entrez_ID = intersect(all_cat_genes, gene_cats[[cat]]),
    Category = cat
  )
})

dim(cat_genes_df)
#1499 genes overall from all categories

#filter overlaps for proSus
proSus_overlap <- cat_genes_df %>%
  filter(Entrez_ID %in% proSus_genes)
#33 genes overlap

#filter overlaps for recSus
recSus_overlap <- cat_genes_df %>%
  filter(Entrez_ID %in% recSus_genes)
#42 genes overlap

#also sanity check that these genes are DEGs that overlap with proSus recSus
sets_for_overlap <- list(
  proSus = proSus_overlap$Entrez_ID,
  recSus = recSus_overlap$Entrez_ID,
  geneSets = unique(unlist(gene_cats))
)

deg_wide <- combined_toptables_dxr_RUV %>%
  mutate(
    Timepoint = case_when(
      Time == "24T"  ~ "t0",
      Time == "24R"  ~ "t24",
      Time == "144R" ~ "t144",
      TRUE ~ NA_character_
    ),
    absFC = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, SYMBOL, Timepoint, logFC, absFC, adj.P.Val) %>%
  filter(!is.na(SYMBOL)) %>%
  pivot_wider(
    names_from = Timepoint,
    values_from = c(logFC, absFC, adj.P.Val),
    names_sep = "_"
  ) %>%
  mutate(
    DEG_t0   = adj.P.Val_t0   < 0.05,
    DEG_t24  = adj.P.Val_t24  < 0.05,
    DEG_t144 = adj.P.Val_t144 < 0.05
  )

recSus_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% recSus_overlap$Entrez_ID)

proSus_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% proSus_overlap$Entrez_ID)

#check whether the assumptions are stil the same that the absFC is t0 < t144
#recSus
recSus_pattern <- recSus_degs %>%
  mutate(correct_pattern = absFC_t0 > absFC_t144)

#proSus
proSus_pattern <- proSus_degs %>%
  mutate(correct_pattern = absFC_t0 < absFC_t144)

recSus_summary <- recSus_pattern %>%
  summarise(
    total_genes = n(),
    n_correct = sum(correct_pattern, na.rm = TRUE),
    percent_correct = 100 * n_correct / total_genes
  )

proSus_summary <- proSus_pattern %>%
  summarise(
    total_genes = n(),
    n_correct = sum(correct_pattern, na.rm = TRUE),
    percent_correct = 100 * n_correct / total_genes
  )

recSus_summary #37 genes follow the pattern
proSus_summary #27 genes follow the pattern



#since there are fewer genes here, I believe that there are multiples of the same genes within different categories
gene_category_counts <- cat_genes_df %>%
  group_by(Entrez_ID) %>%
  summarise(n_categories = n_distinct(Category),
            categories = paste(unique(Category), collapse = ", "),
            .groups = "drop") %>%
  arrange(desc(n_categories))

#pull genes that are in more than one category
shared_genes <- gene_category_counts %>%
  filter(n_categories > 1)

#view the genes that are shared across categories for curiosity
shared_genes
#160 genes are shared across at least two categories 
#(predominantly the eQTLs and reQTLs with 103 shared genes)


#find gene symbols
proSus_overlap <- proSus_overlap %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

recSus_overlap <- recSus_overlap %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

#now plot these example genes for each

#first change colnames pf my expression dataframe to match factors
boxplot_new <- boxplot1

expr_cols <- setdiff(colnames(boxplot_new), c("Entrez_ID", "SYMBOL"))

rename_cond <- function(colnames_vec) {
  colnames_vec <- gsub("DMSO", "VEH", colnames_vec)       # DMSO -> VEH
  colnames_vec <- gsub("_24T_", "_t0_", colnames_vec)     # 24T -> t0
  colnames_vec <- gsub("_24R_", "_t24_", colnames_vec)    # 24R -> t24
  colnames_vec <- gsub("_144R_", "_t144_", colnames_vec)  # 144R -> t144
  colnames_vec <- gsub("Ind6REP", "6R", colnames_vec)     # Ind6REP -> 6R
  colnames_vec <- gsub("Ind", "", colnames_vec)           
  return(colnames_vec)
}

new_expr_cols <- rename_cond(expr_cols)
colnames(boxplot_new)[match(expr_cols, colnames(boxplot_new))] <- new_expr_cols

#process the cpm data
process_cpm_data_cormotif <- function(gene_id, expr_df) {
  gene_data <- expr_df %>% filter(Entrez_ID == gene_id)
  
  long_data <- gene_data %>%
    pivot_longer(
      cols = -c(Entrez_ID, SYMBOL),
      names_to = "Sample",
      values_to = "log2CPM"
    ) %>%
    mutate(
      Treatment = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("VEH", Sample) ~ "VEH",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("t0", Sample) ~ "t0",
        grepl("t24", Sample) ~ "t24",
        grepl("t144", Sample) ~ "t144",
        TRUE ~ NA_character_
      ),
      Individual = case_when(
        grepl("1$", Sample) ~ "1",
        grepl("2$", Sample) ~ "2",
        grepl("3$", Sample) ~ "3",
        grepl("4$", Sample) ~ "4",
        grepl("5$", Sample) ~ "5",
        grepl("6$", Sample) ~ "6",
        grepl("6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Treatment, Timepoint, sep = "_")
    )
  
  # Set factor levels for plotting order
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c("DOX_t0", "VEH_t0", 
               "DOX_t24", "VEH_t24", 
               "DOX_t144", "VEH_t144")
  )
  
  return(long_data)
}

# Function to generate plots for a set of genes
generate_overlap_plots_cormotif <- function(overlap_df, expr_df, comparison_label) {
  plots <- list()
  
  for (gene_id in overlap_df$Entrez_ID) {
    gene_data <- process_cpm_data_cormotif(gene_id, expr_df)
    
    # Get SYMBOL and all categories
    gene_symbol <- unique(gene_data$SYMBOL)
    gene_categories <- overlap_df$Category[overlap_df$Entrez_ID == gene_id]
    gene_categories <- paste(unique(gene_categories), collapse = ", ")
    
    p <- ggplot(gene_data, aes(x = Condition, 
                               y = log2CPM,
                               fill = Condition)) +
      geom_boxplot(outlier.shape = NA) +
      geom_point(aes(color = Individual), size = 2, 
                 alpha = 0.9,
                 position = position_identity()) +
      scale_fill_manual(values = txtime_col) +
      scale_color_manual(values = ind_col) +
      ggtitle(paste0(gene_symbol,
                     " (", comparison_label, " in ", gene_categories, ") ")) +
      labs(x = "Condition", y = "log2cpm") +
      theme_custom()
    
    # Use Entrez_ID + SYMBOL + comparison label for the list name to guarantee uniqueness
    plot_name <- paste0(gene_symbol, "_", gene_id, "_", comparison_label)
    plots[[plot_name]] <- p
  }
  
  return(plots)
}

#generate plots for both
proSus_plots <- generate_overlap_plots_cormotif(proSus_overlap, boxplot_new, "proSus")
recSus_plots <- generate_overlap_plots_cormotif(recSus_overlap, boxplot_new, "recSus")

#preview all plots
for (p in c(proSus_plots, recSus_plots)) print(p)

#save all of these plots with unique names
for (plot_name in names(proSus_plots)) {
  save_plot(proSus_plots[[plot_name]], 
            filename = paste0("ExGene_", plot_name, "_EMP"), 
            folder = output_folder)
}

for (plot_name in names(recSus_plots)) {
  save_plot(recSus_plots[[plot_name]], 
            filename = paste0("ExGene_", plot_name, "_EMP"), 
            folder = output_folder)
}

```

```{r log2cpm example genes proSus sets}

#ensure your new proSus definitions exist
#set 1 = t0 < t24 & t0 < t144
#set 2 = t0 < t24 & t0 < t144 & t24 < t144

#read in the previous sets that I defined
# proSus_new1 <- deg_wide %>%
#   filter(
#     Entrez_ID %in% final_genes_2_RUV,
#     absFC_t0 < absFC_t24, 
#     absFC_t0 < absFC_t144) %>%
#   pull(Entrez_ID) %>%
#   unique()
# 
# proSus_new2 <- deg_wide %>%
#   filter(
#     Entrez_ID %in% final_genes_2_RUV,
#     absFC_t0 < absFC_t24, 
#     absFC_t0 < absFC_t144, 
#     absFC_t24 < absFC_t144) %>%
#   pull(Entrez_ID) %>%
#   unique()

length(proSus_new1) #264 genes
length(proSus_new2) #163 genes

#modify these for log2cpm expression data
proSus_new1_expr <- boxplot_new %>%
  filter(Entrez_ID %in% proSus_new1)

proSus_new2_expr <- boxplot_new %>%
  filter(Entrez_ID %in% proSus_new2)

recSus_expr <- boxplot_new %>%
  filter(Entrez_ID %in% recSus_genes)

#convert Entrez_ID to numeric
proSus_df1$Entrez_ID <- as.numeric(proSus_df1$Entrez_ID)
proSus_df2$Entrez_ID <- as.numeric(proSus_df2$Entrez_ID)

#intersect with all annotated categories
proSus_overlap_df1 <- cat_genes_df %>%
  filter(Entrez_ID %in% proSus_new1_expr)

proSus_overlap_df2 <- cat_genes_df %>%
  filter(Entrez_ID %in% proSus_df2$Entrez_ID)

proSus_degs_df1 <- deg_wide %>% 
  filter(Entrez_ID %in% proSus_overlap_df1$Entrez_ID)

proSus_degs_df2 <- deg_wide %>% 
  filter(Entrez_ID %in% proSus_overlap_df2$Entrez_ID)

#check pattern: t0 < t144 and t0 < t24 vs set2 stricter
proSus_df1_pattern <- proSus_degs_df1 %>%
  mutate(correct_pattern = absFC_t0 < absFC_t144 & absFC_t0 < absFC_t24)

proSus_df2_pattern <- proSus_degs_df2 %>%
  mutate(correct_pattern = absFC_t0 < absFC_t144 & absFC_t0 < absFC_t24 & absFC_t24 < absFC_t144)

# Summaries
proSus_df1_summary <- proSus_df1_pattern %>%
  summarise(
    total_genes = n(),
    n_correct = sum(correct_pattern, na.rm = TRUE),
    percent_correct = 100 * n_correct / total_genes
  )

proSus_df2_summary <- proSus_df2_pattern %>%
  summarise(
    total_genes = n(),
    n_correct = sum(correct_pattern, na.rm = TRUE),
    percent_correct = 100 * n_correct / total_genes
  )

proSus_df1_summary
proSus_df2_summary

#now plot these
proSus_df1_plots <- generate_overlap_plots_cormotif(proSus_df1_pattern, boxplot_new, "proSus_df1")

proSus_df2_plots <- generate_overlap_plots_cormotif(proSus_df2_pattern, boxplot_new, "proSus_df2")


for (plot_name in names(proSus_df1_plots)) {
  save_plot(proSus_df1_plots[[plot_name]], 
            filename = paste0("ExGene_", plot_name, "_proSus_df1_EMP"), 
            folder = output_folder)
}

for (plot_name in names(proSus_df2_plots)) {
  save_plot(proSus_df2_plots[[plot_name]], 
            filename = paste0("ExGene_", plot_name, "_proSus_df2_EMP"), 
            folder = output_folder)
}

venn_list_proSus <- list(
  proSus_df1 = as.character(proSus_overlap_df1$Entrez_ID),
  proSus_df2 = as.character(proSus_overlap_df2$Entrez_ID),
  recSus = as.character(recSus_overlap$Entrez_ID),
  Recovered = as.character(final_genes_1_RUV),
  CT = as.character(CT_genes)
)

venn_proSus_compare <- ggVennDiagram(
  venn_list_proSus,
  category.names = c("proSus_df1", "proSus_df2", "recSus", "Recovered", "CT")
) +
  ggtitle("DOX Cardiotoxicity Genes\nComparing new proSus definitions vs recSus & CT") +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient(low = "#F9F9F9", high = "#4B9CD3") +
  theme_custom()

print(venn_proSus_compare)



```

#Updated Analysis 11/10/25
#PROSUS FIN
```{r New proSus set definitions}
#I am going to finalize my definitions of proSus
#proSus = Sustained genes that are t0 < t24 & t24 < t144
#not_proSus = all other Sustained genes - proSus genes

#total of 501 Sustained genes, make a gene set of this new definition

#combine my toptables together
combined_toptables_RUV_dxr <- list(
  "t0"   = DOX_24T_R %>% mutate(absFC = abs(logFC)),
  "t24"  = DOX_24R_R %>% mutate(absFC = abs(logFC)),
  "t144" = DOX_144R_R %>% mutate(absFC = abs(logFC))
)

#don't filter for DEGs, not applicable here
all_genes_dxr <- lapply(combined_toptables_RUV_dxr, function(df) {
  df %>%
    mutate(absFC = abs(logFC))
})

#make a function to categorize these genes
categorize_sustained_proSus <- function(gene, all_genes_dxr) {
  #pull genes at t0 t24 t144
  t0   <- all_genes_dxr[["t0"]]
  t24  <- all_genes_dxr[["t24"]]
  t144 <- all_genes_dxr[["t144"]]
  
  # absFC values if present
  absFC_t0   <- if (gene %in% t0$Entrez_ID)   
    t0 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t24  <- if (gene %in% t24$Entrez_ID) 
    t24 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  absFC_t144 <- if (gene %in% t144$Entrez_ID) 
    t144 %>% 
    filter(Entrez_ID == gene) %>% 
    pull(absFC) else NA_real_
  
  #assign categories based on absFC patterns
  if (!is.na(absFC_t0) & !is.na(absFC_t24) & !is.na(absFC_t144)) {
    if (absFC_t0 < absFC_t24 & absFC_t24 < absFC_t144) {
      return("proSus")
    } else {
      return("notproSus")
    }
  } else {
    return(NA_character_)
  }
}

#proSus = increasing over time t0 < t144 & t24 < t144
#notproSus = all other genes

#make into a dataframe
proSus_fin_df <- data.frame(
  Study = "Sustained",
  Entrez_ID = final_genes_2_RUV,
  Category = sapply(final_genes_2_RUV, 
                    categorize_sustained_proSus, 
                    all_genes_dxr = all_genes_dxr),
  stringsAsFactors = FALSE
) %>%
  dplyr::filter(!is.na(Category))

#divide these out by timepoint
t0_proSus <- combined_toptables_dxr_RUV[["t0"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t0  = logFC,
    adjP_t0   = adj.P.Val,
    Sig_t0    = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t0  = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t0, absFC_t0, adjP_t0, Sig_t0)

t24_proSus <- combined_toptables_dxr_RUV[["t24"]] %>% 
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>% 
  mutate(
    logFC_t24 = logFC,
    adjP_t24 = adj.P.Val,
    Sig_t24 = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t24 = abs(logFC)
  ) %>% 
  dplyr::select(Entrez_ID, logFC_t24, absFC_t24, adjP_t24, Sig_t24)

t144_proSus <- combined_toptables_dxr_RUV[["t144"]] %>%
  dplyr::select(Entrez_ID, logFC, adj.P.Val) %>%
  mutate(
    logFC_t144 = logFC,
    adjP_t144  = adj.P.Val,
    Sig_t144   = ifelse(adj.P.Val < 0.05, "DE", "nonDE"),
    absFC_t144 = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, logFC_t144, absFC_t144, adjP_t144, Sig_t144)

# make sure Entrez_ID types match
proSus_fin_df$Entrez_ID <- as.integer(proSus_fin_df$Entrez_ID)
t0_proSus$Entrez_ID <- as.integer(t0_proSus$Entrez_ID)
t24_proSus$Entrez_ID <- as.integer(t24_proSus$Entrez_ID)
t144_proSus$Entrez_ID <- as.integer(t144_proSus$Entrez_ID)

# join for full data frame
df_sustained_proSus <- proSus_fin_df %>%
  left_join(t0_proSus,   by = "Entrez_ID") %>%
  left_join(t24_proSus,  by = "Entrez_ID") %>% 
  left_join(t144_proSus, by = "Entrez_ID")

#save this new dataframe for later analysis
# saveRDS(df_sustained_proSus, "data/new/RUV/CMF/Sustained_proSus_dataframe.RDS")

####this is the dataframe you want from now on####
# proSus_df <- readRDS("data/new/RUV/CMF/Sustained_proSus_dataframe.RDS")

#now convert to have SYMBOL in the dataframe
# proSus_df <- readRDS("data/new/RUV/CMF/Sustained_proSus_dataframe.RDS")
# proSus_df <- as.data.frame(proSus_df) 
# proSus_df$Entrez_ID <- as.character(proSus_df$Entrez_ID)

#I used the absFC to determine whether they were proSus
#ie absFC t0 < t24 & t24 < t144 = proSus
#all others are notproSus (of the 501 Sustained genes)

#add in HGNC symbols
#now convert these to have a symbol column

# symbol_map <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = as.character(proSus_df$Entrez_ID),
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )

#remove any duplicates if any
# symbol_map <- symbol_map[!duplicated(symbol_map$ENTREZID), ]

#merge into your df
# proSus_df <- proSus_df %>%
  # left_join(symbol_map, by = c("Entrez_ID" = "ENTREZID"))

#reorder columns so Entrez_ID and SYMBOL are together
# proSus_df <- proSus_df %>%
#   dplyr::select(
#     colnames(proSus_df)[1:2],  
#     SYMBOL,                    
#     everything()               
#   )

#save a final version of this dataframe
# saveRDS(proSus_df, "data/new/RUV/CMF/Sustained_proSus_dataframe_symbolentrez.RDS")

proSus_df <- readRDS("data/new/RUV/CMF/Sustained_proSus_dataframe_symbolentrez.RDS")
```


#barchart of Sustained genes
```{r Make a barplot of all sustained genes}
#now that I've found the 163 genes fitting my definition for proSus, let's pull out the genes that do not fit that description from the Sustained group
#501 sustained genes total
#163 proSus genes
#rest = notproSus (338 genes)

proSus_fin_summary <- proSus_df %>%
  group_by(Study, Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  mutate(Proportion = Count / sum(Count),
         Percent = round(Proportion * 100, 1))

category_colors <- c(
  "proSus" = "#1f77b4",  
  "notproSus" = "#ff7f9e"  
)

plot_proSus_fin_summary <- ggplot(proSus_fin_summary, aes(x = Study, y = Percent, fill = Category)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(Percent, 1), "\n(n = ", Count, ")")),
            position = position_stack(vjust = 0.5),
            size = 4, color = "white") +
  scale_y_continuous(limits = c(0, 102),
                     expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_manual(values = category_colors) +
  theme_custom() +
  labs(
    y = "Percentage of Sustained Genes (%)",
    x = "",
    fill = "Category"
  )

print(plot_proSus_fin_summary)
#163 genes total

# save_plot(
#   plot = plot_proSus_fin_summary,
#   filename = "Sustained_Proportion_Barplot_proSus_finalset_DEGs_EMP",
#   folder = output_folder,
#   height = 4,
#   width = 5
# )


```

#make gene set
```{r create a df with my proSus and notproSus gene sets}

#read in my final dataframe with all of the info for proSus and notproSus genes
proSus_df <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/CMF/Sustained_proSus_dataframe_symbolentrez.RDS")

#ensure numeric absFC values
proSus_df_all <- proSus_df %>%
  mutate(
    absFC_t0   = as.numeric(absFC_t0),
    absFC_t24  = as.numeric(absFC_t24),
    absFC_t144 = as.numeric(absFC_t144)
  )

proSus_df_all <- proSus_df_all %>%
  mutate(
    Category_final = case_when(
      absFC_t0 < absFC_t24 & absFC_t24 < absFC_t144 ~ "proSus",
      !is.na(absFC_t0) & !is.na(absFC_t24) & !is.na(absFC_t144) ~ "notproSus",
      TRUE ~ NA_character_  #keep genes missing any FC as NA
    )
  )

#check the counts to make sure all is accurate
table(proSus_df_all$Category_final, useNA = "ifany")
#338 notproSus and 163 proSus - good

#make my final proSus gene list
proSus_gene_list <- proSus_df_all %>%
  filter(Category_final == "proSus") %>%
  pull(Entrez_ID) %>%
  unique()

#make my final notproSus gene list
notproSus_gene_list <- proSus_df_all %>% 
  filter(Category_final == "notproSus") %>% 
  pull(Entrez_ID) %>% 
  unique()

length(proSus_gene_list)
length(notproSus_gene_list)

#save these as objects for easy access
# saveRDS(proSus_gene_list, "data/new/RUV/CMF/proSus_gene_list.RDS")
# saveRDS(notproSus_gene_list, "data/new/RUV/CMF/notproSus_gene_list.RDS")

 
```


#GO/KEGG proSus genes
```{r GO analysis of proSus gene set}
#Of the previous data, I am interested in the genes from our sustained motif that are increasingly different over time 
#(progressing Sustained or proSus) 
#this would be the 163 genes where t0 < t144 & t24 < t144 - named proSus

#read in my sustained dataframe from above
proSus_gene_list <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/CMF/proSus_gene_list.RDS")
notproSus_gene_list <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/CMF/notproSus_gene_list.RDS")

#background
# all_genes

length(proSus_gene_list)
#163 - don't filter for DEGs

proSus_GOKEGG_RUV <- gost(query = proSus_gene_list,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = TRUE,
                          user_threshold = 0.05,
                          significant = TRUE,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

proSus_GOKEGG_genes_RUV <- gostplot(proSus_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
proSus_GOKEGG_genes_RUV

table_proSus_GOKEGG_genes_RUV <- proSus_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_proSus_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_proSus_genes_GOBP_RUV <- table_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

proSus_table_genes_GOBP_plot <- ggplot(table_proSus_genes_GOBP_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("proSus Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(proSus_table_genes_GOBP_plot)

# save_plot(
#   plot = proSus_table_genes_GOBP_plot,
#   filename = "Sustained_proSus_GOBP_logval_all_EMP",
#   folder = output_folder
# )

#KEGG
table_proSus_genes_KEGG_RUV <- table_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

proSus_table_genes_KEGG_plot <- ggplot(table_proSus_genes_KEGG_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("proSus Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(proSus_table_genes_KEGG_plot)

# save_plot(
#   plot = proSus_table_genes_KEGG_plot,
#   filename = "Sustained_proSus_KEGG_logval_all_EMP",
#   folder = output_folder
# )


#now do the same for notproSus genes

notproSus_GOKEGG_RUV <- gost(query = notproSus_gene_list,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = TRUE,
                          user_threshold = 0.05,
                          significant = TRUE,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

notproSus_GOKEGG_genes_RUV <- gostplot(notproSus_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
notproSus_GOKEGG_genes_RUV

table_notproSus_GOKEGG_genes_RUV <- notproSus_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_notproSus_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_notproSus_genes_GOBP_RUV <- table_notproSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))


notproSus_table_genes_GOBP_plot <- ggplot(table_notproSus_genes_GOBP_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("notproSus Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(notproSus_table_genes_GOBP_plot)

# save_plot(
#   plot = notproSus_table_genes_GOBP_plot,
#   filename = "Sustained_notproSus_GOBP_logval_all_EMP",
#   folder = output_folder
# )

#KEGG
table_notproSus_genes_KEGG_RUV <- table_notproSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

notproSus_table_genes_KEGG_plot <- ggplot(table_notproSus_genes_KEGG_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("notproSus Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(notproSus_table_genes_KEGG_plot)

# save_plot(
#   plot = notproSus_table_genes_KEGG_plot,
#   filename = "Sustained_notproSus_KEGG_logval_all_EMP",
#   folder = output_folder
# )

```


#proSus vs notproSus venn diagrams
```{r Venn Diagram proSus notproSus CT Recovered}
#now compare the overlap of these genes with my CT genes from other studies

CT_genes 
proSus_gene_list
notproSus_gene_list
final_genes_1_RUV

venn_proSus_list <- list(
  CT = as.character(CT_genes),
  Recovered = as.character(final_genes_1_RUV),
  proSus = as.character(proSus_gene_list),
  notproSus = as.character(notproSus_gene_list)
)


venn_proSus <- ggVennDiagram(
  venn_proSus_list,
  category.names = c("CT \n (n = 201)", 
                     "Recovered \n (n = 7602)", 
                     "proSus \n (n = 163)", 
                     "notproSus \n (n = 338)")
) +
  ggtitle("DOX Cardiotoxicity Genes\n proSus vs notproSus vs Recovered vs CT") +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient(low = "#F9F9F9", high = "#4B9CD3") +
  theme_custom()


print(venn_proSus)

```

#log2cpm example gene
```{r Example genes log2cpm for proSus}
#proSus_gene_list
#CT_genes

#there are 5 total genes to investigate based on the Venn diagram of overlap with CT genes
#1 overlap with proSus
#4 overlap with notproSus

intersect(proSus_gene_list, CT_genes)
proSus_overlap <- proSus_gene_list[proSus_gene_list %in% CT_genes]
#these give the same results
#10721 Entrez_ID = 

intersect(notproSus_gene_list, CT_genes)
notproSus_overlap <- notproSus_gene_list[notproSus_gene_list %in% CT_genes]
#these give the same results
#8407, 129607, 30811, 1310 Entrez_ID =
#8407 = 
#129607 = 

CT_cats <- list( 
  "Fonoudi et al." = fonoudi_ids,
  "Liu et al." = liu_ids,
  "Sapp et al." = sapp_ids
)

ddr_p53_dic_cats <- list( 
  "DNA Damage Response Genes" = unique(na.omit(DNA_damage_genes)),
  "p53 Target Genes" = unique(na.omit(p53_target_genes)),
  "DOX Cardiotoxicity Genes" = unique(na.omit(AIC_genes))
)

#pull the gene symbol so I can plot log2cpm data
ct_genes_df <- map_dfr(names(CT_cats), function(cat) {
  tibble(
    Entrez_ID = intersect(CT_genes, CT_cats[[cat]]),
    Category = cat
  )
})

dim(ct_genes_df)
#202 genes overall from all categories

#filter overlaps for proSus
proSus_overlap <- ct_genes_df %>%
  filter(Entrez_ID %in% proSus_gene_list)
#1 gene - from Sapp et al

#filter overlaps for recSus
notproSus_overlap <- ct_genes_df %>%
  filter(Entrez_ID %in% notproSus_gene_list)
#4 genes - from Sapp et al

#also sanity check that these genes are DEGs that overlap with proSus recSus
set_for_overlap <- list(
  proSus = proSus_overlap$Entrez_ID,
  notproSus = notproSus_overlap$Entrez_ID,
  geneSets = unique(unlist(CT_genes))
)

deg_wide <- combined_toptables_dxr_RUV %>%
  mutate(
    Timepoint = case_when(
      Time == "24T"  ~ "t0",
      Time == "24R"  ~ "t24",
      Time == "144R" ~ "t144",
      TRUE ~ NA_character_
    ),
    absFC = abs(logFC)
  ) %>%
  dplyr::select(Entrez_ID, SYMBOL, Timepoint, logFC, absFC, adj.P.Val) %>%
  filter(!is.na(SYMBOL)) %>%
  pivot_wider(
    names_from = Timepoint,
    values_from = c(logFC, absFC, adj.P.Val),
    names_sep = "_"
  ) %>%
  mutate(
    DEG_t0   = adj.P.Val_t0   < 0.05,
    DEG_t24  = adj.P.Val_t24  < 0.05,
    DEG_t144 = adj.P.Val_t144 < 0.05
  )

proSus_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% proSus_overlap$Entrez_ID)

notproSus_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% notproSus_overlap$Entrez_ID)

#check whether the assumptions are stil the same that the absFC is t0 < t144

#proSus
proSus_pattern <- proSus_degs %>%
  mutate(correct_pattern = absFC_t0 < absFC_t24 & absFC_t24 < absFC_t144)

proSus_summary <- proSus_pattern %>%
  summarise(
    total_genes = n(),
    n_correct = sum(correct_pattern, na.rm = TRUE),
    percent_correct = 100 * n_correct / total_genes
  )

proSus_summary 

#find gene symbols
proSus_overlap <- proSus_overlap %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

notproSus_overlap <- notproSus_overlap %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

#now plot these example genes for each

#first change colnames pf my expression dataframe to match factors
# boxplot_new <- boxplot1

# expr_cols <- setdiff(colnames(boxplot_new), c("Entrez_ID", "SYMBOL"))
# 
# rename_cond <- function(colnames_vec) {
#   colnames_vec <- gsub("DMSO", "VEH", colnames_vec)       # DMSO -> VEH
#   colnames_vec <- gsub("_24T_", "_t0_", colnames_vec)     # 24T -> t0
#   colnames_vec <- gsub("_24R_", "_t24_", colnames_vec)    # 24R -> t24
#   colnames_vec <- gsub("_144R_", "_t144_", colnames_vec)  # 144R -> t144
#   colnames_vec <- gsub("Ind6REP", "6R", colnames_vec)     # Ind6REP -> 6R
#   colnames_vec <- gsub("Ind", "", colnames_vec)
#   return(colnames_vec)
# }
# 
# new_expr_cols <- rename_cond(expr_cols)
# colnames(boxplot_new)[match(expr_cols, colnames(boxplot_new))] <- new_expr_cols

# saveRDS(boxplot_new, "data/new/RUV/CMF/log2cpm_boxplotdata_updated.RDS")

boxplot_new <- readRDS("data/new/RUV/CMF/log2cpm_boxplotdata_updated.RDS")

#process the cpm data
process_cpm_data_cormotif <- function(gene_id, expr_df) {
  gene_data <- expr_df %>% filter(Entrez_ID == gene_id)
  
  long_data <- gene_data %>%
    pivot_longer(
      cols = -c(Entrez_ID, SYMBOL),
      names_to = "Sample",
      values_to = "log2CPM"
    ) %>%
    mutate(
      Treatment = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("VEH", Sample) ~ "VEH",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("t0", Sample) ~ "t0",
        grepl("t24", Sample) ~ "t24",
        grepl("t144", Sample) ~ "t144",
        TRUE ~ NA_character_
      ),
      Individual = case_when(
        grepl("1$", Sample) ~ "1",
        grepl("2$", Sample) ~ "2",
        grepl("3$", Sample) ~ "3",
        grepl("4$", Sample) ~ "4",
        grepl("5$", Sample) ~ "5",
        grepl("6$", Sample) ~ "6",
        grepl("6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Treatment, Timepoint, sep = "_")
    )
  
  # Set factor levels for plotting order
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c("DOX_t0", "VEH_t0", 
               "DOX_t24", "VEH_t24", 
               "DOX_t144", "VEH_t144")
  )
  
  return(long_data)
}

# Function to generate plots for a set of genes
generate_overlap_plots_cormotif <- function(overlap_df, expr_df, comparison_label) {
  plots <- list()
  
  for (gene_id in overlap_df$Entrez_ID) {
    gene_data <- process_cpm_data_cormotif(gene_id, expr_df)
    
    # Get SYMBOL and all categories
    gene_symbol <- unique(gene_data$SYMBOL)
    gene_categories <- overlap_df$Category[overlap_df$Entrez_ID == gene_id]
    gene_categories <- paste(unique(gene_categories), collapse = ", ")
    
    p <- ggplot(gene_data, aes(x = Condition, 
                               y = log2CPM,
                               fill = Condition)) +
      geom_boxplot(outlier.shape = NA) +
      geom_point(aes(color = Individual), size = 2, 
                 alpha = 0.9,
                 position = position_identity()) +
      scale_fill_manual(values = txtime_col) +
      scale_color_manual(values = ind_col) +
      ggtitle(paste0(gene_symbol,
                     " (", comparison_label, " in ", gene_categories, ") ")) +
      labs(x = "Condition", y = "log2cpm") +
      theme_custom()
    
    # Use Entrez_ID + SYMBOL + comparison label for the list name to guarantee uniqueness
    plot_name <- paste0(gene_symbol, "_", gene_id, "_", comparison_label)
    plots[[plot_name]] <- p
  }
  
  return(plots)
}

#generate plots for both
proSus_plots <- generate_overlap_plots_cormotif(proSus_overlap, boxplot_new, "proSus")
notproSus_plots <- generate_overlap_plots_cormotif(notproSus_overlap, boxplot_new, "notproSus")

#preview all plots
for (p in c(proSus_plots, notproSus_plots)) print(p)

#save all of these plots with unique names
# for (plot_name in names(proSus_plots)) {
#   save_plot(proSus_plots[[plot_name]],
#             filename = paste0("ExGene_proSus_", plot_name, "_EMP"),
#             folder = output_folder)
# }
# 
# for (plot_name in names(notproSus_plots)) {
#   save_plot(notproSus_plots[[plot_name]],
#             filename = paste0("ExGene_notproSus_", plot_name, "_EMP"),
#             folder = output_folder)
# }


```


#logFC line plots proSus vs notproSus
```{r logFC line plots proSus vs notproSus genes}

proSus_gene_list
notproSus_gene_list

#simplify the line plot
proSus_df_all

#create a toptable with all of the genes for proSus
filt_toptable_proSus_RUV <- combined_toptables_dxr_RUV_df %>% 
  mutate(proSus = case_when(
    Entrez_ID %in% proSus_gene_list ~ "proSus",
    TRUE ~ NA_character_
  )) %>% 
  dplyr::filter(!is.na(SYMBOL)) %>% 
  dplyr::filter(!is.na(proSus)) %>% 
  mutate(Time = factor(Time, 
                       levels = c("t0",
                                  "t24",
                                  "t144"))) %>% 
  mutate(absFC = abs(logFC))
#this should contain 163 unique genes across timepoints

#calculate medians for ALL proSus genes across timepoints
medians_proSus_RUV <- filt_toptable_proSus_RUV %>%
  group_by(Time) %>%
  summarise(
    median_logFC = median(logFC),
    median_abslogFC = median(absFC),
    .groups = "drop"
  )

#label with median values
labs_logFC_proSus <- paste0(
  "proSus\nmedian logFC =\n",
  paste0(medians_proSus_RUV$Time, "=", round(medians_proSus_RUV$median_logFC, 2), collapse = "\n")
)

labs_absFC_proSus <- paste0(
  "proSus\nmedian abslogFC =\n",
  paste0(medians_proSus_RUV$Time, "=", round(medians_proSus_RUV$median_abslogFC, 2), collapse = "\n")
)


# #sdd a column that labels positive/negative direction
filt_toptable_proSus_RUV <- filt_toptable_proSus_RUV %>%
  mutate(direction = ifelse(logFC >= 0, "up", "down"))

#label direction
medians_proSus_RUV <- medians_proSus_RUV %>%
  mutate(direction = "median")


#make a logFC version
plot_proSus_logFC <- ggplot() +
  geom_line(data = filt_toptable_proSus_RUV,
            aes(x = Time, 
                y = logFC, 
                group = Entrez_ID),
            color = "#A06FA8",
            alpha = 0.4, 
            linewidth = 0.9) +
  geom_line(data = medians_proSus_RUV,
            aes(x = Time, 
                y = median_logFC, 
                group = 1,
                color = direction),
            linewidth = 3
            ) +
  scale_color_manual(
    breaks = c("median"), 
    values = c("median" = "#7B4F82"),
    labels = c(
      median = labs_logFC_proSus),
    name = NULL
    ) +
  labs(title = "logFC  proChron Genes (n = 163)",
       y = "logFC", x = "Timepoint") +
  scale_y_continuous(breaks = c(-10, -5, 0, 5, 10), 
                     limits = c(-10, 10),
                     expand = c(0,0)) +
  scale_x_discrete(breaks = c("t0", "t24", "t144"),
                     expand = c(0, 0)) +
  theme_custom() +
  theme(legend.position = "right")

#now an absFC version
plot_proSus_absFC <- ggplot() +
  geom_line(data = filt_toptable_proSus_RUV,
            aes(x = Time, 
                y = absFC, 
                group = Entrez_ID),
            color = "orchid",
            alpha = 0.4, 
            linewidth = 0.9) +
  geom_line(data = medians_proSus_RUV,
            aes(x = Time, 
                y = median_abslogFC, 
                group = 1,
                color = direction),
            linewidth = 3
            ) +
  scale_color_manual(
    breaks = c("median"), 
    values = c("median" = "#3D6680"),
    labels = c(
      median = labs_absFC_proSus),
    name = NULL
    ) +
  labs(title = "abs logFC  proSus Genes (n = 163)",
       y = "absFC", x = "Timepoint") +
  scale_y_continuous(expand = c(0,0),
                     limits = c(0, 10)) +
  scale_x_discrete(breaks = c("t0", "t24", "t144"),
                     expand = c(0, 0)) +
  theme_custom() +
  theme(legend.position = "right")

print(plot_proSus_logFC)
print(plot_proSus_absFC)

#find how many genes are up and how many are down
proSus_directionality <- filt_toptable_proSus_RUV %>%
  group_by(Time, direction) %>%
  summarise(n = n(), .groups = "drop")

#now make it so that it only counts those that are increasingly negative or increasingly positive across time

filt_toptable_notproSus_RUV <- combined_toptables_dxr_RUV_df %>% 
  mutate(notproSus = case_when(
    Entrez_ID %in% notproSus_gene_list ~ "notproSus",
    TRUE ~ NA_character_
  )) %>% 
  dplyr::filter(!is.na(SYMBOL)) %>% 
  dplyr::filter(!is.na(notproSus)) %>% 
  mutate(Time = factor(Time, 
                       levels = c("t0",
                                  "t24",
                                  "t144"))) %>% 
  mutate(absFC = abs(logFC))
#this should contain 163 unique genes across timepoints

#calculate medians for ALL proSus genes across timepoints
medians_notproSus_RUV <- filt_toptable_notproSus_RUV %>%
  group_by(Time) %>%
  summarise(
    median_logFC = median(logFC),
    median_abslogFC = median(absFC),
    .groups = "drop"
  )

#label with median values
labs_logFC_notproSus <- paste0(
  "notproSus\nmedian logFC =\n",
  paste0(medians_notproSus_RUV$Time, "=", round(medians_notproSus_RUV$median_logFC, 2), collapse = "\n")
)

labs_absFC_notproSus <- paste0(
  "notproSus\nmedian absFC =\n",
  paste0(medians_notproSus_RUV$Time, "=", round(medians_notproSus_RUV$median_abslogFC, 2), collapse = "\n")
)

#add a column that labels positive/negative direction
filt_toptable_notproSus_RUV <- filt_toptable_notproSus_RUV %>%
  mutate(direction = ifelse(logFC >= 0, "up", "down"))

#label direction
medians_notproSus_RUV <- medians_notproSus_RUV %>%
  mutate(direction = "median")


#logFC version
plot_notproSus_logFC <- ggplot() +
  geom_line(data = filt_toptable_notproSus_RUV,
            aes(x = Time, 
                y = logFC, 
                group = Entrez_ID),
            color = "#E1B9E3",
            alpha = 0.4, 
            linewidth = 0.9) +
  geom_line(data = medians_notproSus_RUV,
            aes(x = Time, 
                y = median_logFC, 
                group = 1,
                color = direction),
            linewidth = 3
            ) +
  scale_color_manual(
    breaks = c("median"), 
    values = c("median" = "#A06FA8"),
    labels = c(
      median = labs_logFC_notproSus),
    name = NULL
    ) +
  labs(title = "logFC  notproSus Genes (n = 338)",
       y = "logFC", x = "Timepoint") +
  scale_y_continuous(breaks = c(-10, -5, 0, 5, 10), 
                     limits = c(-10, 10),
                     expand = c(0,0)) +
  scale_x_discrete(breaks = c("t0", "t24", "t144"),
                     expand = c(0, 0)) +
  theme_custom() +
  theme(legend.position = "right")


#absFC version
plot_notproSus_absFC <- ggplot() +
  geom_line(data = filt_toptable_notproSus_RUV,
            aes(x = Time, 
                y = absFC, 
                group = Entrez_ID),
            color = "orchid",
            alpha = 0.4, 
            linewidth = 0.9) +
  geom_line(data = medians_notproSus_RUV,
            aes(x = Time, 
                y = median_abslogFC, 
                group = 1,
                color = direction),
            linewidth = 3
            ) +
  scale_color_manual(
    breaks = c("median"), 
    values = c("median" = "#3D6680"),
    labels = c(
      median = labs_absFC_notproSus),
    name = NULL
    ) +
  labs(title = "abslogFC  notproSus Genes (n = 338)",
       y = "absFC", x = "Timepoint") +
  scale_y_continuous(limits = c(0, 10),
                     expand = c(0, 0)) +
  scale_x_discrete(breaks = c("t0", "t24", "t144"),
                     expand = c(0, 0)) +
  theme_custom() +
  theme(legend.position = "right")


print(plot_notproSus_logFC)
print(plot_notproSus_absFC)

# save_plot(
#   plot = plot_proSus_logFC,
#   filename = "Lineplot_proSus_logFC_EMP_251211",
#   folder = output_folder,
#   height = 4,
#   width = 5
# )
# save_plot(
#   plot = plot_proSus_absFC,
#   filename = "Lineplot_proSus_absFC_EMP_251112",
#   folder = output_folder,
#   height = 4,
#   width = 5
# )
# save_plot(
#   plot = plot_notproSus_logFC,
#   filename = "Lineplot_notproSus_logFC_EMP_251112",
#   folder = output_folder,
#   height = 4,
#   width = 5
# )
# save_plot(
#   plot = plot_notproSus_absFC,
#   filename = "Lineplot_notproSus_absFC_EMP_251112",
#   folder = output_folder,
#   height = 4,
#   width = 5
# )

#Fig6 data here

```

#Updated Forest Plots
```{r Updated Forest Plots Sustained vs notSus}
#I want to have two gene sets - one is the 501 Sustained genes
#the other is every other gene - not my recovered set
#I want to test for enrichment of different gene sets within my Sustained group against the notSus group

#sustained group
final_genes_2_RUV
#notSus group

# notSus_genes <- setdiff(all_genes, final_genes_2_RUV)
# saveRDS(notSus_genes, "data/new/RUV/CMF/notSus_genes_list_entrez.RDS")
notSus_genes <- readRDS("data/new/RUV/CMF/notSus_genes_list_entrez.RDS")
length(notSus_genes)
#total of 13818 expressed genes not in the Sustained group

#collect gene sets from all sources
m_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp4.RDS")
r_eqtls_ids <- readRDS("data/new/eQTLs/knowles_ids_supp5.RDS")
all_eqtls <- unique(c(m_eqtls_ids, r_eqtls_ids))
all_genes <- unique(filcpm_matrix)
all_mtf_genes <- unique(c(final_genes_1_RUV, final_genes_2_RUV))
liu_ids <- readRDS("data/new/RUV/liu_dataset_entrez.RDS")
sapp_ids <- readRDS("data/new/RUV/sapp_dataset_entrez.RDS")
fonoudi_ids <- readRDS("data/new/RUV/fonoudi_dataset_entrez.RDS") #prev DIC
DIC_rm_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS") #now DIC
p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")
DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")
hf_gwas_genes <- readRDS("data/new/GWAS/hf_gwas_genes_symbolentrez_mapped.RDS")
hf_gwas_genes_list <- hf_gwas_genes$Entrez_ID

#list of gene categories
gene_cats <- list( 
  "DNA Damage Response Genes" = unique(na.omit(DNA_damage_genes)),
  "DOX Cardiotoxicity Genes" = unique(na.omit(DIC_rm_genes)),
  "p53 Target Genes" = unique(na.omit(p53_target_genes)),
  "Fonoudi et al." = fonoudi_ids,
  "Liu et al." = liu_ids,
  "Sapp et al." = sapp_ids,
  "Marginal eQTLs" = m_eqtls_ids,
  "Response eQTLs" = r_eqtls_ids,
  "HF GWAS" = hf_gwas_genes_list
)

#make a function to run through fisher's exact testing to find odds ratios
#comparing each sustained group to recovered for all
fisher_test_enrich_new <- function(gene_cats, test_genes, ref_genes) {
  a <- sum(test_genes %in% gene_cats)
  b <- length(test_genes) - a
  c <- sum(ref_genes %in% gene_cats)
  d <- length(ref_genes) - c
  
  mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
                dimnames = list(Group = c("Test", "Reference"),
                                Category = c("InSet", "NotInSet")))
  
  ft <- fisher.test(mat)
  
  tibble(
    OR = unname(ft$estimate),
    CI_low = ft$conf.int[1],
    CI_high = ft$conf.int[2],
    p_value = ft$p.value,
    Significant = case_when(
      ft$p.value < 0.001 ~ "***",
      ft$p.value < 0.01  ~ "**",
      ft$p.value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  )
}


#function to compare the gene sets to one another
compare_sets <- function(test_genes, ref_genes, label) {
  summary_df <- map_dfr(names(gene_cats), function(cat_name) {
    res <- fisher_test_enrich_new(gene_cats[[cat_name]], 
                                  test_genes, ref_genes)
    res %>% mutate(Category = cat_name)
  })
  
  summary_df$Category <- factor(summary_df$Category, 
                                levels = rev(names(gene_cats)))
  summary_df$Comparison <- label
  return(summary_df)
}

#make all comparisons
comparisons <- bind_rows(
  compare_sets(final_genes_2_RUV, 
               notSus_genes, 
               "Sustained vs notSustained"),
  compare_sets(proSus_gene_list,
               final_genes_1_RUV, 
               "proSus vs Recovered"),
  compare_sets(notproSus_gene_list, 
               final_genes_1_RUV,
               "notproSus vs Recovered")
)

comparisons <- comparisons %>%
  mutate(
    OR_plot = ifelse(OR == 0, 1e-3, OR),
    CI_low_plot = ifelse(CI_low == 0, 1e-3, CI_low),
    CI_high_plot = ifelse(CI_high == 0, 1e-3, CI_high)
  )

#order factors for plotting
comparisons$Category <- factor(comparisons$Category, levels = rev(names(gene_cats)))

comparisons$Comparison <- factor(
  comparisons$Comparison,
  levels = c("Sustained vs notSustained", 
             "proSus vs Recovered", 
             "notproSus vs Recovered")
)

#generate six forest plots: 3x log scale, 3x standard scale

make_forest_plot <- function(df, log_scale = TRUE) {
  
  #add a small epsilon to avoid plotting issues
  epsilon <- 0.001
  df_plots <- df %>%
    mutate(
      OR_plot = ifelse(OR == 0, epsilon, OR),
      CI_low_plot = ifelse(CI_low == 0, epsilon, CI_low),
      CI_high_plot = CI_high
    )
  
  #then make the plots for linear and log
  p <- ggplot(df_plots, 
              aes(y = Category, x = OR_plot, 
                  xmin = CI_low_plot, xmax = CI_high_plot)) +
    geom_point(size = 3.5) +
    geom_errorbarh(height = 0.5,
                   linewidth = 0.5, 
                   linetype = "solid", 
                   color = "black") +
    geom_text(aes(label = Significant), 
              position = position_nudge(y = 0.3),
              color = "black", 
              size = 4) +
    geom_vline(xintercept = 1, 
               linetype = "dashed", 
               color = "red") +
    labs(x = ifelse(log_scale, "Odds Ratio (log scale)", "Odds Ratio"),
         y = "",
         title = unique(df_plots$Comparison)) +
    theme_custom() 

  # Apply consistent scale with limits covering all CIs
  if (log_scale) {
    p <- p + scale_x_log10(limits = c(0.001, 
                                      max(df$CI_high_plot, 
                                               na.rm = TRUE) * 2))
  } else {
    p <- p + scale_x_continuous(limits = c(-2, 40))
  }

  return(p)
}

#optional breaks to put in scale_x_log10 
##limits = c(0.01, 100), breaks = c(0.01, 0.1, 1, 10, 100)
#breaks = c(0.01, 0.1, 1, 10, 100, 1000, 10000)

#plot all forest plots
plots <- comparisons %>%
  group_split(Comparison) %>%
  map(~list(
    log = make_forest_plot(.x, log_scale = TRUE),
    linear = make_forest_plot(.x, log_scale = FALSE)
  ))

#create and view summary table
forest_summary_ordered <- comparisons %>%
  mutate(Category = factor(Category, 
                           levels = c("DNA Damage Response Genes", 
                                      "DOX Cardiotoxicity Genes", 
                                      "p53 Target Genes", 
                                      "Fonoudi et al.", 
                                      "Liu et al.", 
                                      "Sapp et al.", 
                                      "Marginal eQTLs", 
                                      "Response eQTLs",
                                      "HF GWAS"))) %>%
  arrange(Comparison, Category) %>%
  mutate(
    OR = round(OR, 3),
    CI_low = round(CI_low, 3),
    CI_high = round(CI_high, 3),
    p_value = signif(p_value, 3)
  )

#print the summary for all stats
print(forest_summary_ordered)

#label my comparisons for plots
comparison_labels <- c("Sus_notSus", "proSus_Rec", "notproSus_Rec")

for (i in seq_along(plots)) {
  comp_name <- comparison_labels[i]

  # log-scale plot
  save_plot(
    plot = plots[[i]]$log,
    filename = paste0("ForestPlot_", comp_name, "_log"),
    folder = output_folder
  )
}

# # linear-scale plot
# save_plot(
#   plot = plots[[i]]$linear,
#   filename = paste0("ForestPlot_", comp_name, "_linear_old"),
#   folder = output_folder
# )
# }


#now make the linear plots more polished
make_linear_forest_plot <- function(df) {
  
  #add a small epsilon to avoid plotting issues
  epsilon <- 0.001
  df_plot <- df %>%
    mutate(
      OR_plot = ifelse(OR == 0, epsilon, OR),
      CI_low_plot = ifelse(CI_low == 0, epsilon, CI_low),
      CI_high_plot = CI_high
    )
  
  # Find maximum x limit to show all CIs
  # x_max <- max(df_plot$CI_high_plot, na.rm = TRUE) * 1.2
  # x_min <- 0 # start from 0 so small ORs are visible
  
  p <- ggplot(df_plot, aes(y = Category, x = OR_plot,
                           xmin = CI_low_plot, 
                           xmax = CI_high_plot)) +
    geom_point(size = 3.5) +
    geom_errorbarh(height = 0.5, linewidth = 0.5, color = "black") +
    geom_text(aes(label = Significant), 
              position = position_nudge(y = 0.3), size = 4) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
    labs(x = "Odds Ratio (linear scale)", y = "Gene Set",
         title = unique(df$Comparison)) +
    theme_custom() +
    coord_cartesian(xlim = c(-2, 40))
  
  return(p)
}


comparisons$Comparison <- factor(
  comparisons$Comparison,
  levels = c("Sustained vs notSustained", 
             "proSus vs Recovered", 
             "notproSus vs Recovered")
)

linear_plots <- comparisons %>%
  group_split(Comparison) %>%
  map(~ make_linear_forest_plot(.x))

for (i in seq_along(linear_plots)) {
  comp_name <- comparison_labels[i]

  # linear-scale plot
  save_plot(
    plot = linear_plots[[i]],
    filename = paste0("ForestPlot_", comp_name, "_linear_EMP"),
    folder = output_folder
  )
}

```

#HF GWAS Venn Diagram
```{r Venn Diagram HF GWAS genes proSus}

proSus_gene_list
notproSus_gene_list
final_genes_1_RUV
hf_gwas_genes <- readRDS("data/new/GWAS/hf_gwas_genes_symbolentrez_mapped.RDS")
hf_gwas_genes_list <- hf_gwas_genes$Entrez_ID

venn_proSus_list_HF <- list(
  HF = as.character(hf_gwas_genes_list),
  Recovered = as.character(final_genes_1_RUV),
  proSus = as.character(proSus_gene_list),
  notproSus = as.character(notproSus_gene_list)
)


venn_proSus_HF <- ggVennDiagram(
  venn_proSus_list_HF,
  category.names = c("HF GWAS\n (n = 299)", 
                     "Recovered \n (n = 7602)", 
                     "proSus \n (n = 163)", 
                     "notproSus \n (n = 338)")
) +
  ggtitle("HF GWAS Genes\n proSus vs notproSus vs Recovered vs HF GWAS") +
  labs(x = NULL, y = NULL) +
  scale_fill_gradient(low = "#F9F9F9", high = "#4B9CD3") +
  theme_custom()


print(venn_proSus_HF)

save_plot(
  plot = venn_proSus_HF,
  filename = "Venn_HF_proSus_EMP",
  folder = output_folder,
  height = 6,
  width = 8
)

```

#HF GWAS log2cpm overlapping genes
```{r Overlap log2cpm Genes notproSus}

#there are 4 total genes to investigate based on the Venn diagram of overlap with HF GWAS Genes
#4 overlap with notproSus

notproSus_overlap <- notproSus_gene_list[notproSus_gene_list %in% hf_gwas_genes_list]
#Entrez_IDs - 11113, 26154, 10293, 1026

HF_cats <- list( 
  "HF GWAS" = hf_gwas_genes_list
)

hf_gwas_cats <- list( 
  "HF GWAS Genes" = unique(na.omit(hf_gwas_genes_list))
)

#pull the gene symbol so I can plot log2cpm data
hf_genes_df <- map_dfr(names(HF_cats), function(cat) {
  tibble(
    Entrez_ID = intersect(hf_gwas_genes_list, HF_cats[[cat]]),
    Category = cat
  )
})

dim(hf_genes_df)


#filter overlaps for notproSus
notproSus_overlap_hf <- hf_genes_df %>%
  filter(Entrez_ID %in% notproSus_gene_list)
#4 genes

# saveRDS(deg_wide, "data/new/RUV/CMF/DEGs_overlap_wide_dataframe.RDS")
#read in my dataframe for plotting log2cpm genes
deg_wide <- readRDS("data/new/RUV/CMF/DEGs_overlap_wide_dataframe.RDS")

notproSus_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% notproSus_overlap_hf$Entrez_ID)

#check whether the assumptions are stil the same that the absFC is t0 < t144

#find gene symbols

notproSus_overlap_hf <- notproSus_overlap_hf %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

#now plot these example genes for each
boxplot_new <- readRDS("data/new/RUV/CMF/log2cpm_boxplotdata_updated.RDS")

#process the cpm data
process_cpm_data_cormotif <- function(gene_id, expr_df) {
  gene_data <- expr_df %>% filter(Entrez_ID == gene_id)
  
  long_data <- gene_data %>%
    pivot_longer(
      cols = -c(Entrez_ID, SYMBOL),
      names_to = "Sample",
      values_to = "log2CPM"
    ) %>%
    mutate(
      Treatment = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("VEH", Sample) ~ "VEH",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("t0", Sample) ~ "t0",
        grepl("t24", Sample) ~ "t24",
        grepl("t144", Sample) ~ "t144",
        TRUE ~ NA_character_
      ),
      Individual = case_when(
        grepl("1$", Sample) ~ "1",
        grepl("2$", Sample) ~ "2",
        grepl("3$", Sample) ~ "3",
        grepl("4$", Sample) ~ "4",
        grepl("5$", Sample) ~ "5",
        grepl("6$", Sample) ~ "6",
        grepl("6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Treatment, Timepoint, sep = "_")
    )
  
  # Set factor levels for plotting order
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c("DOX_t0", "VEH_t0", 
               "DOX_t24", "VEH_t24", 
               "DOX_t144", "VEH_t144")
  )
  
  return(long_data)
}

# Function to generate plots for a set of genes
generate_overlap_plots_cormotif <- function(overlap_df, expr_df, comparison_label) {
  plots <- list()
  
  for (gene_id in overlap_df$Entrez_ID) {
    gene_data <- process_cpm_data_cormotif(gene_id, expr_df)
    
    # Get SYMBOL and all categories
    gene_symbol <- unique(gene_data$SYMBOL)
    gene_categories <- overlap_df$Category[overlap_df$Entrez_ID == gene_id]
    gene_categories <- paste(unique(gene_categories), collapse = ", ")
    
    p <- ggplot(gene_data, aes(x = Condition, 
                               y = log2CPM,
                               fill = Condition)) +
      geom_boxplot(outlier.shape = NA) +
      geom_point(aes(color = Individual), size = 2, 
                 alpha = 0.9,
                 position = position_identity()) +
      scale_fill_manual(values = txtime_col) +
      scale_color_manual(values = ind_col) +
      ggtitle(paste0(gene_symbol,
                     " (", comparison_label, " in ", gene_categories, ") ")) +
      labs(x = "Condition", y = "log2cpm") +
      theme_custom()
    
    # Use Entrez_ID + SYMBOL + comparison label for the list name to guarantee uniqueness
    plot_name <- paste0(gene_symbol, "_", gene_id, "_", comparison_label)
    plots[[plot_name]] <- p
  }
  
  return(plots)
}

#generate plots for notproSus overlap genes
notproSus_plots_hf <- generate_overlap_plots_cormotif(notproSus_overlap_hf, boxplot_new, "notproSus")

#preview all plots
for (p in c(notproSus_plots_hf)) print(p)

#save all of these plots with unique names
for (plot_name in names(notproSus_plots_hf)) {
  save_plot(notproSus_plots_hf[[plot_name]],
            filename = paste0("ExGene_HF_notproSus_", plot_name, "_EMP"),
            folder = output_folder)
}


```


#HF GWAS Forest Plot
```{r Forest plot for HF GWAS proSus}
#make an updated forest plot with HF GWAS data

hf_gwas_genes <- readRDS("data/new/GWAS/hf_gwas_genes_symbolentrez_mapped.RDS")
hf_gwas_genes_list <- hf_gwas_genes$Entrez_ID

#list of gene categories
gene_cats <- list(
  "HF GWAS" = hf_gwas_genes_list
)

#make a function to run through fisher's exact testing to find odds ratios
#comparing each sustained group to recovered for all
fisher_test_enrich_new <- function(gene_cats, test_genes, ref_genes) {
  a <- sum(test_genes %in% gene_cats)
  b <- length(test_genes) - a
  c <- sum(ref_genes %in% gene_cats)
  d <- length(ref_genes) - c
  
  mat <- matrix(c(a, b, c, d), nrow = 2, byrow = TRUE,
                dimnames = list(Group = c("Test", "Reference"),
                                Category = c("InSet", "NotInSet")))
  
  ft <- fisher.test(mat)
  
  tibble(
    OR = unname(ft$estimate),
    CI_low = ft$conf.int[1],
    CI_high = ft$conf.int[2],
    p_value = ft$p.value,
    Significant = case_when(
      ft$p.value < 0.001 ~ "***",
      ft$p.value < 0.01  ~ "**",
      ft$p.value < 0.05  ~ "*",
      TRUE ~ "ns"
    )
  )
}


#function to compare the gene sets to one another
compare_sets <- function(test_genes, ref_genes, label) {
  summary_df <- map_dfr(names(gene_cats), function(cat_name) {
    res <- fisher_test_enrich_new(gene_cats[[cat_name]], 
                                  test_genes, ref_genes)
    res %>% mutate(Category = cat_name)
  })
  
  summary_df$Category <- factor(summary_df$Category, 
                                levels = rev(names(gene_cats)))
  summary_df$Comparison <- label
  return(summary_df)
}

#make all comparisons
comparisons <- bind_rows(
  compare_sets(final_genes_2_RUV, 
               final_genes_1_RUV, 
               "Sustained vs Recovered"),
  compare_sets(proSus_gene_list,
               final_genes_1_RUV, 
               "proSus vs Recovered"),
  compare_sets(notproSus_gene_list, 
               final_genes_1_RUV,
               "notproSus vs Recovered")
)

comparisons <- comparisons %>%
  mutate(
    OR_plot = ifelse(OR == 0, 1e-3, OR),
    CI_low_plot = ifelse(CI_low == 0, 1e-3, CI_low),
    CI_high_plot = ifelse(CI_high == 0, 1e-3, CI_high)
  )

#order factors for plotting
comparisons$Category <- factor(comparisons$Category, levels = rev(names(gene_cats)))

comparisons$Comparison <- factor(
  comparisons$Comparison,
  levels = c("Sustained vs Recovered", 
             "proSus vs Recovered", 
             "notproSus vs Recovered")
)

#generate forest plot: log scale, linear scale

make_forest_plot <- function(df, log_scale = TRUE) {
  
  #add a small epsilon to avoid plotting issues
  epsilon <- 0.001
  df_plots <- df %>%
    mutate(
      OR_plot = ifelse(OR == 0, epsilon, OR),
      CI_low_plot = ifelse(CI_low == 0, epsilon, CI_low),
      CI_high_plot = CI_high
    )
  
  #then make the plots for linear and log
  p <- ggplot(df_plots, 
              aes(y = Category, x = OR_plot, 
                  xmin = CI_low_plot, xmax = CI_high_plot)) +
    geom_point(size = 3.5) +
    geom_errorbarh(height = 0.1,
                   linewidth = 0.5, 
                   linetype = "solid", 
                   color = "black") +
    geom_text(aes(label = Significant), 
              position = position_nudge(y = 0.1),
              color = "black", 
              size = 4) +
    geom_vline(xintercept = 1, 
               linetype = "dashed", 
               color = "red") +
    labs(x = ifelse(log_scale, "Odds Ratio (log scale)", "Odds Ratio"),
         y = "",
         title = unique(df_plots$Comparison)) +
    theme_custom() 

  # Apply consistent scale with limits covering all CIs
  if (log_scale) {
    p <- p + scale_x_log10(limits = c(0.001, 
                                      max(df$CI_high_plot, 
                                               na.rm = TRUE) * 1.5))
  } else {
    p <- p + scale_x_continuous(limits = c(-2, 40))
  }

  return(p)
}

#optional breaks to put in scale_x_log10 
##limits = c(0.01, 100), breaks = c(0.01, 0.1, 1, 10, 100)
#breaks = c(0.01, 0.1, 1, 10, 100, 1000, 10000)

#plot all forest plots
plots <- comparisons %>%
  group_split(Comparison) %>%
  map(~list(
    log = make_forest_plot(.x, log_scale = TRUE),
    linear = make_forest_plot(.x, log_scale = FALSE)
  ))

#create and view summary table
forest_summary_ordered_hf <- comparisons %>%
  mutate(Category = factor(Category, 
                           levels = c("HF GWAS"
                                      ))) %>%
  arrange(Comparison, Category) %>%
  mutate(
    OR = round(OR, 3),
    CI_low = round(CI_low, 3),
    CI_high = round(CI_high, 3),
    p_value = signif(p_value, 3)
  )

#print the summary for all stats
print(forest_summary_ordered_hf)

#label my comparisons for plots
comparison_labels <- c("Sus_Rec", "proSus_Rec", "notproSus_Rec")

for (i in seq_along(plots)) {
  comp_name <- comparison_labels[i]

  # log-scale plot
  save_plot(
    plot = plots[[i]]$log,
    filename = paste0("ForestPlot_HFGWAS_", comp_name, "_log_EMP"),
    folder = output_folder
  )
}


#now make the linear plots more polished
make_linear_forest_plot <- function(df) {
  
  #add a small epsilon to avoid plotting issues
  epsilon <- 0.001
  df_plot <- df %>%
    mutate(
      OR_plot = ifelse(OR == 0, epsilon, OR),
      CI_low_plot = ifelse(CI_low == 0, epsilon, CI_low),
      CI_high_plot = CI_high
    )
  
  # Find maximum x limit to show all CIs
  # x_max <- max(df_plot$CI_high_plot, na.rm = TRUE) * 1.2
  # x_min <- 0 # start from 0 so small ORs are visible
  
  p <- ggplot(df_plot, aes(y = Category, x = OR_plot,
                           xmin = CI_low_plot, 
                           xmax = CI_high_plot)) +
    geom_point(size = 3.5) +
    geom_errorbarh(height = 0.1, linewidth = 0.5, color = "black") +
    geom_text(aes(label = Significant), 
              position = position_nudge(y = 0.1), size = 4) +
    geom_vline(xintercept = 1, linetype = "dashed", color = "red") +
    labs(x = "Odds Ratio (linear scale)", y = "Gene Set",
         title = unique(df$Comparison)) +
    theme_custom() +
    coord_cartesian(xlim = c(-2, 40))
  
  return(p)
}


comparisons$Comparison <- factor(
  comparisons$Comparison,
  levels = c("Sustained vs Recovered", 
             "proSus vs Recovered", 
             "notproSus vs Recovered")
)

linear_plots <- comparisons %>%
  group_split(Comparison) %>%
  map(~ make_linear_forest_plot(.x))

for (i in seq_along(linear_plots)) {
  comp_name <- comparison_labels[i]

  # linear-scale plot
  save_plot(
    plot = linear_plots[[i]],
    filename = paste0("ForestPlot_HFGWAS_", comp_name, "_linear_EMP"),
    folder = output_folder
  )
}

```


#Identify proSus genes directionality
```{r proSus genes up vs down regulation}
#I want to take my set of proSus genes and stratify by response direction
proSus_df <- readRDS("data/new/RUV/CMF/Sustained_proSus_dataframe_symbolentrez.RDS")

#pull the proSus genes from the df
proSus_only_df <- proSus_df %>% 
  filter(
    Category == "proSus"
  )


#now find direction
proSus_only_df <- proSus_only_df %>%
  mutate(Direction = case_when(
    !is.na(logFC_t0) & !is.na(logFC_t24) & !is.na(logFC_t144) &
      logFC_t0 < logFC_t24 & logFC_t24 < logFC_t144 ~ "Upregulated",

    !is.na(logFC_t0) & !is.na(logFC_t24) & !is.na(logFC_t144) &
      logFC_t0 > logFC_t24 & logFC_t24 > logFC_t144 ~ "Downregulated",

    TRUE ~ "Mixed"
  ))

table(proSus_only_df$Direction)


proSus_up_genes <- proSus_only_df %>%
  dplyr::filter(Direction == "Upregulated") %>%
  dplyr::pull(Entrez_ID, SYMBOL)
#9 upregulated genes by logFC
#2 of these are DEGs in all timepoints - ACHE & CPE

proSus_down_genes <- proSus_only_df %>%
  dplyr::filter(Direction == "Downregulated") %>%
  dplyr::pull(Entrez_ID, SYMBOL)
#154 genes downregulated by logFC

#plot these genes on a line plot as well as pulling out the log2cpm genes


```

##line plots proSus up vs down
```{r LogFC absFC line plots up vs down reg}

proSus_up_genes
proSus_down_genes

# saveRDS(proSus_only_df, "data/new/RUV/CMF/proSus_genes_only_dataframe.RDS")
proSus_only_df <- readRDS("data/new/RUV/CMF/proSus_genes_only_dataframe.RDS")

proSus_only_long <- proSus_only_df %>%
  pivot_longer(
    cols = starts_with("logFC_"),
    names_to = "Time",
    values_to = "logFC"
  ) %>%
  mutate(
    Time = factor(Time,
                  levels = c("logFC_t0", "logFC_t24", "logFC_t144"),
                  labels = c("t0", "t24", "t144"))
  )


medians_logFC <- proSus_only_long %>%
  group_by(Direction, Time) %>%
  summarise(median_logFC = median(logFC, na.rm = TRUE), .groups = "drop")

labs_logFC_proSus <- paste0(
  "proSus\nmedian logFC =\n",
  paste0(medians_logFC$Time, "=", round(medians_logFC$median_logFC, 2), collapse = "\n")
)

#plot upregulated genes
plot_proSus_up <- ggplot() +
    geom_line(
    data = proSus_only_long %>% filter(Direction == "Upregulated"),
    aes(x = Time, y = logFC, group = Entrez_ID),
    color = "#7EC8E3",
    alpha = 0.5,
    linewidth = 0.9
  ) +
  geom_line(
    data = medians_logFC %>% filter(Direction == "Upregulated"),
    aes(x = Time, y = median_logFC, group = 1),
    color = "#3D6680",
    linewidth = 2
  ) +
  geom_text(
    data = medians_logFC %>% filter(Direction == "Upregulated"),
    aes(x = Time, y = median_logFC,
        label = round(median_logFC, 2)),
    vjust = -0.7,
    size = 3
  ) +
  labs(
    title = "proSus upregulated genes (n = 9)",
    x = "Timepoint",
    y = "logFC"
  ) +
  theme_custom()

#now plot downregulated genes
plot_proSus_down <- ggplot() +
    geom_line(
    data = proSus_only_long %>% filter(Direction == "Downregulated"),
    aes(x = Time, y = logFC, group = Entrez_ID),
    color = "#7EC8E3",
    alpha = 0.5,
    linewidth = 0.9
  ) +
  geom_line(
    data = medians_logFC %>% filter(Direction == "Downregulated"),
    aes(x = Time, y = median_logFC, group = 1),
    color = "#3D6680",
    linewidth = 2
  ) +
  geom_text(
    data = medians_logFC %>% filter(Direction == "Downregulated"),
    aes(x = Time, y = median_logFC,
        label = round(median_logFC, 2)),
    vjust = -0.7,
    size = 3
  ) +
  labs(
    title = "proSus downregulated genes (n = 154)",
    x = "Timepoint",
    y = "logFC"
  ) +
  theme_custom()

print(plot_proSus_up)
print(plot_proSus_down)

# save_plot(
#   plot_proSus_up,
#   filename = "LinePlot_proSus_upreg_EMP",
#   folder = output_folder
# )
# 
# save_plot(
#   plot_proSus_down,
#   filename = "LinePlot_proSus_downreg_EMP",
#   folder = output_folder
# )


```


#plot log2cpm of 9 upregulated genes
```{r Upregulated genes proSus log2cpm examples}

#there are 9 total genes to investigate that are upregulated in proSus

proSus_up_genes

dir_cats <- list( 
  "Upregulated" = proSus_up_genes
)

proSus_up_cats <- list( 
  "Upregulated" = unique(na.omit(proSus_up_genes))
)

#pull the gene symbol so I can plot log2cpm data
proSus_up_genes_df <- map_dfr(names(up_cats), function(cat) {
  tibble(
    Entrez_ID = intersect(proSus_up_genes, up_cats[[cat]]),
    Category = cat
  )
})

dim(proSus_up_genes_df)


#filter overlaps for notproSus
proSus_upreg <- proSus_up_genes_df %>%
  filter(Entrez_ID %in% proSus_gene_list)
#9 genes

# saveRDS(deg_wide, "data/new/RUV/CMF/DEGs_overlap_wide_dataframe.RDS")
#read in my dataframe for plotting log2cpm genes
deg_wide <- readRDS("data/new/RUV/CMF/DEGs_overlap_wide_dataframe.RDS")

proSus_up_degs <- deg_wide %>% 
  dplyr::filter(Entrez_ID %in% proSus_upreg$Entrez_ID)

proSus_upreg <- proSus_upreg %>%
  mutate(
    SYMBOL = mapIds(
      org.Hs.eg.db,
      keys = Entrez_ID,
      column = "SYMBOL",
      keytype = "ENTREZID",
      multiVals = "first"
    )
  )

#now plot these example genes for each
boxplot_new <- readRDS("data/new/RUV/CMF/log2cpm_boxplotdata_updated.RDS")

#process the cpm data
process_cpm_data_cormotif <- function(gene_id, expr_df) {
  gene_data <- expr_df %>% filter(Entrez_ID == gene_id)
  
  long_data <- gene_data %>%
    pivot_longer(
      cols = -c(Entrez_ID, SYMBOL),
      names_to = "Sample",
      values_to = "log2CPM"
    ) %>%
    mutate(
      Treatment = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("VEH", Sample) ~ "VEH",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("t0", Sample) ~ "t0",
        grepl("t24", Sample) ~ "t24",
        grepl("t144", Sample) ~ "t144",
        TRUE ~ NA_character_
      ),
      Individual = case_when(
        grepl("1$", Sample) ~ "1",
        grepl("2$", Sample) ~ "2",
        grepl("3$", Sample) ~ "3",
        grepl("4$", Sample) ~ "4",
        grepl("5$", Sample) ~ "5",
        grepl("6$", Sample) ~ "6",
        grepl("6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Treatment, Timepoint, sep = "_")
    )
  
  # Set factor levels for plotting order
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c("DOX_t0", "VEH_t0", 
               "DOX_t24", "VEH_t24", 
               "DOX_t144", "VEH_t144")
  )
  
  return(long_data)
}

# Function to generate plots for a set of genes
generate_overlap_plots_cormotif <- function(overlap_df, expr_df, comparison_label) {
  plots <- list()
  
  for (gene_id in overlap_df$Entrez_ID) {
    gene_data <- process_cpm_data_cormotif(gene_id, expr_df)
    
    # Get SYMBOL and all categories
    gene_symbol <- unique(gene_data$SYMBOL)
    gene_categories <- overlap_df$Category[overlap_df$Entrez_ID == gene_id]
    gene_categories <- paste(unique(gene_categories), collapse = ", ")
    
    p <- ggplot(gene_data, aes(x = Condition, 
                               y = log2CPM,
                               fill = Condition)) +
      geom_boxplot(outlier.shape = NA) +
      geom_point(aes(color = Individual), size = 2, 
                 alpha = 0.9,
                 position = position_identity()) +
      scale_fill_manual(values = txtime_col) +
      scale_color_manual(values = ind_col) +
      ggtitle(paste0(gene_symbol,
                     " (", comparison_label, " - ", gene_categories, ") ")) +
      labs(x = "Condition", y = "log2cpm") +
      theme_custom()
    
    # Use Entrez_ID + SYMBOL + comparison label for the list name to guarantee uniqueness
    plot_name <- paste0(gene_symbol, "_", gene_id, "_", comparison_label)
    plots[[plot_name]] <- p
  }
  
  return(plots)
}

#generate plots for notproSus overlap genes
proSus_up_plots <- generate_overlap_plots_cormotif(proSus_upreg, boxplot_new, "proSus")

#preview all plots
for (p in c(proSus_up_plots)) print(p)

#save all of these plots with unique names
for (plot_name in names(proSus_up_plots)) {
  save_plot(proSus_up_plots[[plot_name]],
            filename = paste0("ExGene_proSus_Upreg_", plot_name, "_EMP"),
            folder = output_folder)
}

```

```{r GO Analysis proSus upreg and downreg genes}
#I want to look at biological pathways potentially involved in my proSus upregulated and proSus downregulated genes that I identified

#start with proSus_up
proSus_up_genes <- readRDS("data/new/RUV/CMF/proSus_upregulated_gene_list.RDS")
proSus_down_genes <- readRDS("data/new/RUV/CMF/proSus_downregulated_gene_list.RDS")

#background
# all_genes - all expressed genes

length(proSus_up_genes)
#9 genes

up_proSus_GOKEGG_RUV <- gost(query = proSus_up_genes,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          significant = TRUE,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

up_proSus_GOKEGG_genes_RUV <- gostplot(up_proSus_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
up_proSus_GOKEGG_genes_RUV

table_up_proSus_GOKEGG_genes_RUV <- up_proSus_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_up_proSus_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_up_proSus_genes_GOBP_RUV <- table_up_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

up_proSus_table_genes_GOBP_plot <- ggplot(table_up_proSus_genes_GOBP_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Upregulated proSus Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(up_proSus_table_genes_GOBP_plot)

save_plot(
  plot = up_proSus_table_genes_GOBP_plot,
  filename = "Sustained_upreg_proSus_GOBP_logval_all_EMP",
  folder = output_folder
)

#KEGG
table_up_proSus_genes_KEGG_RUV <- table_up_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

up_proSus_table_genes_KEGG_plot <- ggplot(table_up_proSus_genes_KEGG_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Upregulated proSus Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(up_proSus_table_genes_KEGG_plot)

save_plot(
  plot = up_proSus_table_genes_KEGG_plot,
  filename = "Sustained_upreg_proSus_KEGG_logval_all_EMP",
  folder = output_folder
)
#no results for up proSus (likely due to small # of genes)

#now do the same for down proSus genes

down_proSus_GOKEGG_RUV <- gost(query = proSus_down_genes,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          significant = TRUE,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

down_proSus_GOKEGG_genes_RUV <- gostplot(down_proSus_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
down_proSus_GOKEGG_genes_RUV

table_down_proSus_GOKEGG_genes_RUV <- down_proSus_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_down_proSus_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_down_proSus_genes_GOBP_RUV <- table_down_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

down_proSus_table_genes_GOBP_plot <- ggplot(table_down_proSus_genes_GOBP_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Downregulated proSus Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(down_proSus_table_genes_GOBP_plot)

save_plot(
  plot = down_proSus_table_genes_GOBP_plot,
  filename = "Sustained_downreg_proSus_GOBP_logval_all_EMP",
  folder = output_folder
)

#KEGG
table_down_proSus_genes_KEGG_RUV <- table_down_proSus_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

down_proSus_table_genes_KEGG_plot <- ggplot(table_down_proSus_genes_KEGG_RUV, aes(x = log_val, y = reorder(term_name, p_value))) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Downregulated proSus Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(size= guide_legend(title = "# of \n intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_custom()

print(down_proSus_table_genes_KEGG_plot)

save_plot(
  plot = down_proSus_table_genes_KEGG_plot,
  filename = "Sustained_downreg_proSus_KEGG_logval_all_EMP",
  folder = output_folder
)


```

#Drug Bank Resource
```{r Load in DrugBank database information}

library(xml2)

# drugbank_xml <- read_xml("D:/DrugBank/full database.xml")
# 
# #check the namespace so I'm pulling drugs correctly
# ns <- xml_ns(drugbank_xml)
# 
# drug_nodes <- xml_find_all(drugbank_xml, ".//d1:drug", ns)
# length(drug_nodes)
# 
# #extract all of the info I want from the database using the right namespace d1
# extract_drug_info <- function(drug_node, ns) {
#   # basic identifiers
#   drug_id   <- xml_text(xml_find_first(drug_node,
#                                        "./d1:drugbank-id[@primary='true']", ns))
#   drug_name <- xml_text(xml_find_first(drug_node, 
#                                        "./d1:name", ns))
#   cas_num   <- xml_text(xml_find_first(drug_node,
#                                        "./d1:cas-number", ns))
#   
#   # KEGG ID
#   kegg_id <- xml_text(xml_find_first(drug_node,".//d1:external-identifiers/d1:external-identifier[d1:resource='KEGG Drug']/d1:identifier", ns))
# 
#   # groups (approved, investigational, etc.)
#   groups <- xml_find_all(drug_node, "./d1:groups/d1:group", ns) %>%
#     xml_text() %>% paste(collapse = "; ")
# 
#   # categories
#   categories <- xml_find_all(drug_node,
#                              "./d1:categories/d1:category/d1:category", ns) %>%
#     xml_text() %>% paste(collapse = "; ")
# 
#   # classifications
#   classification <- xml_find_first(drug_node, "./d1:classification", ns)
#   if (!is.na(classification)) {
#     kingdom    <- xml_text(xml_find_first(classification, "./d1:kingdom", ns))
#     superclass <- xml_text(xml_find_first(classification, "./d1:superclass", ns))
#     class      <- xml_text(xml_find_first(classification, "./d1:class", ns))
#     subclass   <- xml_text(xml_find_first(classification, "./d1:subclass", ns))
#     classifications <- paste(kingdom, superclass, class, subclass, sep = " | ")
#   } else {
#     classifications <- NA_character_
#   }
# 
#   # major text fields
#   description        <- xml_text(xml_find_first(drug_node, 
#                                                 "./d1:description", ns))
#   indication         <- xml_text(xml_find_first(drug_node, 
#                                                 "./d1:indication", ns))
#   pharmacodynamics   <- xml_text(xml_find_first(drug_node,
#                                                 "./d1:pharmacodynamics", ns))
#   mechanism_of_action <- xml_text(xml_find_first(drug_node,
#                                                  "./d1:mechanism-of-action", ns))
#   toxicity           <- xml_text(xml_find_first(drug_node, 
#                                                 "./d1:toxicity", ns))
# 
#   # target genes and actions (no polypeptide sequences)
#   target_nodes <- xml_find_all(drug_node, "./d1:targets/d1:target", ns)
# 
#   if (length(target_nodes) > 0) {
#     target_info <- map_dfr(target_nodes, function(tn) {
#       gene <- xml_text(xml_find_first(tn, "./d1:polypeptide/d1:gene-name", ns))
#       actions <- xml_find_all(tn, "./d1:actions/d1:action", ns) %>% xml_text() %>%
#         paste(collapse = "; ")
#       tibble(gene = gene, target_actions = actions)
#     })
#   } else {
#     target_info <- tibble(gene = NA_character_, target_actions = NA_character_)
#   }
# 
#   # dosage info
#   dosage_nodes <- xml_find_all(drug_node, "./d1:dosages/d1:dosage", ns)
#   if (length(dosage_nodes) > 0) {
#     dosages <- dosage_nodes %>% 
#       map_chr(~ paste(
#         xml_text(xml_find_first(.x, "./d1:form", ns)),
#         xml_text(xml_find_first(.x, "./d1:route", ns)),
#         xml_text(xml_find_first(.x, "./d1:strength", ns)),
#         sep = " | "
#       )) %>% paste(collapse = "; ")
#   } else {
#     dosages <- NA_character_
#   }
# 
#   # combine into full table
#   out <- target_info %>%
#     mutate(
#       drugbank_id        = drug_id,
#       drug_name          = drug_name,
#       cas_number         = cas_num,
#       kegg_id            = kegg_id,
#       groups             = groups,
#       categories         = categories,
#       classifications    = classifications,
#       description        = description,
#       indication         = indication,
#       pharmacodynamics   = pharmacodynamics,
#       mechanism_of_action = mechanism_of_action,
#       toxicity           = toxicity,
#       dosages            = dosages
#     ) %>%
#     relocate(drugbank_id, drug_name, cas_number, kegg_id)
# 
#   return(out)
# }

#run for all drugs in the system
# drug_target_df <- map_dfr(drug_nodes, ~extract_drug_info(.x, ns))
# drug_target_df <- na.omit(drug_target_df)
# saveRDS(drug_target_df, "data/new/DrugBank/drug_target_df_allinfo.RDS")

#read in the dataframe that I made above
drug_target_df <- readRDS("data/new/DrugBank/drug_target_df_allinfo.RDS")

```


```{r Interrogate DrugBank for proSus up genes}
#I am interested to find out if any upregulated proSus genes (9) are targetable

#ddd in my target genes that I want to investigate to my df

proSus_up_symbol <- names(proSus_up_genes)
proSus_down_symbol <- names(proSus_down_genes)

#first filter for my proSus upregulated genes (9)
proSus_up_drugs <- drug_target_df %>%
  filter(gene %in% proSus_up_symbol)
proSus_up_drugs <- proSus_up_drugs %>% filter(!is.na(gene))

#filter for my downregulated proSus genes
proSus_down_drugs <- drug_target_df %>%
  filter(gene %in% proSus_down_symbol)
proSus_down_drugs <- proSus_down_drugs %>% filter(!is.na(gene))

#make a list for upregulated genes
up_drug_list_per_gene <- proSus_up_drugs %>%
  group_by(gene) %>%
  summarise(drugs = paste(unique(drug_name), collapse = ", "))

# write.csv(up_drug_list_per_gene, "data/new/DrugBank/proSus_up_genes_drug_list.csv")

#summarize downregulated genes in a list too
down_drug_list_per_gene <- proSus_down_drugs %>%
  group_by(gene) %>%
  summarise(drugs = paste(unique(drug_name), collapse = ", "))

# write.csv(down_drug_list_per_gene, "data/new/DrugBank/proSus_down_genes_drug_list.csv")

#now check for heart-related indications from these drugs for up and down proSus
heart_keywords <- c(
  "heart failure", "CVD", "cardiomyopathy", "cardiac", "cardio",
  "arrhythmia", "ventricular", "atrial", "myocardial",
  "coronary", "CHF", "hypertension", "blood pressure", "cardiac failure",
  "heart", "chronic heart failure", "acute heart failure"
)

#first filter for just the up and down genes without heart included
proSus_up_allind <- proSus_up_drugs %>% 
  filter(!is.na(indication))

proSus_down_allind <- proSus_down_drugs %>% 
  filter(!is.na(indication))

#filter for heart-related indications from proSus up drugs
proSus_up_heart <- proSus_up_drugs %>%
  filter(!is.na(indication)) %>%
  filter(str_detect(tolower(indication), paste(heart_keywords, collapse = "|")))

#filter for heart-related indications from proSus down drugs
proSus_down_heart <- proSus_down_drugs %>%
  filter(!is.na(indication)) %>%
  filter(str_detect(tolower(indication), paste(heart_keywords, collapse = "|")))

#summarize per gene
up_heart_summary <- proSus_up_heart %>%
  group_by(gene) %>%
  summarise(drugs = paste(unique(drug_name), collapse = ", "),
            indications = paste(unique(indication), collapse = " | "))

# write.csv(up_heart_summary, "data/new/DrugBank/heart_up_proSus_genes_list.csv")

#summarize per gene
down_heart_summary <- proSus_down_heart %>%
  group_by(gene) %>%
  summarise(drugs = paste(unique(drug_name), collapse = ", "),
            indications = paste(unique(indication), collapse = " | "))

# write.csv(down_heart_summary, "data/new/DrugBank/heart_down_proSus_genes_list.csv")


```

#dataframe
```{r Make a dataframe for proSus}

#use combined_toptables_dxr as the long dataframe already made
#classify motif membership, proSus vs notproSus membership, and SYMBOL


# Your motif sets and lists must be character vectors
final_genes_1_RUV      <- as.character(final_genes_1_RUV)
final_genes_2_RUV      <- as.character(final_genes_2_RUV)
proSus_gene_list       <- as.character(proSus_gene_list)
notproSus_gene_list    <- as.character(notproSus_gene_list)

# Function to annotate ONE toptable dataframe
annotate_one_toptable <- function(df) {
  df %>%
    mutate(
      Cluster_Membership = case_when(
        Entrez_ID %in% final_genes_1_RUV ~ "Recovered",
        Entrez_ID %in% final_genes_2_RUV ~ "Sustained",
        TRUE ~ "NoMotif"
      ),
      Response_Direction = case_when(
        Cluster_Membership == "Sustained" &
          Entrez_ID %in% proSus_gene_list ~ "proSus",
        Cluster_Membership == "Sustained" &
          Entrez_ID %in% notproSus_gene_list ~ "notproSus",
        TRUE ~ NA
      )
    )
}

#apply to all 3 timepoint-specific toptables
annotated_toptables <- lapply(combined_toptables_dxr_RUV, annotate_one_toptable)

#save these to csvs to use for metadata
# for (nm in names(annotated_toptables)) {
#   write.csv(
#     annotated_toptables[[nm]],
#     file = paste0("data/new/RUV/CMF/Annotated_Toptables_", nm, "_EMP_251125.csv"),
#     row.names = FALSE
#   )
# }

#now add the KEGG and GO:BP terms to the annotated toptables

#this function takes the gost() result and returns a gene-term dataframe
make_gene_term_df <- function(gost_result) {
  #extract the result table
  res <- gost_result$result

  #separate by source
  go_bp <- res %>%
    filter(source == "GO:BP") %>%
    dplyr::select(term_name, intersection, intersection_size) %>%
    #intersection is a comma-separated string of Entrez IDs
    separate_rows(intersection, sep = ",") %>%
    rename(Entrez_ID = intersection) %>%
    mutate(Entrez_ID = as.character(Entrez_ID),
           Entrez_ID  = trimws(Entrez_ID))

  kegg <- res %>%
    filter(source == "KEGG") %>%
    dplyr::select(term_name, intersection, intersection_size) %>%
    separate_rows(intersection, sep = ",") %>%
    rename(Entrez_ID = intersection) %>%
    mutate(Entrez_ID = as.character(Entrez_ID),
           Entrez_ID = trimws(Entrez_ID))

  list(GO_BP = go_bp, KEGG = kegg)
}

proSus_terms <- make_gene_term_df(proSus_GOKEGG_RUV)
notproSus_terms <- make_gene_term_df(notproSus_GOKEGG_RUV)
Rec_terms <- make_gene_term_df(motif1_mat_GOKEGG_RUV)
Sus_terms <- make_gene_term_df(motif2_mat_GOKEGG_RUV)

#make a function to annotate genes with terms 
annotate_with_terms <- function(df) {

  df <- df %>%
    #add in GO:BP terms
    #recovered
    left_join(Rec_terms$GO_BP %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(GO_BP_Terms_rec = paste(term_name,
                                                  collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    #sustained
    left_join(Sus_terms$GO_BP %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(GO_BP_Terms_sus = paste(term_name,
                                                  collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    #proSus
    left_join(proSus_terms$GO_BP %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(GO_BP_Terms_pro = paste(term_name,
                                              collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    #notproSus
    left_join(notproSus_terms$GO_BP %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(GO_BP_Terms_notpro = paste(term_name,
                                                     collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    mutate(
      Clust_Memb_GOBP = coalesce(GO_BP_Terms_rec,
                                      GO_BP_Terms_sus),
      Resp_Dir_GOBP = coalesce(GO_BP_Terms_pro,
                             GO_BP_Terms_notpro)
    ) %>%
    dplyr::select(-GO_BP_Terms_rec,
                  -GO_BP_Terms_sus,
                  -GO_BP_Terms_pro,
                  -GO_BP_Terms_notpro) %>%

    #KEGG terms
    #recovered
    left_join(Rec_terms$KEGG %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(KEGG_Terms_rec = paste(term_name,
                                                 collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    #sustained
    left_join(Sus_terms$KEGG %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(KEGG_Terms_sus = paste(term_name,
                                                 collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    #proSus
    left_join(proSus_terms$KEGG %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(KEGG_Terms_pro = paste(term_name,
                                             collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    #notproSus
    left_join(notproSus_terms$KEGG %>%
                group_by(Entrez_ID) %>%
                arrange(desc(intersection_size)) %>%
                summarize(KEGG_Terms_notpro = paste(term_name,
                                                    collapse = "; "),
                          .groups = "drop"),
              by = "Entrez_ID") %>%
    mutate(
      Clust_Memb_KEGG = coalesce(KEGG_Terms_rec,
                                 KEGG_Terms_sus),
      Resp_Dir_KEGG = coalesce(KEGG_Terms_pro,
                               KEGG_Terms_notpro)) %>%
    dplyr::select(-KEGG_Terms_rec,
                  -KEGG_Terms_sus,
                  -KEGG_Terms_pro,
                  -KEGG_Terms_notpro)

  return(df)
}

#coerce entrez_ids to character in this list of dataframes before joining
for (nm in names(annotated_toptables)) {
  annotated_toptables[[nm]]$Entrez_ID <- as.character(annotated_toptables[[nm]]$Entrez_ID)
}

#now join them together to get the terms added to the toptables
annotated_toptables_terms <- lapply(annotated_toptables, annotate_with_terms)


saveRDS(annotated_toptables_terms, "data/new/RUV/CMF/annotated_toptables_list_GOKEGG.RDS")

annotated_toptables_terms <- readRDS("data/new/RUV/CMF/annotated_toptables_list_GOKEGG.RDS")

#save these to csvs to use for metadata
# for (nm in names(annotated_toptables_terms)) {
#   write.csv(
#     annotated_toptables_terms[[nm]],
#     file = paste0("data/new/RUV/CMF/Annotated_Toptables_GOKEGG_sep_", nm, "_EMP_251125.csv"),
#     row.names = FALSE
#   )
# }


```

```{r Rewrite workflow}

make_gene_term_df <- function(gost_result) {

  res <- gost_result$result

  # Detect correct column that stores gene intersections
  int_col <- intersect(
    c("intersection", "intersections", "intersection_gene_ids"),
    colnames(res)
  )

  if (length(int_col) == 0) {
    stop("No intersection column found in gost table.")
  }

  int_col <- int_col[1]  # pick first matched column

  # Internal cleaner
  clean_terms <- function(df) {
    df %>%
      dplyr::select(term_name, !!sym(int_col), intersection_size) %>%   # use detected column
      tidyr::separate_rows(!!sym(int_col), sep = ",") %>%              # explode to long
      dplyr::mutate(
        Entrez_ID = trimws(as.character(!!sym(int_col))),
        Entrez_ID = gsub("[^0-9]", "", Entrez_ID)                       # keep only numeric IDs
      ) %>%
      dplyr::select(term_name, Entrez_ID, intersection_size)
  }

  list(
    GO_BP = res %>% filter(source == "GO:BP") %>% clean_terms(),
    KEGG  = res %>% filter(source == "KEGG")  %>% clean_terms()
  )
}

#build term tables for 4 categories


proSus_terms    <- make_gene_term_df(proSus_GOKEGG_RUV)
notproSus_terms <- make_gene_term_df(notproSus_GOKEGG_RUV)
Rec_terms       <- make_gene_term_df(motif1_mat_GOKEGG_RUV)
Sus_terms       <- make_gene_term_df(motif2_mat_GOKEGG_RUV)

#gene annotation table (Entrez_ID to SYMBOL)


gene_annot <- combined_toptables_dxr_list$t0 %>%
  dplyr::select(Entrez_ID, SYMBOL) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>%
  distinct()

#make list of SYMBOLs per term

make_term_gene_list <- function(term_table, gene_annot) {

  df <- left_join(term_table, gene_annot, by = "Entrez_ID")

  term_summary <- df %>%
    group_by(term_name) %>%
    arrange(desc(intersection_size)) %>%
    summarize(
      SYMBOL = list(as.character(SYMBOL)),
      max_intersection = max(intersection_size),
      .groups = "drop"
    ) %>%
    arrange(desc(max_intersection))

  term_summary$term_name <- factor(term_summary$term_name,
                                   levels = term_summary$term_name)

  #return a named list
  term_summary %>%
    select(-max_intersection) %>%
    split(.$term_name) %>%
    map(~ list(SYMBOL = .x$SYMBOL[[1]]))
}


#build the 8 final lists


Rec_GO_BP_list       <- make_term_gene_list(Rec_terms$GO_BP, gene_annot)
Sus_GO_BP_list       <- make_term_gene_list(Sus_terms$GO_BP, gene_annot)
proSus_GO_BP_list    <- make_term_gene_list(proSus_terms$GO_BP, gene_annot)
notproSus_GO_BP_list <- make_term_gene_list(notproSus_terms$GO_BP, gene_annot)

Rec_KEGG_list        <- make_term_gene_list(Rec_terms$KEGG, gene_annot)
Sus_KEGG_list        <- make_term_gene_list(Sus_terms$KEGG, gene_annot)
proSus_KEGG_list     <- make_term_gene_list(proSus_terms$KEGG, gene_annot)
notproSus_KEGG_list  <- make_term_gene_list(notproSus_terms$KEGG, gene_annot)


#Store everything in a single unified list

clust_GOKEGG_terms_list <- list(
  Rec_GOBP       = Rec_GO_BP_list,
  Sus_GOBP       = Sus_GO_BP_list,
  proSus_GOBP    = proSus_GO_BP_list,
  notproSus_GOBP = notproSus_GO_BP_list,
  Rec_KEGG       = Rec_KEGG_list,
  Sus_KEGG       = Sus_KEGG_list,
  proSus_KEGG    = proSus_KEGG_list,
  notproSus_KEGG = notproSus_KEGG_list
)

# Save RDS
# saveRDS(clust_GOKEGG_terms_list, "data/new/RUV/CMF/cluster_GOKEGG_terms_geneids.RDS"
# )


#build Excel workbook of top 10 terms

biglist <- clust_GOKEGG_terms_list
wb <- createWorkbook()

for (set_name in names(biglist)) {

  terms <- biglist[[set_name]]
  top_terms <- head(names(terms), 10)

  df_list <- map(top_terms, function(term) {
    genes <- terms[[term]]$SYMBOL
    gene_cols <- as.list(genes)
    names(gene_cols) <- paste0("gene", seq_along(genes))
    tibble(term = term, !!!gene_cols)
  })

  df <- bind_rows(df_list)

  addWorksheet(wb, sheetName = set_name)
  writeData(wb, sheet = set_name, df)
}

saveWorkbook(
  wb,
  file = file.path(output_folder, "top10_GO_KEGG_genes_new.xlsx"),
  overwrite = TRUE
)

```


```{r}
# extract KEGG term names for each set
kegg_terms_list <- list(
  Rec_KEGG       = names(clust_GOKEGG_terms_list$Rec_KEGG),
  Sus_KEGG       = names(clust_GOKEGG_terms_list$Sus_KEGG),
  proSus_KEGG    = names(clust_GOKEGG_terms_list$proSus_KEGG),
  notproSus_KEGG = names(clust_GOKEGG_terms_list$notproSus_KEGG)
)

# check
str(kegg_terms_list)

gene_annot <- combined_toptables_dxr_list$t0 %>%
  dplyr::select(Entrez_ID, SYMBOL) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>%
  distinct()

# Function to convert Entrez_ID to SYMBOL and build summary table
make_term_gene_df <- function(term_table, gene_annot) {
  term_table %>%
    left_join(gene_annot, by = "Entrez_ID") %>%
    group_by(term_name) %>%
    arrange(desc(intersection_size)) %>%
    summarize(
      Genes = paste(unique(SYMBOL), collapse = ", "),
      .groups = "drop"
    )
}

# Build list of dataframes for each KEGG set
kegg_summary_list <- list(
  Rec_KEGG = make_term_gene_df(Rec_terms$KEGG, gene_annot),
  Sus_KEGG = make_term_gene_df(Sus_terms$KEGG, gene_annot),
  proSus_KEGG = make_term_gene_df(proSus_terms$KEGG, gene_annot),
  notproSus_KEGG = make_term_gene_df(notproSus_terms$KEGG, gene_annot)
)

# Create workbook and add sheets
wb <- createWorkbook()
for(set_name in names(kegg_summary_list)) {
  df <- kegg_summary_list[[set_name]]
  addWorksheet(wb, sheetName = set_name)
  writeData(wb, sheet = set_name, df)
}
# 
# # Save workbook
# saveWorkbook(
#   wb,
#   file = file.path(output_folder, "KEGG_terms_with_genes.xlsx"),
#   overwrite = TRUE
# )
# 

```


#compare GO and KEGG
```{r GO KEGG analysis proSus notproSus Recovered Sustained}
#I want to do what I tried above and compare four gene lists and get the genes from each intersecting term for KEGG and GO BP

#take my results from above that are not combined into a toptable

proSus_terms <- make_gene_term_df(proSus_GOKEGG_RUV)
notproSus_terms <- make_gene_term_df(notproSus_GOKEGG_RUV)
Rec_terms <- make_gene_term_df(motif1_mat_GOKEGG_RUV)
Sus_terms <- make_gene_term_df(motif2_mat_GOKEGG_RUV)

#add SYMBOL into these lists of Entrez_ID
gene_annot <- combined_toptables_dxr_list$t0 %>%
  dplyr::select(Entrez_ID, SYMBOL) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>%
  distinct()

#extract the genes in each term across clusters
make_term_gene_list <- function(term_table, gene_annot) {

  # join SYMBOLs
  df <- left_join(term_table, gene_annot, by = "Entrez_ID")

  # summarize: list of genes per term, and max intersection_size for ordering terms
  term_summary <- df %>%
    group_by(term_name) %>%
    arrange(desc(intersection_size)) %>%  # order genes within term
    summarize(
      # Entrez_ID = list(as.character(Entrez_ID)),
      SYMBOL    = list(as.character(SYMBOL)),
      max_intersection = max(intersection_size),
      .groups = "drop"
    ) %>%
    arrange(desc(max_intersection))  # order terms by largest intersection_size

  # convert term_name to factor to preserve order
  term_summary$term_name <- factor(term_summary$term_name, levels = term_summary$term_name)

  # convert to named list
  term_list <- term_summary %>%
    select(-max_intersection) %>%
    split(.$term_name) %>%
    lapply(function(x) list(
      # Entrez_ID = x$Entrez_ID[[1]],
      SYMBOL    = x$SYMBOL[[1]]
    ))

  return(term_list)
}

# #GO:BP
Rec_GO_BP_list <- make_term_gene_list(Rec_terms$GO_BP, gene_annot)
Sus_GO_BP_list <- make_term_gene_list(Sus_terms$GO_BP, gene_annot)
proSus_GO_BP_list <- make_term_gene_list(proSus_terms$GO_BP, gene_annot)
notproSus_GO_BP_list <- make_term_gene_list(notproSus_terms$GO_BP, gene_annot)

#KEGG
Rec_KEGG_list <- make_term_gene_list(Rec_terms$KEGG, gene_annot)
Sus_KEGG_list <- make_term_gene_list(Sus_terms$KEGG, gene_annot)
proSus_KEGG_list <- make_term_gene_list(proSus_terms$KEGG, gene_annot)
notproSus_KEGG_list <- make_term_gene_list(notproSus_terms$KEGG, gene_annot)


clust_GOKEGG_terms_list <- list(
  Rec_GOBP = Rec_GO_BP_list,
  Sus_GOBP = Sus_GO_BP_list,
  proSus_GOBP = proSus_GO_BP_list,
  notproSus_GOBP = notproSus_GO_BP_list,
  Rec_KEGG = Rec_KEGG_list,
  Sus_KEGG = Sus_KEGG_list,
  proSus_KEGG = proSus_KEGG_list,
  notproSus_KEGG = notproSus_KEGG_list
)

saveRDS(clust_GOKEGG_terms_list, "data/new/RUV/CMF/cluster_GOKEGG_terms_geneids.RDS")

#now I've created a list of Entrez_ID and SYMBOLs that are tied to each term for each cluster set

clust_GOKEGG_terms_list <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/CMF/cluster_GOKEGG_terms_geneids.RDS")

#make these into a dataframe with SYMBOL and not Entrez_ID so it's easier to tell

biglist <- clust_GOKEGG_terms_list

#make an excel workbook
wb <- createWorkbook()

for(set_name in names(biglist)) {

  terms <- biglist[[set_name]]

  # Build wide dataframe
  df_list <- map(terms, function(term) {
    genes <- terms[[term]]$SYMBOL

    # Create named columns gene1, gene2, ...
    gene_cols <- as.list(genes)
    names(gene_cols) <- paste0("gene", seq_along(genes))

    tibble(term = term, !!!gene_cols)
  })

  df <- bind_rows(df_list)

  # Add sheet & write
  addWorksheet(wb, sheetName = set_name)
  writeData(wb, sheet = set_name, df)
}

saveWorkbook(wb,
             file = file.path(output_folder, "top10_GO_KEGG_genes_list.xlsx"),
             overwrite = TRUE)

```

#Check Intersection of GO KEGG Terms
```{r GO KEGG intersection genes}

#I want to go ahead and look at which genes are involved in each term that I have and compare them to my gene sets - are any of these genes involved in certain terms?

liu_ids <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/liu_dataset_entrez.RDS")
sapp_ids <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/sapp_dataset_entrez.RDS")
fonoudi_ids <- readRDS("C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/RUV/fonoudi_dataset_entrez.RDS") #prev DIC
CT_genes <- unique(c(fonoudi_ids, sapp_ids, liu_ids)) #201 genes total

AIC_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS") #this is now DIC
AIC_set <- unique(na.omit(AIC_genes)) #this is now DIC
p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")
p53_set <- unique(na.omit(p53_target_genes))
DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")
ddr_set <- unique(na.omit(DNA_damage_genes))

CT_gene_sets <- list(
  CT = CT_genes,
  p53 = p53_set,
  DDR = ddr_set,
  AIC = AIC_set
)

#first, find all of the Entrez_IDs that overlap between terms and CT genes
summarize_genes_in_terms <- function(term_list, gene_sets) {
  
  # term_list: named list of terms, each element has $Entrez_ID and $SYMBOL
  # gene_sets: named list of gene sets
  
  term_summary <- lapply(names(term_list), function(term_name) {
    genes_in_term <- term_list[[term_name]]$Entrez_ID
    
    # check which genes are in each gene set
    gene_set_hits <- lapply(gene_sets, function(gs) genes_in_term[genes_in_term %in% gs])
    
    # collapse to strings for table
    gene_set_hits <- lapply(gene_set_hits, function(x) if(length(x) > 0) paste(x, collapse = "; ") else NA)
    
    c(term_name = term_name, gene_set_hits)
  })
  
  # convert to data.frame
  term_summary_df <- do.call(rbind, term_summary) %>% as.data.frame(stringsAsFactors = FALSE)
  
  # rename columns: term_name + gene sets
  colnames(term_summary_df) <- c("Term", names(gene_sets))
  
  return(term_summary_df)
}

#now put together the summary tables
Rec_GOBP_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$Rec_GOBP, 
  CT_gene_sets)
Sus_GOBP_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$Sus_GOBP, 
  CT_gene_sets)
proSus_GOBP_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$proSus_GOBP, 
  CT_gene_sets)
notproSus_GOBP_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$notproSus_GOBP, 
  CT_gene_sets)

Rec_KEGG_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$Rec_KEGG,
  CT_gene_sets)
Sus_KEGG_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$Sus_KEGG,
  CT_gene_sets)
proSus_KEGG_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$proSus_KEGG,
  CT_gene_sets)
notproSus_KEGG_summary <- summarize_genes_in_terms(
  clust_GOKEGG_terms_list$notproSus_KEGG,
  CT_gene_sets)

clust_CT_overlap_GOKEGG_summaries <- list(
  Rec_GOBP = Rec_GOBP_summary,
  Sus_GOBP = Sus_GOBP_summary,
  proSus_GOBP = proSus_GOBP_summary,
  notproSus_GOBP = notproSus_GOBP_summary,
  Rec_KEGG = Rec_KEGG_summary,
  Sus_KEGG = Sus_KEGG_summary,
  proSus_KEGG = proSus_KEGG_summary,
  notproSus_KEGG = notproSus_KEGG_summary
)

#now do another one for a simpler summary to show overlap
make_term_gene_counts <- function(term_list, gene_sets) {
  
  # term_list: named list of terms, each element has $Entrez_ID and $SYMBOL
  # gene_sets: named list of gene sets
  
  term_summary <- lapply(names(term_list), function(term_name) {
    genes_in_term <- term_list[[term_name]]$Entrez_ID
    
    # count how many genes from each gene set are in this term
    gene_set_counts <- sapply(gene_sets, function(gs) sum(genes_in_term %in% gs))
    
    c(Term = term_name, gene_set_counts)
  })
  
  # convert to data.frame
  term_summary_df <- do.call(rbind, term_summary) %>% as.data.frame(stringsAsFactors = FALSE)
  
  # convert counts to numeric
  term_summary_df[, -1] <- lapply(term_summary_df[, -1], as.numeric)
  
  return(term_summary_df)
}


#now make the lists here
Rec_GOBP_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$Rec_GOBP, 
  CT_gene_sets)
Sus_GOBP_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$Sus_GOBP, 
  CT_gene_sets)
proSus_GOBP_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$proSus_GOBP,
  CT_gene_sets)
notproSus_GOBP_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$notproSus_GOBP, 
  CT_gene_sets)

# KEGG
Rec_KEGG_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$Rec_KEGG, 
  CT_gene_sets)
Sus_KEGG_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$Sus_KEGG, 
  CT_gene_sets)
proSus_KEGG_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$proSus_KEGG, 
  CT_gene_sets)
notproSus_KEGG_counts <- make_term_gene_counts(
  clust_GOKEGG_terms_list$notproSus_KEGG, 
  CT_gene_sets)


GOBP_all_summary <- bind_rows(
  Rec_GOBP_counts %>% mutate(Cluster = "Rec"),
  Sus_GOBP_counts %>% mutate(Cluster = "Sus"),
  proSus_GOBP_counts %>% mutate(Cluster = "proSus"),
  notproSus_GOBP_counts %>% mutate(Cluster = "notproSus")
)

KEGG_all_summary <- bind_rows(
  Rec_KEGG_counts %>% mutate(Cluster = "Rec"),
  Sus_KEGG_counts %>% mutate(Cluster = "Sus"),
  proSus_KEGG_counts %>% mutate(Cluster = "proSus"),
  notproSus_KEGG_counts %>% mutate(Cluster = "notproSus")
)

#try to visualize this in heatmap form
prepare_plot_data <- function(summary_df, cluster_name) {
  summary_df %>%
    filter(Cluster == cluster_name) %>%
    rowwise() %>%
    mutate(Total = sum(c(CT, p53, DDR, AIC))) %>%
    ungroup() %>%
    slice_max(order_by = Total, n = 10) %>%
    pivot_longer(cols = c("CT", "p53", "DDR", "AIC"),
                 names_to = "GeneSet",
                 values_to = "Count") %>%
    mutate(Term = factor(Term, levels = unique(Term[order(-Total)])))
}

plot_cluster_heatmap <- function(plot_data, cluster_name, category_name) {
  ggplot(plot_data, aes(x = GeneSet, y = Term, fill = Count)) +
    geom_tile(color = "white") +
    geom_text(aes(label = ifelse(Count > 0, Count, "")), 
              size = 3, 
              colour = "white") +
    scale_fill_gradient() +
    theme_custom() +
    labs(fill = "# Genes", x = "Gene Set", y = "Term",
         title = paste0(cluster_name, " Top 10 ", category_name, " Terms"))
}

clusters <- c("Rec", "Sus", "proSus", "notproSus")
categories <- c("GOBP", "KEGG")

summary_tables_GOKEGG <- list(
  "GOBP" = GOBP_all_summary,
  "KEGG" = KEGG_all_summary
)

all_plots <- list()

for(cat in categories) {
  summary_df <- summary_tables_GOKEGG[[cat]]
  
  for(clust in clusters) {
    plot_data <- prepare_plot_data(summary_df, clust)
    plot_name <- paste0(clust, "_", cat)
    
    all_plots[[plot_name]] <- plot_cluster_heatmap(plot_data, clust, cat)
  }
}

print(all_plots)

# for(name in names(all_plots)) {
#   save_plot(filename = paste0("Heatmap_", name, "_top10_Terms_EMP"),
#          plot = all_plots[[name]],
#          folder = output_folder,
#          width = 6, height = 8)
# }

```



```{r Check DEGs for Figures}
#I want to grab a group of genes of interest and see whether or not they are DEGs at each timepoint

fig_genes <- c(
  "ZMYND8", "CCNB2", "CACNA2D3", "POLQ", "TRAIP"
)

combined_toptables_dxr_RUV <- list(
  "t0"   = DOX_24T_R %>% mutate(absFC = abs(logFC)),
  "t24"  = DOX_24R_R %>% mutate(absFC = abs(logFC)),
  "t144" = DOX_144R_R %>% mutate(absFC = abs(logFC))
)

DEGs_dxr <- lapply(combined_toptables_dxr_RUV, function(df) {
  df %>%
    dplyr::filter(adj.P.Val < 0.05) %>%
    mutate(absFC = abs(logFC))
})

deg_t0_sub <- DOX_24T_R %>%
  filter(adj.P.Val < 0.05) %>% 
  filter(SYMBOL %in% fig_genes) %>%
  mutate(Time = "t0", DEG_status = "DEG")

deg_t24_sub <- DOX_24R_R %>%
  filter(adj.P.Val < 0.05) %>%
  filter(SYMBOL %in% fig_genes) %>%
  mutate(Time = "t24", DEG_status = "DEG")

deg_t144_sub <- DOX_144R_R %>%
  filter(adj.P.Val < 0.05) %>% 
  filter(SYMBOL %in% fig_genes) %>%
  mutate(Time = "t144", DEG_status = "DEG")

genes_deg_long <- bind_rows(
  deg_t0_sub,
  deg_t24_sub,
  deg_t144_sub
)

genes_complete <- expand_grid(
  SYMBOL = fig_genes,
  Time = c("t0", "t24", "t144")
) %>%
  left_join(
    genes_deg_long,
    by = c("SYMBOL", "Time")
  ) %>%
  mutate(
    DEG_status = ifelse(is.na(DEG_status), "Not DEG", DEG_status)
  )

genes_DEG_table <- genes_complete %>%
  mutate(Time = factor(Time, levels = c("t0", "t24", "t144"))) %>%
  pivot_wider(
    names_from = Time,
    values_from = c(logFC, adj.P.Val, DEG_status),
    names_sep = "_"
  ) %>%
  arrange(SYMBOL) %>% 
  dplyr::select(-...1)

genes_DEG_status_compact <- genes_complete %>%
  mutate(DEG_status = ifelse(DEG_status == "Not DEG", NA, "DEG")) %>%
  dplyr::select(SYMBOL, Time, DEG_status) %>%
  pivot_wider(
    names_from = Time,
    values_from = DEG_status
  ) %>%
  arrange(SYMBOL)




```

